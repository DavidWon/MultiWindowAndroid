diff --git a/build/target/product/sdk.mk b/build/target/product/sdk.mk
index 817d9a4..159ddff 100644
--- a/build/target/product/sdk.mk
+++ b/build/target/product/sdk.mk
@@ -62,6 +62,7 @@ PRODUCT_PACKAGES := \
 	SmokeTest \
 	SmokeTestApp \
 	rild \
+	WindowApps \
 	LegacyCamera
 
 # Define the host tools and libs that are parts of the SDK.
diff --git a/frameworks/base/Android.mk b/frameworks/base/Android.mk
index 166db4e..a4046f8 100644
--- a/frameworks/base/Android.mk
+++ b/frameworks/base/Android.mk
@@ -161,6 +161,7 @@ LOCAL_SRC_FILES += \
 	core/java/android/os/IUpdateLock.aidl \
 	core/java/android/os/IUserManager.aidl \
 	core/java/android/os/IVibratorService.aidl \
+	core/java/android/os/IWindowApps.aidl \
 	core/java/android/service/notification/INotificationListener.aidl \
 	core/java/android/print/ILayoutResultCallback.aidl \
 	core/java/android/print/IPrinterDiscoveryObserver.aidl \
diff --git a/frameworks/base/api/current.txt b/frameworks/base/api/current.txt
index 054f1cd..7609afa 100644
--- a/frameworks/base/api/current.txt
+++ b/frameworks/base/api/current.txt
@@ -2951,6 +2951,7 @@ package android.app {
     method public void moveTaskToFront(int, int, android.os.Bundle);
     method public deprecated void restartPackage(java.lang.String);
     field public static final java.lang.String META_HOME_ALTERNATE = "android.app.home.alternate";
+    field public static final int MOVE_TASK_BACK_TASKS_INVISIBLE = 4; // 0x4
     field public static final int MOVE_TASK_NO_USER_ACTION = 2; // 0x2
     field public static final int MOVE_TASK_WITH_HOME = 1; // 0x1
     field public static final int RECENT_IGNORE_UNAVAILABLE = 2; // 0x2
@@ -4394,6 +4395,11 @@ package android.app {
     field public static final java.lang.String WALLPAPER_PREVIEW_META_DATA = "android.wallpaper.preview";
   }
 
+  public class WindowAppsManager {
+    method public java.lang.String getWindowApps();
+    method public void setWindowApps(java.lang.String);
+  }
+
 }
 
 package android.app.admin {
@@ -6015,6 +6021,7 @@ package android.content {
     field public static final java.lang.String WALLPAPER_SERVICE = "wallpaper";
     field public static final java.lang.String WIFI_P2P_SERVICE = "wifip2p";
     field public static final java.lang.String WIFI_SERVICE = "wifi";
+    field public static final java.lang.String WINDOW_APPS_SERVICE = "window_apps";
     field public static final java.lang.String WINDOW_SERVICE = "window";
   }
 
@@ -28715,8 +28722,10 @@ package android.view {
     method public java.lang.String debug(java.lang.String);
     method public int describeContents();
     method public final java.lang.CharSequence getTitle();
+    method public void getWindowingParam();
     method public static boolean mayUseInputMethod(int);
     method public final void setTitle(java.lang.CharSequence);
+    method public void setWindowingParam();
     method public void writeToParcel(android.os.Parcel, int);
     field public static final int ALPHA_CHANGED = 128; // 0x80
     field public static final int ANIMATION_CHANGED = 16; // 0x10
@@ -28813,6 +28822,10 @@ package android.view {
     field public static final int TYPE_SYSTEM_OVERLAY = 2006; // 0x7d6
     field public static final int TYPE_TOAST = 2005; // 0x7d5
     field public static final int TYPE_WALLPAPER = 2013; // 0x7dd
+    field public int WindowingH;
+    field public int WindowingW;
+    field public int WindowingX;
+    field public int WindowingY;
     field public float alpha;
     field public float buttonBrightness;
     field public float dimAmount;
@@ -28821,6 +28834,8 @@ package android.view {
     field public int gravity;
     field public float horizontalMargin;
     field public float horizontalWeight;
+    field public boolean isFullscreen;
+    field public boolean isInWindowing;
     field public deprecated int memoryType;
     field public java.lang.String packageName;
     field public int rotationAnimation;
diff --git a/frameworks/base/core/java/android/app/Activity.java b/frameworks/base/core/java/android/app/Activity.java
index e29f8ea..fb87a18 100644
--- a/frameworks/base/core/java/android/app/Activity.java
+++ b/frameworks/base/core/java/android/app/Activity.java
@@ -4207,7 +4207,7 @@ public class Activity extends ContextThemeWrapper
                 resultCode = mResultCode;
                 resultData = mResultData;
             }
-            if (false) Log.v(TAG, "Finishing self: token=" + mToken);
+            if (true) Log.v(TAG, "Finishing self: token=" + mToken);
             try {
                 if (resultData != null) {
                     resultData.prepareToLeaveProcess();
diff --git a/frameworks/base/core/java/android/app/ActivityManager.java b/frameworks/base/core/java/android/app/ActivityManager.java
index bb04063..256126e 100644
--- a/frameworks/base/core/java/android/app/ActivityManager.java
+++ b/frameworks/base/core/java/android/app/ActivityManager.java
@@ -948,6 +948,18 @@ public class ActivityManager {
     public static final int MOVE_TASK_NO_USER_ACTION = 0x00000002;
 
     /**
+     * Ritter_multi
+     * Flag for {@link #moveTaskToFront(int, int)}: When moveTaskToFront()
+     * called, then resumeTopActivitiesLocked(), updateConfigurationLocked(),
+     * ensureActivitiesVisibleLocked() will be called, when ensure...() called,
+     * the other TASK in the same STACK will be set to visible until a full screen APP shows,
+     * so if we move a non full screen TASK to front, other TASK behind it will show too.
+     * To avoid this situation,
+     * I use this flag to control the BACK TASK in the some STACK not visible.
+     */
+    public static final int MOVE_TASK_BACK_TASKS_INVISIBLE = 0x00000004;
+
+    /**
      * Equivalent to calling {@link #moveTaskToFront(int, int, Bundle)}
      * with a null options argument.
      *
diff --git a/frameworks/base/core/java/android/app/ActivityManagerNative.java b/frameworks/base/core/java/android/app/ActivityManagerNative.java
index 74266cc..f2013d6 100644
--- a/frameworks/base/core/java/android/app/ActivityManagerNative.java
+++ b/frameworks/base/core/java/android/app/ActivityManagerNative.java
@@ -2028,6 +2028,23 @@ public abstract class ActivityManagerNative extends Binder implements IActivityM
             reply.writeNoException();
             return true;
         }
+
+        //Ritter_Multi
+        case RITTER_MOVE_HOME_TO_TOP: {
+            data.enforceInterface(IActivityManager.descriptor);
+            moveHomeToTop();
+            reply.writeNoException();
+            return true;
+        }
+
+        //Ritter_Multi
+/*        case RITTER_MOVE_TASK_TO_TOP: {
+            data.enforceInterface(IActivityManager.descriptor);
+            int taskID = data.readInt();
+            moveTaskToTop_AM(taskID);
+            reply.writeNoException();
+            return true;
+        }*/
         }
 
         return super.onTransact(code, data, reply, flags);
@@ -4661,4 +4678,29 @@ class ActivityManagerProxy implements IActivityManager
     }
 
     private IBinder mRemote;
+
+    //Ritter_Multi
+    @Override
+    public void moveHomeToTop() throws RemoteException {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        mRemote.transact(RITTER_MOVE_HOME_TO_TOP, data, reply, 0);
+        reply.readException();
+        data.recycle();
+        reply.recycle();
+    }
+    //Ritter_Multi
+/*    @Override
+    public void moveTaskToTop_AM(int taskID) throws RemoteException {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        data.writeInt(taskID);
+        mRemote.transact(RITTER_MOVE_TASK_TO_TOP, data, reply, 0);
+        reply.readException();
+        reply.recycle();
+        data.recycle();
+    }*/
+
 }
diff --git a/frameworks/base/core/java/android/app/ActivityThread.java b/frameworks/base/core/java/android/app/ActivityThread.java
index df63ab3..1aa300c 100644
--- a/frameworks/base/core/java/android/app/ActivityThread.java
+++ b/frameworks/base/core/java/android/app/ActivityThread.java
@@ -558,6 +558,7 @@ public final class ActivityThread {
 
         public final void schedulePauseActivity(IBinder token, boolean finished,
                 boolean userLeaving, int configChanges) {
+            Log.d(TAG,"Ritter::ActivityThread ApplicationThreadNative: schedulePauseActivity()");
             queueOrSendMessage(
                     finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,
                     token,
diff --git a/frameworks/base/core/java/android/app/ApplicationThreadNative.java b/frameworks/base/core/java/android/app/ApplicationThreadNative.java
index 347d43f..ee5f1c3 100644
--- a/frameworks/base/core/java/android/app/ApplicationThreadNative.java
+++ b/frameworks/base/core/java/android/app/ApplicationThreadNative.java
@@ -33,6 +33,7 @@ import android.os.RemoteException;
 import android.os.IBinder;
 import android.os.Parcel;
 import android.os.ParcelFileDescriptor;
+import android.util.Log;
 
 import java.io.FileDescriptor;
 import java.io.IOException;
@@ -651,6 +652,7 @@ class ApplicationThreadProxy implements IApplicationThread {
     
     public final void schedulePauseActivity(IBinder token, boolean finished,
             boolean userLeaving, int configChanges) throws RemoteException {
+        Log.d("TAG","Ritter::ApplicationThread ApplicationThreadProxy: schedulePauseActivity()");
         Parcel data = Parcel.obtain();
         data.writeInterfaceToken(IApplicationThread.descriptor);
         data.writeStrongBinder(token);
diff --git a/frameworks/base/core/java/android/app/ContextImpl.java b/frameworks/base/core/java/android/app/ContextImpl.java
index 190ddb4..1ac0489 100644
--- a/frameworks/base/core/java/android/app/ContextImpl.java
+++ b/frameworks/base/core/java/android/app/ContextImpl.java
@@ -84,6 +84,7 @@ import android.os.Handler;
 import android.os.IBinder;
 import android.os.IPowerManager;
 import android.os.IUserManager;
+import android.os.IWindowApps;
 import android.os.Looper;
 import android.os.PowerManager;
 import android.os.Process;
@@ -587,6 +588,14 @@ class ContextImpl extends Context {
             public Object createService(ContextImpl ctx) {
                 return new ConsumerIrManager(ctx);
             }});
+
+        //Ritter_nulti
+        registerService(WINDOW_APPS_SERVICE, new ServiceFetcher() {
+            public Object createService(ContextImpl ctx) {
+                IBinder b = ServiceManager.getService(Context.WINDOW_APPS_SERVICE);
+                IWindowApps service = IWindowApps.Stub.asInterface(b);
+                return new WindowAppsManager(service,ctx);
+            }});
     }
 
     static ContextImpl getImpl(Context context) {
diff --git a/frameworks/base/core/java/android/app/IActivityManager.java b/frameworks/base/core/java/android/app/IActivityManager.java
index 77c2ea0..0194fda 100644
--- a/frameworks/base/core/java/android/app/IActivityManager.java
+++ b/frameworks/base/core/java/android/app/IActivityManager.java
@@ -408,6 +408,11 @@ public interface IActivityManager extends IInterface {
 
     public void performIdleMaintenance() throws RemoteException;
 
+    //Ritter_Multi
+    public void moveHomeToTop() throws RemoteException;
+
+    //Ritter_Multi
+//    public void moveTaskToTop_AM(int taskID) throws RemoteException;
     /*
      * Private non-Binder interfaces
      */
@@ -694,4 +699,7 @@ public interface IActivityManager extends IInterface {
     int RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+180;
     int GET_PERSISTED_URI_PERMISSIONS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+181;
     int APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+182;
+    //Ritter_Multi
+    int RITTER_MOVE_HOME_TO_TOP = IBinder.FIRST_CALL_TRANSACTION+183;
+//    int RITTER_MOVE_TASK_TO_TOP = IBinder.FIRST_CALL_TRANSACTION+184;
 }
diff --git a/frameworks/base/core/java/android/app/WindowAppsManager.java b/frameworks/base/core/java/android/app/WindowAppsManager.java
new file mode 100644
index 0000000..aea83f9
--- /dev/null
+++ b/frameworks/base/core/java/android/app/WindowAppsManager.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import android.content.Context;
+import android.os.IWindowApps;
+import android.os.RemoteException;
+import android.util.Log;
+
+/**
+ */
+public class WindowAppsManager {
+    private static final String TAG = "WindowAppsManager";
+    private final IWindowApps mService;
+
+
+    /**
+     * package private on purpose
+     */
+    WindowAppsManager(IWindowApps service, Context ctx) {
+        mService = service;
+        if(mService==null){
+            Log.d("TAG","Ritter::AIDL WindowAppsManager() mService==null");
+        } else {
+            Log.d("TAG","Ritter::AIDL WindowAppsManager() mService!=null");
+        }
+    }
+
+    public void setWindowApps(String pkgNames){
+        try {
+            mService.setWindowApps(pkgNames);
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+    }
+
+    public String getWindowApps(){
+        String res = "";
+        try {
+            res = mService.getWindowApps();
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        return res;
+    }
+
+}
diff --git a/frameworks/base/core/java/android/content/Context.java b/frameworks/base/core/java/android/content/Context.java
index 2e4e209..a14a947 100644
--- a/frameworks/base/core/java/android/content/Context.java
+++ b/frameworks/base/core/java/android/content/Context.java
@@ -2454,6 +2454,17 @@ public abstract class Context {
      */
     public static final String CONSUMER_IR_SERVICE = "consumer_ir";
 
+    //Ritter_multi
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.os.WindowAppsService} for Windowing APPs list
+     *
+     * @see #getSystemService
+     * @see android.os.WindowAppsService
+     */
+    public static final String WINDOW_APPS_SERVICE = "window_apps";
+    //end
+
     /**
      * Determine whether the given permission is allowed for a particular
      * process and user ID running in the system.
diff --git a/frameworks/base/core/java/android/os/IWindowApps.aidl b/frameworks/base/core/java/android/os/IWindowApps.aidl
new file mode 100644
index 0000000..ce9c2e4
--- /dev/null
+++ b/frameworks/base/core/java/android/os/IWindowApps.aidl
@@ -0,0 +1,27 @@
+/* //device/java/android/android/os/IPowerManager.aidl
+**
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package android.os;
+
+/**
+ * {@hide}
+ */
+interface IWindowApps
+{
+    void setWindowApps(String pkgName);
+    String getWindowApps();
+}
diff --git a/frameworks/base/core/java/android/view/IWindowSession.aidl b/frameworks/base/core/java/android/view/IWindowSession.aidl
index c32a2c9..2995fe7 100644
--- a/frameworks/base/core/java/android/view/IWindowSession.aidl
+++ b/frameworks/base/core/java/android/view/IWindowSession.aidl
@@ -191,4 +191,19 @@ interface IWindowSession {
     void onRectangleOnScreenRequested(IBinder token, in Rect rectangle, boolean immediate);
 
     IWindowId getWindowId(IBinder window);
+
+    /**
+     * Ritter_Multi
+     */
+    void moveHomeToTop_WS();
+
+    /**
+     * Ritter_Multi
+     */
+    void moveTaskToTop_WS(int taskID);
+
+    /**
+     * Ritter_Multi
+     */
+    boolean getMyWindowStateAttrs(IWindow window, out Rect outRect);
 }
diff --git a/frameworks/base/core/java/android/view/ViewRootImpl.java b/frameworks/base/core/java/android/view/ViewRootImpl.java
index 9461068..8410c5e 100644
--- a/frameworks/base/core/java/android/view/ViewRootImpl.java
+++ b/frameworks/base/core/java/android/view/ViewRootImpl.java
@@ -18,7 +18,9 @@ package android.view;
 
 import android.Manifest;
 import android.animation.LayoutTransition;
+import android.app.Activity;
 import android.app.ActivityManagerNative;
+import android.app.WindowAppsManager;
 import android.content.ClipDescription;
 import android.content.ComponentCallbacks;
 import android.content.ComponentCallbacks2;
@@ -81,6 +83,7 @@ import java.io.IOException;
 import java.io.OutputStream;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashSet;
 
 /**
@@ -98,7 +101,7 @@ public final class ViewRootImpl implements ViewParent,
     private static final boolean LOCAL_LOGV = false;
     /** @noinspection PointlessBooleanExpression*/
     private static final boolean DEBUG_DRAW = false || LOCAL_LOGV;
-    private static final boolean DEBUG_LAYOUT = false || LOCAL_LOGV;
+    private static final boolean DEBUG_LAYOUT = true || LOCAL_LOGV;
     private static final boolean DEBUG_DIALOG = false || LOCAL_LOGV;
     private static final boolean DEBUG_INPUT_RESIZE = false || LOCAL_LOGV;
     private static final boolean DEBUG_ORIENTATION = false || LOCAL_LOGV;
@@ -144,6 +147,13 @@ public final class ViewRootImpl implements ViewParent,
 
     final WindowManager.LayoutParams mWindowAttributes = new WindowManager.LayoutParams();
 
+    //Ritter_multi
+    public WindowManager.LayoutParams getLayoutParams(){
+        return mWindowAttributes;
+    }
+    private boolean isFirstAddWindow = false;
+    //end
+
     final W mWindow;
 
     final int mTargetSdkVersion;
@@ -334,6 +344,7 @@ public final class ViewRootImpl implements ViewParent,
     }
 
     public ViewRootImpl(Context context, Display display) {
+        Log.d(TAG,"Ritter::VRI ViewRootImpl()");
         mContext = context;
         mWindowSession = WindowManagerGlobal.getWindowSession();
         mDisplay = display;
@@ -424,12 +435,22 @@ public final class ViewRootImpl implements ViewParent,
      * We have one child
      */
     public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
+        Log.d(TAG,"Ritter::VRI setView() attrs x:"+attrs.x+"" +
+                ",y:"+attrs.y+
+                ",w:"+attrs.width+
+                ",h:"+attrs.height+
+                ",pkgName:"+attrs.packageName+
+                ",isInWindowing:"+attrs.isInWindowing
+                );
         synchronized (this) {
             if (mView == null) {
                 mView = view;
                 mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
                 mFallbackEventHandler.setView(view);
                 mWindowAttributes.copyFrom(attrs);
+                //Ritter_multi
+                isFirstAddWindow = true;
+                //end
                 if (mWindowAttributes.packageName == null) {
                     mWindowAttributes.packageName = mBasePackageName;
                 }
@@ -743,6 +764,13 @@ public final class ViewRootImpl implements ViewParent,
     }
 
     void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView) {
+        Log.d(TAG,"Ritter::VRI setLayoutParams() attrs x:"+attrs.x+"" +
+                ",y:"+attrs.y+
+                ",w:"+attrs.width+
+                ",h:"+attrs.height+
+                ",pkgName:"+attrs.packageName+
+                ",isInWindowing:"+attrs.isInWindowing
+                );
         synchronized (this) {
             int oldSoftInputMode = mWindowAttributes.softInputMode;
             // Keep track of the actual window flags supplied by the client.
@@ -818,6 +846,7 @@ public final class ViewRootImpl implements ViewParent,
 
     @Override
     public void requestLayout() {
+        Log.d(TAG,"Ritter VRI W handleMessage requestLayout()");
         if (!mHandlingLayoutInLayoutRequest) {
             checkThread();
             mLayoutRequested = true;
@@ -966,6 +995,7 @@ public final class ViewRootImpl implements ViewParent,
     }
 
     void scheduleTraversals() {
+        Log.d(TAG,"Ritter VRI W handleMessage scheduleTraversals()");
         if (!mTraversalScheduled) {
             mTraversalScheduled = true;
             mTraversalBarrier = mHandler.getLooper().postSyncBarrier();
@@ -1125,6 +1155,7 @@ public final class ViewRootImpl implements ViewParent,
 
     private void performTraversals() {
         // cache mView since it is used so much below...
+        Log.d(TAG,"Ritter::VRI performTraversals()");
         final View host = mView;
 
         if (DBG) {
@@ -1141,8 +1172,73 @@ public final class ViewRootImpl implements ViewParent,
         boolean windowSizeMayChange = false;
         boolean newSurface = false;
         boolean surfaceChanged = false;
+
+        //Ritter_multi new
+        /*  The mWindowAttributes set in WMS::addWindow() will lose,
+         * I don't know why, so I have to use my own method get its value
+         * and set here.
+         * */
+        if (isFirstAddWindow) {
+            Rect out = new Rect();
+            if (getMyWindowStateAttrs(out)) {
+                Log.d(TAG, "Ritter::VRI performTraversals() out.x:" + out.left
+                        + ",y:" + out.top + ",w:" + (out.right - out.left)
+                        + ",h:" + (out.bottom - out.top));
+                mWindowAttributes.x = out.left;
+                mWindowAttributes.y = out.top;
+                mWindowAttributes.width = (out.right - out.left);
+                mWindowAttributes.height = (out.bottom - out.top);
+                mWindowAttributes.setWindowingParam();
+
+                if (mContext instanceof Activity) {
+                    Activity activity = (Activity) mContext;
+                    int screenWidth = activity.getWindowManager()
+                            .getDefaultDisplay().getWidth();
+                    int screenHeight = activity.getWindowManager()
+                            .getDefaultDisplay().getHeight();
+
+
+                    // Get window apps from service
+                    String APPs = "";
+                    WindowAppsManager mWindowAppsManager = (WindowAppsManager) mContext
+                            .getSystemService("window_apps");
+                    try {
+                        APPs = mWindowAppsManager.getWindowApps();
+                    } catch (Exception e){
+                        e.printStackTrace();
+                    }
+                    ArrayList<String> pkgList = new ArrayList<String>(Arrays.asList(APPs.split("#")));
+
+                    if (pkgList.contains(activity.getComponentName().getPackageName())
+                            && !activity.getComponentName().getPackageName().isEmpty()) {
+                        mWindowAttributes.isFullscreen = false;
+                    }
+
+//                    if (activity.getComponentName().getPackageName()
+//                            .equals("com.example.activity")) {
+//                        mWindowAttributes.isFullscreen = false;
+//                    }
+                }
+            }
+            isFirstAddWindow = false;
+        }
+        // end
+
         WindowManager.LayoutParams lp = mWindowAttributes;
 
+        //Ritter_multi new
+        Log.d(TAG,
+                "Ritter::VRI performTraversals() mWindowAttributes.mAttrs.x:"
+                        + mWindowAttributes.x + ",mAttrs.y:"
+                        + mWindowAttributes.y + ",mAttrs.w:"
+                        + mWindowAttributes.width + ",mAttrs.h:"
+                        + mWindowAttributes.height
+                        + ",mAttrs.isInWindowing:"
+                        + mWindowAttributes.isInWindowing
+                        + ",mAttrs.pkgName:"
+                        + mWindowAttributes.packageName);
+        //end
+
         int desiredWindowWidth;
         int desiredWindowHeight;
 
@@ -1336,6 +1432,16 @@ public final class ViewRootImpl implements ViewParent,
             }
             mAttachInfo.mOverscanRequested = (params.flags
                     & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
+            Log.d(TAG,
+                    "Ritter::VRI performTraversals() params != null win.mAttrs.x:"
+                            + params.x + ",mAttrs.y:"
+                            + params.y + ",mAttrs.w:"
+                            + params.width + ",mAttrs.h:"
+                            + params.height
+                            + ",mAttrs.isInWindowing:"
+                            + params.isInWindowing
+                            + ",mAttrs.pkgName:"
+                            + params.packageName);
         }
 
         if (mFitSystemWindowsRequested) {
@@ -1667,9 +1773,25 @@ public final class ViewRootImpl implements ViewParent,
                         (relayoutResult&WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
                 if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()
                         || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
+                    //Ritter_multi old
                     int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
                     int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
 
+                    //Ritter_multi new
+/*                    int childWidthMeasureSpec, childHeightMeasureSpec;
+                    if(lp.isInWindowing){
+                        // Force the window APP in here to MATCH_PARENT
+                        // otherwise, the ActionBarView will throw error
+                        childWidthMeasureSpec = getRootMeasureSpec(mWidth, ViewGroup.LayoutParams.FILL_PARENT);
+                        childHeightMeasureSpec = getRootMeasureSpec(mHeight, ViewGroup.LayoutParams.FILL_PARENT);
+                    } else {
+//                        childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
+//                        childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
+                        childWidthMeasureSpec = getRootMeasureSpec(mWidth, ViewGroup.LayoutParams.FILL_PARENT);
+                        childHeightMeasureSpec = getRootMeasureSpec(mHeight, ViewGroup.LayoutParams.FILL_PARENT);
+                    }*/
+                    //end
+
                     if (DEBUG_LAYOUT) Log.v(TAG, "Ooops, something changed!  mWidth="
                             + mWidth + " measuredWidth=" + host.getMeasuredWidth()
                             + " mHeight=" + mHeight
@@ -3050,7 +3172,9 @@ public final class ViewRootImpl implements ViewParent,
                 }
                 } // fall through...
             case MSG_RESIZED_REPORT:
+                Log.d(TAG,"Ritter VRI W handleMessage MSG_RESIZED_REPORT");
                 if (mAdded) {
+                    Log.d(TAG,"Ritter VRI W handleMessage MSG_RESIZED_REPORT mAdded==true");
                     SomeArgs args = (SomeArgs) msg.obj;
 
                     Configuration config = (Configuration) args.arg4;
@@ -5090,7 +5214,19 @@ public final class ViewRootImpl implements ViewParent,
 
     private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
             boolean insetsPending) throws RemoteException {
-
+        Log.d(TAG,"Ritter::VRI relayoutWindow()");
+        if (params != null){
+        Log.d(TAG,
+                "Ritter::VRI relayoutWindow() win.mAttrs.x:"
+                        + params.x + ",mAttrs.y:"
+                        + params.y + ",mAttrs.w:"
+                        + params.width + ",mAttrs.h:"
+                        + params.height
+                        + ",mAttrs.isInWindowing:"
+                        + params.isInWindowing
+                        + ",mAttrs.pkgName:"
+                        + params.packageName);
+        }
         float appScale = mAttachInfo.mApplicationScale;
         boolean restore = false;
         if (params != null && mTranslator != null) {
@@ -5248,6 +5384,7 @@ public final class ViewRootImpl implements ViewParent,
     }
 
     void doDie() {
+        Log.d(TAG,"Ritter::VRI doDie()");
         checkThread();
         if (LOCAL_LOGV) Log.v(TAG, "DIE in " + this + " of " + mSurface);
         synchronized (this) {
@@ -5346,7 +5483,7 @@ public final class ViewRootImpl implements ViewParent,
 
     public void dispatchResized(Rect frame, Rect overscanInsets, Rect contentInsets,
             Rect visibleInsets, boolean reportDraw, Configuration newConfig) {
-        if (DEBUG_LAYOUT) Log.v(TAG, "Resizing " + this + ": frame=" + frame.toShortString()
+        if (DEBUG_LAYOUT) Log.d(TAG, "Resizing " + this + ": frame=" + frame.toShortString()
                 + " contentInsets=" + contentInsets.toShortString()
                 + " visibleInsets=" + visibleInsets.toShortString()
                 + " reportDraw=" + reportDraw);
@@ -5591,6 +5728,56 @@ public final class ViewRootImpl implements ViewParent,
 
         @Override
         public void onInputEvent(InputEvent event) {
+            Log.d(TAG,"Ritter::VRI onInputEvent()");
+            if(event instanceof MotionEvent){
+                Log.d(TAG,"Ritter::VRI onInputEvent() MotionEvent");
+                final MotionEvent motionEvent = (MotionEvent)event;
+                if(motionEvent.getAction()==MotionEvent.ACTION_DOWN){
+                    Log.d(TAG,"Ritter::VRI onInputEvent() MotionEvent DOWN");
+                    Log.d(TAG,"Ritter::VRI onInputEvent() mWindowAttributes.packageName:" + mWindowAttributes.packageName);
+                    Log.d(TAG,"Ritter::VRI onInputEvent() mContext.getPackageName():" + mContext.getPackageName()
+                            + ",mContext.getBasePackageName():" + mContext.getBasePackageName()
+                            + ",mContext.getOpPackageName():" + mContext.getOpPackageName());
+
+                    Activity activity = null;
+                    boolean isActivity = false;
+                    if(mContext instanceof Activity){
+                        activity = (Activity)mContext;
+                        isActivity = true;
+                        Log.d(TAG,"Ritter::VRI onInputEvent() mContext instanceof Activity a.getTaskId():" + activity.getTaskId());
+                    }else{
+                        Log.d(TAG,"Ritter::VRI onInputEvent() mContext !instanceof Activity ");
+                    }
+
+                    if(!mView.hasWindowFocus()) {
+//                        sWindowSession.handleFocusChange(mWindowAttributes.token);
+                        Log.d(TAG,"Ritter::VRI onInputEvent() !hasWindowFocus:" + mWindowAttributes.packageName);
+                        Log.d(TAG,"Ritter::VRI onInputEvent() !hasWindowFocus mContext.getPackageName():" + mContext.getPackageName()
+                                + ",mContext.getBasePackageName():" + mContext.getBasePackageName()
+                                + ",mContext.getOpPackageName():" + mContext.getOpPackageName());
+                        Log.d(TAG,"Ritter::VRI onInputEvent() !hasWindowFocus mContext.getApplicationInfo().packageName:" + mContext.getApplicationInfo().packageName
+                                +",mContext.getApplicationInfo().className:" + mContext.getApplicationInfo().className);
+                        //Ritter_Multi
+                        if(isActivity&&!mContext.getPackageName().equals("com.android.launcher")){
+                            Log.d(TAG,"Ritter::VRI onInputEvent() !hasWindowFocus: Not Touch on launcher:"+mContext.getPackageName());
+                            try{
+                                mWindowSession.moveTaskToTop_WS(activity.getTaskId());
+//                                mWindowSession.moveHomeToTop_WS();
+                            }
+                            catch(RemoteException e){
+                            }
+                        }else{
+                            Log.d(TAG,"Ritter::VRI onInputEvent() !hasWindowFocus: Touch on launcher, do nothing");
+                        }
+                    }else{
+                        Log.d(TAG,"Ritter::VRI onInputEvent() hasWindowFocus:"+mWindowAttributes.packageName);
+                    }
+                } else if(motionEvent.getAction()==MotionEvent.ACTION_MOVE){
+                    Log.d(TAG,"Ritter::VRI onInputEvent() MotionEvent MOVE");
+                } else if(motionEvent.getAction()==MotionEvent.ACTION_UP){
+                    Log.d(TAG,"Ritter::VRI onInputEvent() MotionEvent UP");
+                }
+            }
             enqueueInputEvent(event, this, 0, true);
         }
 
@@ -6095,6 +6282,11 @@ public final class ViewRootImpl implements ViewParent,
         @Override
         public void resized(Rect frame, Rect overscanInsets, Rect contentInsets,
                 Rect visibleInsets, boolean reportDraw, Configuration newConfig) {
+            Log.d(TAG,"Ritter VRI W::resized() reportDraw:"+reportDraw);
+            //Ritter_multi new
+//            reportDraw = true;
+            //end
+
             final ViewRootImpl viewAncestor = mViewAncestor.get();
             if (viewAncestor != null) {
                 viewAncestor.dispatchResized(frame, overscanInsets, contentInsets,
@@ -6104,6 +6296,7 @@ public final class ViewRootImpl implements ViewParent,
 
         @Override
         public void moved(int newX, int newY) {
+            Log.d(TAG,"Ritter VRI W::moved() newX:"+newX+",newY:"+newY);
             final ViewRootImpl viewAncestor = mViewAncestor.get();
             if (viewAncestor != null) {
                 viewAncestor.dispatchMoved(newX, newY);
@@ -6616,4 +6809,95 @@ public final class ViewRootImpl implements ViewParent,
             }
         }
     }
+
+    //Ritter_multi for public
+    @SuppressWarnings("finally")
+    public int relayoutWindowPublic(WindowManager.LayoutParams params, int viewVisibility,
+            boolean insetsPending){
+        Log.d(TAG,"Ritter::VRI relayoutWindowPublic()");
+        if(params!=null)Log.d(TAG,"Ritter::VRI relayoutWindowPublic() params x:"+params.x
+                +",y:"+params.y
+                +",width:"+params.width
+                +",height:"+params.height
+                +",pkgName:"+params.packageName
+                +",isInWindowing:"+params.isInWindowing);
+/*        int res =0;
+        try {
+            res = mWindowSession.relayout(
+                    mWindow, mSeq, params,
+                    800,
+                    800,
+                    viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,
+                    mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
+                    mPendingConfiguration, mSurface);
+        } catch (RemoteException e) {
+        } finally {
+            return res;
+        }*/
+        int res = 0;
+        float appScale = mAttachInfo.mApplicationScale;
+        boolean restore = false;
+        if (params != null && mTranslator != null) {
+            restore = true;
+            params.backup();
+            mTranslator.translateWindowLayout(params);
+        }
+        if (params != null) {
+            if (true)
+                Log.d(TAG, "WindowLayout in layoutWindow:" + params);
+        }
+        mPendingConfiguration.seq = 0;
+        // Log.d(TAG, ">>>>>> CALLING relayout");
+        if (params != null && mOrigWindowType != params.type) {
+            // For compatibility with old apps, don't crash here.
+            if (mTargetSdkVersion < android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+                Slog.w(TAG, "Window type can not be changed after "
+                        + "the window is added; ignoring change of " + mView);
+                params.type = mOrigWindowType;
+            }
+        }
+        try {
+            if(params!=null)Log.d(TAG,"Ritter::VRI relayoutWindowPublic() before WMS::relayout params x:"+params.x
+                    +",y:"+params.y
+                    +",width:"+params.width
+                    +",height:"+params.height
+                    +",pkgName:"+params.packageName
+                    +",isInWindowing:"+params.isInWindowing);
+            res = mWindowSession.relayout(mWindow, mSeq, params,
+                    params.width,
+                    params.height,
+                    viewVisibility,
+                    insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING
+                            : 0, mWinFrame, mPendingOverscanInsets,
+                    mPendingContentInsets, mPendingVisibleInsets,
+                    mPendingConfiguration, mSurface);
+        } catch (RemoteException e) {
+            return res;
+        }
+
+        if (restore) {
+            params.restore();
+        }
+
+        if (mTranslator != null) {
+            mTranslator.translateRectInScreenToAppWinFrame(mWinFrame);
+            mTranslator
+                    .translateRectInScreenToAppWindow(mPendingOverscanInsets);
+            mTranslator.translateRectInScreenToAppWindow(mPendingContentInsets);
+            mTranslator.translateRectInScreenToAppWindow(mPendingVisibleInsets);
+        }
+        return res;
+    }
+
+    public boolean getMyWindowStateAttrs(Rect outRect){
+        Log.d(TAG,"Ritter::VRI getMyWindowStateAttrs()");
+        boolean res = false;
+        try {
+            res = mWindowSession.getMyWindowStateAttrs(mWindow, outRect);
+        } catch (RemoteException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        return res;
+    }
 }
diff --git a/frameworks/base/core/java/android/view/Window.java b/frameworks/base/core/java/android/view/Window.java
index b3a0699..4631fd1 100644
--- a/frameworks/base/core/java/android/view/Window.java
+++ b/frameworks/base/core/java/android/view/Window.java
@@ -25,6 +25,7 @@ import android.net.Uri;
 import android.os.Bundle;
 import android.os.IBinder;
 import android.os.SystemProperties;
+import android.util.Log;
 import android.view.accessibility.AccessibilityEvent;
 
 /**
@@ -792,6 +793,13 @@ public abstract class Window {
      *          current values.
      */
     public void setAttributes(WindowManager.LayoutParams a) {
+        Log.d("Window","Ritter::Window setAttributes() attrs x:"+a.x+"" +
+                ",y:"+a.y+
+                ",w:"+a.width+
+                ",h:"+a.height+
+                ",pkgName:"+a.packageName+
+                ",isInWindowing:"+a.isInWindowing
+                );
         mWindowAttributes.copyFrom(a);
         if (mCallback != null) {
             mCallback.onWindowAttributesChanged(mWindowAttributes);
diff --git a/frameworks/base/core/java/android/view/WindowManager.java b/frameworks/base/core/java/android/view/WindowManager.java
index 0ce4da5..932531f 100644
--- a/frameworks/base/core/java/android/view/WindowManager.java
+++ b/frameworks/base/core/java/android/view/WindowManager.java
@@ -105,6 +105,28 @@ public interface WindowManager extends ViewManager {
 
     public static class LayoutParams extends ViewGroup.LayoutParams
             implements Parcelable {
+        //Ritter_multi add a flag for windowing
+        public boolean isInWindowing = false;
+        public boolean isFullscreen = true;
+        public int WindowingX;
+        public int WindowingY;
+        public int WindowingW;
+        public int WindowingH;
+
+        public void setWindowingParam(){
+            WindowingX = x;
+            WindowingY = y;
+            WindowingW = width;
+            WindowingH = height;
+        }
+
+        public void getWindowingParam(){
+            x = WindowingX;
+            y = WindowingY;
+            width = WindowingW;
+            height = WindowingH;
+        }
+        //end
         /**
          * X position for this window.  With the default gravity it is ignored.
          * When using {@link Gravity#LEFT} or {@link Gravity#START} or {@link Gravity#RIGHT} or
@@ -1525,6 +1547,14 @@ public interface WindowManager extends ViewManager {
         }
 
         public void writeToParcel(Parcel out, int parcelableFlags) {
+            //Ritter_multi
+            out.writeByte((byte) (isInWindowing ? 1 : 0));
+            out.writeByte((byte) (isFullscreen ? 1 : 0));
+            out.writeInt(WindowingX);
+            out.writeInt(WindowingY);
+            out.writeInt(WindowingW);
+            out.writeInt(WindowingH);
+            //end
             out.writeInt(width);
             out.writeInt(height);
             out.writeInt(x);
@@ -1567,6 +1597,14 @@ public interface WindowManager extends ViewManager {
     
     
         public LayoutParams(Parcel in) {
+            //Ritter_multi
+            isInWindowing = in.readByte() != 0;
+            isFullscreen = in.readByte() != 0;
+            WindowingX = in.readInt();
+            WindowingY = in.readInt();
+            WindowingW = in.readInt();
+            WindowingH = in.readInt();
+            //end
             width = in.readInt();
             height = in.readInt();
             x = in.readInt();
@@ -1631,8 +1669,49 @@ public interface WindowManager extends ViewManager {
         private int[] mCompatibilityParamsBackup = null;
         
         public final int copyFrom(LayoutParams o) {
+            Log.d("LayoutParams","Ritter::WM LayoutParams.copyFrom() attrs x:"+o.x+"" +
+                    ",y:"+o.y+
+                    ",w:"+o.width+
+                    ",h:"+o.height+
+                    ",pkgName:"+o.packageName+
+                    ",isInWindowing:"+o.isInWindowing
+                    );
+            //Ritter_multi
+            if (packageName!=null){
+                Log.d("LayoutParams","Ritter::WM LayoutParams.copyFrom() packageName!=null:"+packageName);
+            } else {
+                Log.d("LayoutParams","Ritter::WM LayoutParams.copyFrom() packageName==null");
+            }
+
             int changes = 0;
     
+            //Ritter_multi
+            if (isInWindowing != o.isInWindowing) {
+                isInWindowing = o.isInWindowing;
+                changes |= LAYOUT_CHANGED;
+            }
+            if (isFullscreen != o.isFullscreen) {
+                isFullscreen = o.isFullscreen;
+                changes |= LAYOUT_CHANGED;
+            }
+            if (WindowingX != o.WindowingX) {
+                WindowingX = o.WindowingX;
+                changes |= LAYOUT_CHANGED;
+            }
+            if (WindowingY != o.WindowingY) {
+                WindowingY = o.WindowingY;
+                changes |= LAYOUT_CHANGED;
+            }
+            if (WindowingW != o.WindowingW) {
+                WindowingW = o.WindowingW;
+                changes |= LAYOUT_CHANGED;
+            }
+            if (WindowingH != o.WindowingH) {
+                WindowingH = o.WindowingH;
+                changes |= LAYOUT_CHANGED;
+            }
+            //end
+
             if (width != o.width) {
                 width = o.width;
                 changes |= LAYOUT_CHANGED;
diff --git a/frameworks/base/core/java/android/view/WindowManagerGlobal.java b/frameworks/base/core/java/android/view/WindowManagerGlobal.java
index 96c0ed2..848fbc2 100644
--- a/frameworks/base/core/java/android/view/WindowManagerGlobal.java
+++ b/frameworks/base/core/java/android/view/WindowManagerGlobal.java
@@ -113,6 +113,11 @@ public final class WindowManagerGlobal {
     private final ArrayList<ViewRootImpl> mRoots = new ArrayList<ViewRootImpl>();
     private final ArrayList<WindowManager.LayoutParams> mParams =
             new ArrayList<WindowManager.LayoutParams>();
+    //Ritter_multi new
+    public ArrayList<WindowManager.LayoutParams> getWindowManagerLayoutParams(){
+        return mParams;
+    }
+
     private final ArraySet<View> mDyingViews = new ArraySet<View>();
     private boolean mNeedsEglTerminate;
 
@@ -167,6 +172,7 @@ public final class WindowManagerGlobal {
     public String[] getViewRootNames() {
         synchronized (mLock) {
             final int numRoots = mRoots.size();
+            Log.d(TAG,"Ritter::WMG getViewRootNames numRoots:"+numRoots);
             String[] mViewRoots = new String[numRoots];
             for (int i = 0; i < numRoots; ++i) {
                 mViewRoots[i] = getWindowName(mRoots.get(i));
diff --git a/frameworks/base/core/java/com/android/internal/widget/ActionBarView.java b/frameworks/base/core/java/com/android/internal/widget/ActionBarView.java
index b5d74e8..53d1d6e 100644
--- a/frameworks/base/core/java/com/android/internal/widget/ActionBarView.java
+++ b/frameworks/base/core/java/com/android/internal/widget/ActionBarView.java
@@ -929,12 +929,14 @@ public class ActionBarView extends AbsActionBarView {
         mIsCollapsed = false;
 
         int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+        //Ritter_multi old Disable this check for multi window
         if (widthMode != MeasureSpec.EXACTLY) {
             throw new IllegalStateException(getClass().getSimpleName() + " can only be used " +
                     "with android:layout_width=\"match_parent\" (or fill_parent)");
         }
 
         int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+//        Ritter_multi old Disable this check for multi window
         if (heightMode != MeasureSpec.AT_MOST) {
             throw new IllegalStateException(getClass().getSimpleName() + " can only be used " +
                     "with android:layout_height=\"wrap_content\"");
diff --git a/frameworks/base/core/res/res/drawable-hdpi/ic_close.png b/frameworks/base/core/res/res/drawable-hdpi/ic_close.png
new file mode 100644
index 0000000000000000000000000000000000000000..778c7f0812d8d59d7ec939c631119a902e589ee9
GIT binary patch
literal 1391
zcmV-#1(5oQP)<h;3K|Lk000e1NJLTq001xm001xu1ONa4{R=S+00002VoOIv0RM-N
z%)bBt010qNS#tmY07w7;07w8v$!k6U000Sga6xAP001xm001xm&hCs?000DcNkl<Z
zSi|j?Piz}S6vp4%*|md{-C0L1MYYpJz##~!L`_mbypB^M4xyB&q6ZFe;)*EwgTx7m
z1E^9H6M@7DwO7OeP$98JIn<#EssyD7Bv2eg(~TWL6$nXo)9!e7IINR6_S#MnkwD5P
z`8M<Y_KoJfZw#=nef@8R#ou16_7=YcyWVtft91Y*5Nd^!a@R))DA(MkAizbGyWnJ~
zl>ngbTigy2<U)GH9q5ew{HHZ7rV$ljqMAJe5YXG$+aCTlC#Bq<2=cPEQaO-|P@6k&
zrtKO%cL-v^L_2YWe-$$Ji&i<%55~De*XWrxcOcZpMfoR_%8e}6_1Gs(4Ta-MbK~T}
zRdT`X<5_eo>`#dwm3%KVlF_q@R2XQu99UR~Y{iNA92xyBdQg3wFt<n6v=p_7Wu7QQ
z$T%pjE4c)VjYWo$2|_-&d-1mT0rI=3;LZFMCDp8|1~OrQO4HOP>t;Wn+d{~AT70AA
z6Rc+}Is%Re;5fdzgwx{dO1BC?0R94b(Z;l{QUe?j2bHF%P1ej_K94Q{$oP!7uH+L=
z&scOsc=n@<f!WB_huvl1^#B}hV>fpeEs~}xje{fNpwX0WNw(R~=TO4a#lsmdu~%jz
znValoWc4cmaA5%x+%hea)~RNIBMhKgO1GqS^AGOAhLTILSTZs!91*~z_w|`$>;)|N
zTxTBufD7~3%Wcz=Qe}uEW>{M6W3gmpNH`*Z@8C#InT=*T*(G25DgX}=uSA45aIMub
zw(W;=%1k74lzm>szA6B~g<r6bTRRXsom6>CvSp`z2b-*FUjqQ(LKgdqRp?p_91(*?
z`V{pp=0wr{82hY-eN8|Kf=q>VEe0G6hye!$CvYgQ%(i5nU?11CuLJN9%lyMzt2n7O
zQUeO$f(++j)C|r%bY-sad>#ABVdo<R1P~y$M}-R@KuEg^fI1b(I4JHYzxFxCc*|?R
zK?Vsp#6i=i!Yky6nJ9MmKLp75w79X=R!qov9%jJ+w$&GQ#TdK?fQ*CU`=Y&fF(;(a
zTbEa<9s@@hplK;;ll3}Pkm~lQ#C0W~U_Il};mv!W56;NuRCu#5RO$`$S_o3z{yQb-
z4djxxIy|i{SY)&H;-JzrwTR^#Ni_g6KI>~A&D>-wZfi+*ZzGoZTfPV%fPzfCzQaC=
zBRORzlIdo1C}BTeGc75lYb6MqT&RNZ37n(wwz5=WUyPGX2fKs?;ldpDa@(|})K*@o
zG(~OqjRhA%!0G`wEWw&lh>t}_1lzJdoax>g$S%xdKVLI#;vtwYu(@GUCz4pGA2<jA
z-O`iqJ#dyVp-9PMT6MBdONN3Ab9jQUn-)n^RWp!@9{K)I>VU9!75dQ8`Dn5!SRmwG
zXK2YwtMWK;A?u}{ln&FTm;}5%_yy*F-_^4v#1^92#^)N|zw=5yaP`5jvIV~|bYUKk
z^Sg^1IHexAuQT|f{iPY2W-H|t?D^BNLi)e_`1RLbKHp1@ZV&%}>}y~DDg6z^7lFuI
ztd^z#001R)MObuXVRU6WV{&C-bY%cCFflPLFflDNF;p=#IyE;sFflDKI65#eL6wV#
z0000bbVXQnWMOn=I&E)cX=Zr<GB7bQEif@HGci;#GdeXeIx#gZFgQ9eFzWFP&j0`b
x8FWQhbW?9;ba!ELWdK2BZ(?O2No`?gWm08fWO;GPWjp`?002ovPDHLkV1oFUYD544

literal 0
HcmV?d00001

diff --git a/frameworks/base/core/res/res/drawable-hdpi/ic_max.png b/frameworks/base/core/res/res/drawable-hdpi/ic_max.png
new file mode 100644
index 0000000000000000000000000000000000000000..5dcc3a3dae34ac3b9dedbf5900282b11a6dbb315
GIT binary patch
literal 961
zcmeAS@N?(olHy`uVBq!ia0vp^1|ZDA0wn)(8}a}trX+877l!}s{b%+Ad7K3vk;OpT
z1B~5HX4`=T%L*LRfizez!?|}o;XrLCJzX3_A`ZWu?(GqhD0001`R?*{ef<-33KAV>
zM5<g_HMK=#TK9tMi(LCte=mr=pmoCc!m2Pw$8H5CaowWJ*@@i~rb#I&MWw8;-BObF
z?)zM^#}6#-Rj0FQFR__D^XD_`=ilcZ|9ihW@$$dQ$)$g!b9V(A1)Tf5<D`GKsJc+$
z%roJ04o+p|@KSg82%WkqK{9c{jpO~^50<{PE2#SZ^j2jl$5StD4JYBhRoC;R=ltvw
zk$J?>BiU42r=R#|nvmNHyU9&eaUYA;lr!XcKD6zh!{~YLzzZRDA8|`oXCsCCqI0MH
z*)EvZGuzUaEn~sWwzbu}ZMJM#oy~Z9;<o4ZTiN`}?WE_w`tHAL>qO^|cSDO$+`0Mb
zRm@x$(^VV-6Id??g}=6}*_+Nab?ZZy-CO1vO{^8unOu`|+L5K+RDrwT%jJ1{9#1*i
z<)r*pcV*mHCGREk&b;{YVI8~MW41b0g^c3IImcW7+NQ-_Hd<A?ShHQ`TKU;U6K^JG
zKG_!Md3~vGPIuVX1K$_kj#1KP%=e9NXj*93Q_R<xaQ2Q015bh|C+7*B?a>!mEH&5X
zE)7;mtK3+y)uU-in9{aoO}4K$`5vfeSP}4M^4Wix4ptAdqRkx+)Mlvp`CRAUaKWNl
z%)?UE>5?#`pJIFWR2Fub$?dtC3daw66nZgv%x(WMX-*2e?9T;4S}aWwD>)Jl?u*;;
zRCm`CPrhDJQOD3Narato7({C-RQ&sSH0GxIZdD`KR8GlR(HeRoDhC+m{z_>-=+Cjf
zV%EoXwUTwKn#F^8wIu3xyxu8yOzY%=nZ^?|es+0;<^8HiDr_~rufKEmG^Q(zVvdj5
zszcc#a};9~3oeOR9uWTUK_kCQV9lEz&1YH-TTe{bcB-aTD&xc}nUgEMPOg9a=IH8I
z6Kfk8)h1ZXS86!exH8ko^y;3Hmit*^Q|E`yd0{>~WJA!of8Vn2FUvLg&Du4e!N_=N
z{9#}US1oakC`m~yNwrEYN(E93Mh1q4x&|h?MrI)fmR825R>sD<2If`<2K>tFcA{v=
z%}>cptHiCLu1<^<s6i5BLvVgtNqJ&XDuZK6ep0G}XKrG8YEWuoN@d~6R2!fo22WQ%
Jmvv4FO#sNvlKB7t

literal 0
HcmV?d00001

diff --git a/frameworks/base/core/res/res/drawable-hdpi/ic_mini.png b/frameworks/base/core/res/res/drawable-hdpi/ic_mini.png
new file mode 100644
index 0000000000000000000000000000000000000000..d4704a4e94de6e38b676ec00c7e15e243db08d1e
GIT binary patch
literal 687
zcmV;g0#N;lP)<h;3K|Lk000e1NJLTq001xm001xu1ONa4{R=S+00001b5ch_0Itp)
z=>Px#0%A)?L;(MXkIcUS000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2i^t*2qiMg
z^<~!p00J{fL_t(o!|j*PY7<cu#((F|pH6gAG8RiU2yrI}3T{n6p^wmK2*uWgK7t57
zfDP>v6kND-uca?g_i78ZZ4}XBO*NCuTo;q3(@@(<y;D%~-PH^;-*@l%ch7+lMmQ%p
z09;`*^<)q>0Am2S`AC2d%<~8+q~wgEPK0Kze+t8xV1<Y-ng>87^M5MqhY>5pSbXIj
zFk$`#irZ*DQ|o)dI4V8*5(T_G;^-PRAi%}S!_7XEK!AhQ%ZtBEtK)JxP!5*Z=Cbza
zTi-nky){VG1&Zu5!!(*Lz^6#d_Py{|*NSy4DCER-+U|=$oi;nH@rq?`0s#s|`3x43
zw3R!8E|&Moby@r=P8?X5<VEf2>X!Q<T*pCY;_I+Y>llFx><fC3<o?p@=6L)2Gw_~d
z+p&(?8@!~2BwUh`((bMBZGB<UlL!%DmrY%;LQz_DCUOd_F|*lS=KX<yeMo<`xLuuV
zER4lHdMHs6;!LIiAV#sPL{JIiK(W)%P{tF~?z79z9z0*~R2m+U76HETacC25pfz!_
z-waN^xAdkt-VU9NF?6Dnap(X(KbWO~5Mw8#;u5Cg?#3`-I%qEeUm>$Z#B|X#rK)hJ
zY=x4tDVO*_BGEz9<StOcML-bLDNBZy_(ZjT6WIBj;{TIy^OP`l>Hk@xV787NmH5Im
za3>#$!`AV->1uc&p_w<|{3a3?frmT>JoD|lof<uI8bA`lDK6(V-<%g@G!FlZ_zex(
V$a!bHlji^c002ovPDHLkV1jUeF{J<i

literal 0
HcmV?d00001

diff --git a/frameworks/base/core/res/res/drawable-hdpi/ic_resize.png b/frameworks/base/core/res/res/drawable-hdpi/ic_resize.png
new file mode 100644
index 0000000000000000000000000000000000000000..c2fc70d594785f6532d9e587735bf68616b8c448
GIT binary patch
literal 1298
zcmeAS@N?(olHy`uVBq!ia0vp^1|ZDA0wn)(8}a}trX+877l!}s{b%+Ad7K3vk;OpT
z1B~5HX4`=T%L*LRfizez!?|}o;S3BcQl2i3ArXh)PWR3UNfkL>|9toTJyx~ir@S?U
zdlYS)4jp!yAaPjv;*Nr)+`Wd51{;bOYlo}N>M%Uk`YvY127|=J2!}_?vm}ICjvUbt
z49IR&a?NU7IQQk5x$mv@(!AvFSZ`nY%I%zQTH*Vj=l=iM|5>I&;eYhR`l}ZVdAgrO
zSY3Gh&}ePZGkG?FDWY!{2>)nauc_bC*jusO;s3L_=TqIEG)qtQo^$xYd+`G<g}Y=X
zR9)F8wnr{ScV+7jdufMP|JH|WS(D+pcTw>s<-$xu-UXr|KesH*V9j~Vwtewgxxy8T
zelC&dadf;k(QWgEN3xH6*Pe<Bw$Qyar#;}w?~k)j?5%klEBf}#y<6LJ-zq!0>L%x9
zb4C3zzAOAUX?E;nr3lMdIe~pX2@_6EtXi77|H>7!MHi2%->eFmRr%hq$bqfuN=H7I
zf&=T4mZLL!{Fzlh3U->Q#`UDxs@X}ZF^Y6Oo^ns8uH&$g)V>@4%6|FJ)9DLs+Hy=r
ztnli!GbgvjnQYtYlN_+>)6Wm*53?0b;l93o65rYN<z4A#SMV$S6@FY({(IX7X7`-$
zvm#GA^RPyExrKQ&Na;(q{o!vc6x=Q?@%*Mr|IB5fcESz^9$F}xe7dB~q_?SO4#Oj1
zu0k~j=btNAI)6PACgM0l^3*T!nfwlOd?dvuT`HS4qvidrA6IMScNb*`n5de(wEdi_
zz_9xB^lekNebL=rb$5<tO}aYU(nZAud3-!93wGy!xOvU?{o0)uKAwA(a6aGveq6}K
zxjRGWO23x+%=Jm<qmu9%`Pg0MUw`i`y|+6&c=mLe8{fRA@2yzn5N+_`;z{Q`N5`;_
zThE+Q=9j;Az|!#1m%@E-?e;vJedzSt?x1{K`;?u%mzU|xVv_LMwD|7=PA7Fnfd>(f
z`koz&t`fO>_4B1Z?)~hd_e&P2v3b?H%FdHA&C&?nxbJvq&CIv|D&DVJnrdI^Zts>B
z?j*MIhC()zq0!qp4s5JkYfi>|oNSjD;+V|tx25t^-HM7O)+<~~y)Oo^cmF)V?Dnwp
zn_a)pj)y{azNLOVAx6xH^J6;luSaD@cPX8_T>a|jhJU}5;zQoQI>M--Ap7p_y{P<M
zo_!%lFFk$GdS}^JNtw!@r{t&3yIg;F=9&o>3>zJ~<<_w41(t1&UeM-xHn1skcZf-Y
z`krU!y&`Lx3Xfh|pLwp>_0p9s&gZIoc4f|UtL)#@xcAAVKVla*to{7w(bHY~|9reU
zh1Ze8@_6UUOWn79>yu_|TT*+dEwOQL!zzOtRnOEoLf84)i_dpe?os)X@8sXVWQm=6
z%9kR6jWI`<Rob=%N@qE^UOa!~zV+8xTe#*PW`6W^S>ZON8MR%H(t~H*KG9Rm=yojs
zOZUY~7S5IOrm|xH;@>EWF>l}DlzVX7J9n{j4pOs^?J4VJ{}g}fzI6EZ#WLK*Ex;l}
zwZt`|BqgyV)hf9t6-Y4{85kPs8W`#tS%erFS(%tynHuXFSXdbtEb%KkiJ~DlKP5A*
z61Rq{!lz1s8YDqB1m~xflqVLYGB~E>C#5QQ<|d}62BjvZR2H60wE-$(@O1TaS?83{
F1OU;uOX~mt

literal 0
HcmV?d00001

diff --git a/frameworks/base/core/res/res/layout/window_title.xml b/frameworks/base/core/res/res/layout/window_title.xml
new file mode 100644
index 0000000..81bf4a3
--- /dev/null
+++ b/frameworks/base/core/res/res/layout/window_title.xml
@@ -0,0 +1,88 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:gravity="left"
+    android:orientation="horizontal" >
+
+<!--     <ImageButton
+        android:id="@+id/IB_resize"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:src="@drawable/ic_resize"/>
+
+    <ImageButton
+        android:id="@+id/IB_close"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentRight="true"
+        android:layout_alignParentTop="true"
+        android:src="@drawable/ic_close" />
+
+    <ImageButton
+        android:id="@+id/IB_max"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:layout_toLeftOf="@+id/IB_close"
+        android:src="@drawable/ic_max" />
+
+    <ImageButton
+        android:id="@+id/IB_mini"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:layout_toLeftOf="@+id/IB_max"
+        android:src="@drawable/ic_mini" />
+
+    <TextView
+        android:id="@+id/TV_drag"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:layout_toLeftOf="@+id/IB_mini"
+        android:layout_toRightOf="@+id/IB_resize" /> -->
+
+    <TextView
+        android:id="@+id/TV_drag"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:layout_toLeftOf="@+id/IB_resize"
+        android:layout_toRightOf="@+id/IB_max"
+         />
+
+    <ImageButton
+        android:id="@+id/IB_close"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentTop="true"
+        android:src="@drawable/ic_close" />
+
+    <ImageButton
+        android:id="@+id/IB_resize"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentRight="true"
+        android:layout_alignParentTop="true"
+        android:src="@drawable/ic_resize" />
+
+    <ImageButton
+        android:id="@+id/IB_mini"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:layout_toRightOf="@+id/IB_close"
+        android:src="@drawable/ic_mini" />
+
+    <ImageButton
+        android:id="@+id/IB_max"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:layout_toRightOf="@+id/IB_mini"
+        android:src="@drawable/ic_max" />
+
+</RelativeLayout>
diff --git a/frameworks/base/core/res/res/values/public.xml b/frameworks/base/core/res/res/values/public.xml
index 8187939..8f42cf6 100644
--- a/frameworks/base/core/res/res/values/public.xml
+++ b/frameworks/base/core/res/res/values/public.xml
@@ -2087,4 +2087,12 @@
   <public type="style" name="Theme.DeviceDefault.NoActionBar.TranslucentDecor" id="0x010301e3" />
   <public type="style" name="Theme.DeviceDefault.Light.NoActionBar.TranslucentDecor" id="0x010301e4" />
 
+  <!-- ===============================================================
+    For multi window
+    =============================================================== -->
+<!--   <public type="id" name="TV_" id="0x010301e5" />
+  <public type="id" name="ic_resize" id="0x010301e5" />
+  <public type="id" name="ic_resize" id="0x010301e5" />
+  <public type="id" name="ic_resize" id="0x010301e5" />
+  <public type="id" name="ic_resize" id="0x010301e5" /> -->
 </resources>
diff --git a/frameworks/base/core/res/res/values/symbols.xml b/frameworks/base/core/res/res/values/symbols.xml
index e17b650..7113c32 100644
--- a/frameworks/base/core/res/res/values/symbols.xml
+++ b/frameworks/base/core/res/res/values/symbols.xml
@@ -1746,4 +1746,16 @@
   <java-symbol type="dimen" name="subtitle_shadow_radius" />
   <java-symbol type="dimen" name="subtitle_shadow_offset" />
   <java-symbol type="dimen" name="subtitle_outline_width" />
+
+  <!-- For multi window -->
+  <java-symbol type="layout" name="window_title" />
+  <java-symbol type="id" name="TV_drag" />
+  <java-symbol type="id" name="IB_resize" />
+  <java-symbol type="id" name="IB_mini" />
+  <java-symbol type="id" name="IB_max" />
+  <java-symbol type="id" name="IB_close" />
+  <java-symbol type="drawable" name="ic_resize" />
+  <java-symbol type="drawable" name="ic_mini" />
+  <java-symbol type="drawable" name="ic_max" />
+  <java-symbol type="drawable" name="ic_close" />
 </resources>
diff --git a/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentTasksLoader.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentTasksLoader.java
index c714d8b..2e12ade 100644
--- a/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentTasksLoader.java
+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentTasksLoader.java
@@ -240,6 +240,7 @@ public class RecentTasksLoader implements View.OnTouchListener {
 
     Runnable mPreloadTasksRunnable = new Runnable() {
             public void run() {
+                Log.d(TAG,"Ritter::RecentTaskLoader mPreloadTasksRunnable run()");
                 loadTasksInBackground();
             }
         };
@@ -265,10 +266,12 @@ public class RecentTasksLoader implements View.OnTouchListener {
     }
 
     public void preloadRecentTasksList() {
+        Log.d(TAG,"Ritter::Recent RecentTaskLoader::preloadRecentTasksList()");
         mHandler.post(mPreloadTasksRunnable);
     }
 
     public void cancelPreloadingRecentTasksList() {
+        Log.d(TAG,"Ritter::Recent RecentTaskLoader::cancelPreloadingRecentTasksList()");
         cancelLoadingThumbnailsAndIcons();
         mHandler.removeCallbacks(mPreloadTasksRunnable);
     }
@@ -400,10 +403,13 @@ public class RecentTasksLoader implements View.OnTouchListener {
     }
 
     public void loadTasksInBackground() {
+        Log.d(TAG,"Ritter::RecentTaskLoader loadTasksInBackground()");
         loadTasksInBackground(false);
     }
     public void loadTasksInBackground(final boolean zeroeth) {
+        Log.d(TAG,"Ritter::RecentTaskLoader loadTasksInBackground() zeroeth");
         if (mState != State.CANCELLED) {
+            Log.d(TAG,"Ritter::RecentTaskLoader loadTasksInBackground() zeroeth return ");
             return;
         }
         mState = State.LOADING;
@@ -414,6 +420,7 @@ public class RecentTasksLoader implements View.OnTouchListener {
         mTaskLoader = new AsyncTask<Void, ArrayList<TaskDescription>, Void>() {
             @Override
             protected void onProgressUpdate(ArrayList<TaskDescription>... values) {
+                Log.d(TAG,"Ritter::RecentTaskLoader mTaskLoader onProgressUpdate()");
                 if (!isCancelled()) {
                     ArrayList<TaskDescription> newTasks = values[0];
                     // do a callback to RecentsPanelView to let it know we have more values
@@ -430,6 +437,7 @@ public class RecentTasksLoader implements View.OnTouchListener {
             }
             @Override
             protected Void doInBackground(Void... params) {
+                Log.d(TAG,"Ritter::RecentTaskLoader mTaskLoader doInBackground()");
                 // We load in two stages: first, we update progress with just the first screenful
                 // of items. Then, we update with the rest of the items
                 final int origPri = Process.getThreadPriority(Process.myTid());
@@ -441,6 +449,14 @@ public class RecentTasksLoader implements View.OnTouchListener {
                 final List<ActivityManager.RecentTaskInfo> recentTasks =
                         am.getRecentTasks(MAX_TASKS, ActivityManager.RECENT_IGNORE_UNAVAILABLE);
                 int numTasks = recentTasks.size();
+                Log.d(TAG,"Ritter::RecentTaskLoader mTaskLoader doInBackground() recentTasks.size:"+recentTasks.size());
+                //Ritter_debug
+                for(int i=0;i<numTasks;i++){
+                    Log.d(TAG,"Ritter::RecentTaskLoader mTaskLoader doInBackground() recentTasks.get("+i+").origActivity:"
+                +recentTasks.get(i).origActivity
+                +",description:"+recentTasks.get(i).description);
+                }
+
                 ActivityInfo homeInfo = new Intent(Intent.ACTION_MAIN)
                         .addCategory(Intent.CATEGORY_HOME).resolveActivityInfo(pm, 0);
 
@@ -462,11 +478,13 @@ public class RecentTasksLoader implements View.OnTouchListener {
 
                     // Don't load the current home activity.
                     if (isCurrentHomeActivity(intent.getComponent(), homeInfo)) {
+                        Log.d(TAG,"Ritter::RecentTaskLoader mTaskLoader doInBackground() home continue");
                         continue;
                     }
 
                     // Don't load ourselves
                     if (intent.getComponent().getPackageName().equals(mContext.getPackageName())) {
+                        Log.d(TAG,"Ritter::RecentTaskLoader mTaskLoader doInBackground() recent continue");
                         continue;
                     }
 
@@ -475,6 +493,7 @@ public class RecentTasksLoader implements View.OnTouchListener {
                             recentInfo.origActivity, recentInfo.description);
 
                     if (item != null) {
+                        Log.d(TAG,"Ritter::RecentTaskLoader mTaskLoader doInBackground() item !=null add packageName:"+ item.packageName);
                         while (true) {
                             try {
                                 tasksWaitingForThumbnails.put(item);
@@ -490,6 +509,8 @@ public class RecentTasksLoader implements View.OnTouchListener {
                             //break;
                         }
                         ++index;
+                    }  else {
+                        Log.d(TAG,"Ritter::RecentTaskLoader mTaskLoader doInBackground() item ==null continue");
                     }
                 }
 
@@ -500,7 +521,7 @@ public class RecentTasksLoader implements View.OnTouchListener {
                         publishProgress(new ArrayList<TaskDescription>());
                     }
                 }
-
+                Log.d(TAG,"Ritter::RecentTaskLoader mTaskLoader doInBackground() tasks.size:"+tasks.size());
                 while (true) {
                     try {
                         tasksWaitingForThumbnails.put(new TaskDescription());
diff --git a/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/Recents.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/Recents.java
index f5670e1..055b3d8 100644
--- a/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/Recents.java
+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/Recents.java
@@ -48,6 +48,7 @@ public class Recents extends SystemUI implements RecentsComponent {
     @Override
     public void toggleRecents(Display display, int layoutDirection, View statusBarView) {
         if (DEBUG) Log.d(TAG, "toggle recents panel");
+        Log.d(TAG,"Ritter::Recents toggleRecents()");
         try {
             TaskDescription firstTask = RecentTasksLoader.getInstance(mContext).getFirstTask();
 
@@ -58,19 +59,23 @@ public class Recents extends SystemUI implements RecentsComponent {
                     | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
 
             if (firstTask == null) {
+                Log.d(TAG,"Ritter::Recents toggleRecents() firstTask == null");
                 if (RecentsActivity.forceOpaqueBackground(mContext)) {
+                    Log.d(TAG,"Ritter::Recents toggleRecents() RecentsActivity.forceOpaqueBackground(mContext)");
                     ActivityOptions opts = ActivityOptions.makeCustomAnimation(mContext,
                             R.anim.recents_launch_from_launcher_enter,
                             R.anim.recents_launch_from_launcher_exit);
                     mContext.startActivityAsUser(intent, opts.toBundle(), new UserHandle(
                             UserHandle.USER_CURRENT));
                 } else {
+                    Log.d(TAG,"Ritter::Recents toggleRecents() !RecentsActivity.forceOpaqueBackground(mContext)");
                     // The correct window animation will be applied via the activity's style
                     mContext.startActivityAsUser(intent, new UserHandle(
                             UserHandle.USER_CURRENT));
                 }
 
             } else {
+                Log.d(TAG,"Ritter::Recents toggleRecents() firstTask != null");
                 Bitmap first = null;
                 if (firstTask.getThumbnail() instanceof BitmapDrawable) {
                     first = ((BitmapDrawable) firstTask.getThumbnail()).getBitmap();
diff --git a/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
index 09a7a5e..ab076e1 100644
--- a/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
@@ -25,6 +25,7 @@ import android.content.Intent;
 import android.content.IntentFilter;
 import android.os.Bundle;
 import android.os.UserHandle;
+import android.util.Log;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.WindowManager;
@@ -32,9 +33,12 @@ import android.view.WindowManager;
 import com.android.systemui.R;
 import com.android.systemui.statusbar.StatusBarPanel;
 
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 
 public class RecentsActivity extends Activity {
+    static final String TAG = "RecentsActivity";
     public static final String TOGGLE_RECENTS_INTENT = "com.android.systemui.recent.action.TOGGLE_RECENTS";
     public static final String PRELOAD_INTENT = "com.android.systemui.recent.action.PRELOAD";
     public static final String CANCEL_PRELOAD_INTENT = "com.android.systemui.recent.CANCEL_PRELOAD";
@@ -52,7 +56,9 @@ public class RecentsActivity extends Activity {
     private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
+            Log.d(TAG,"Ritter::RecentsActivity mIntentReceiver::onReceive()");
             if (CLOSE_RECENTS_INTENT.equals(intent.getAction())) {
+                Log.d(TAG,"Ritter::RecentsActivity mIntentReceiver::onReceive() CLOSE_RECENTS_INTENT.equals(intent.getAction())");
                 if (mRecentsPanel != null && mRecentsPanel.isShowing()) {
                     if (mShowing && !mForeground) {
                         // Captures the case right before we transition to another activity
@@ -60,8 +66,12 @@ public class RecentsActivity extends Activity {
                     }
                 }
             } else if (WINDOW_ANIMATION_START_INTENT.equals(intent.getAction())) {
+                Log.d(TAG,"Ritter::RecentsActivity mIntentReceiver::onReceive() WINDOW_ANIMATION_START_INTENT.equals(intent.getAction())");
                 if (mRecentsPanel != null) {
+                    Log.d(TAG,"Ritter::RecentsActivity mIntentReceiver::onReceive() mRecentsPanel != null");
                     mRecentsPanel.onWindowAnimationStart();
+                } else {
+                    Log.d(TAG,"Ritter::RecentsActivity mIntentReceiver::onReceive() mRecentsPanel == null");
                 }
             }
         }
@@ -119,6 +129,7 @@ public class RecentsActivity extends Activity {
 
     @Override
     public void onStart() {
+        Log.d(TAG,"Ritter::RecentsActivity onStart()");
         // Hide wallpaper if it's not a static image
         if (forceOpaqueBackground(this)) {
             updateWallpaperVisibility(false);
@@ -127,6 +138,7 @@ public class RecentsActivity extends Activity {
         }
         mShowing = true;
         if (mRecentsPanel != null) {
+            Log.d(TAG,"Ritter::RecentsActivity onStart() mRecentsPanel != null");
             // Call and refresh the recent tasks list in case we didn't preload tasks
             // or in case we don't get an onNewIntent
             mRecentsPanel.refreshRecentTasksList();
@@ -137,13 +149,21 @@ public class RecentsActivity extends Activity {
 
     @Override
     public void onResume() {
+        Log.d(TAG,"Ritter::RecentsActivity onResume()");
         mForeground = true;
         super.onResume();
     }
 
     @Override
     public void onBackPressed() {
-        dismissAndGoBack();
+        Log.d(TAG,"RAPP Ritter::RecentsActivity onBackPressed()");
+        //Ritter_multi old
+//        dismissAndGoBack();
+        //Ritter_multi new
+        finish();
+        if (mRecentsPanel != null) {
+            mRecentsPanel.show(false);
+        }
     }
 
     public void dismissAndGoHome() {
@@ -158,25 +178,73 @@ public class RecentsActivity extends Activity {
     }
 
     public void dismissAndGoBack() {
+        Log.d(TAG,"RAPP Ritter::RecentsActivity dismissAndGoBack()");
+        //Ritter_multi new
+        // Make this method only do finish, no simulate click anymore
+        finish();
+        if (mRecentsPanel != null) {
+            mRecentsPanel.show(false);
+        }
+        return;
+        //end
+
+        /*
         if (mRecentsPanel != null) {
             final ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
 
-            final List<ActivityManager.RecentTaskInfo> recentTasks =
-                    am.getRecentTasks(2,
-                            ActivityManager.RECENT_WITH_EXCLUDED |
-                            ActivityManager.RECENT_IGNORE_UNAVAILABLE);
-            if (recentTasks.size() > 1 &&
-                    mRecentsPanel.simulateClick(recentTasks.get(1).persistentId)) {
-                // recents panel will take care of calling show(false) through simulateClick
-                return;
+            //Ritter_multi old
+//            final List<ActivityManager.RecentTaskInfo> recentTasks =
+//                    am.getRecentTasks(2,
+//                            ActivityManager.RECENT_WITH_EXCLUDED |
+//                            ActivityManager.RECENT_IGNORE_UNAVAILABLE);
+//            Log.d(TAG,"RAPP Ritter::RecentsActivity dismissAndGoBack: recentTasks.size():"+recentTasks.size());
+//                        if (recentTasks.size() > 1 &&
+//                    mRecentsPanel.simulateClick(recentTasks.get(1).persistentId)) {
+//                Log.d(TAG,"RAPP Ritter::RecentsActivity dismissAndGoBack: recentTasks.size() > 1 && return");
+//                // recents panel will take care of calling show(false) through simulateClick
+//                return;
+//            }
+
+            //Ritter_multi new
+            int maxRecentApp = 10;
+//            final List<ActivityManager.RecentTaskInfo> recentTasks =
+//            am.getRecentTasks(maxRecentApp,
+//                    ActivityManager.RECENT_WITH_EXCLUDED |
+//                    ActivityManager.RECENT_IGNORE_UNAVAILABLE);
+
+            ArrayList<TaskDescription> recentTasks = mRecentsPanel.getRecentTaskDescriptions();
+
+            Log.d(TAG,"RAPP Ritter::RecentsActivity dismissAndGoBack: recentTasks.size():"+recentTasks.size());
+            if (recentTasks.size() > 1){
+                Log.d(TAG,"RAPP Ritter::RecentsActivity dismissAndGoBack: recentTasks.size() > 1 ");
+                // Ritter
+                 // make all available apps been clicked again,
+                 // make them on top of Launcher.
+                 //
+                HashMap<String,Boolean> whetherCilckedMap = new HashMap<String,Boolean>();
+                for(int i=0;i<recentTasks.size();i++){
+                    boolean ret = mRecentsPanel.simulateClick(recentTasks.get(i).persistentTaskId);
+                    TaskDescription task = recentTasks.get(i);
+                    Log.d(TAG,"RAPP Ritter::RecentsActivity dismissAndGoBack: ret:"+ret+",task.packageName:"+task.packageName);
+                    whetherCilckedMap.put("",ret);
+                }
+
+                if(!whetherCilckedMap.containsValue(false)){
+                    Log.d(TAG,"RAPP Ritter::RecentsActivity dismissAndGoBack: all clicked APP true");
+                    //Ritter if all recent app clicked successfully, return
+                    return;
+                }
             }
+
             mRecentsPanel.show(false);
         }
         finish();
+        */
     }
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
+        Log.d(TAG,"Ritter::RecentsActivity onCreate()");
         getWindow().addPrivateFlags(
                 WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR);
         setContentView(R.layout.status_bar_recent_panel);
@@ -221,12 +289,14 @@ public class RecentsActivity extends Activity {
 
     private void handleIntent(Intent intent, boolean checkWaitingForAnimationParam) {
         super.onNewIntent(intent);
-
+        Log.d(TAG,"RAPP Ritter::RecentsActivity handleIntent()");
         if (TOGGLE_RECENTS_INTENT.equals(intent.getAction())) {
             if (mRecentsPanel != null) {
                 if (mRecentsPanel.isShowing()) {
+                    Log.d(TAG,"RAPP Ritter::RecentsActivity handleIntent() mRecentsPanel.isShowing()");
                     dismissAndGoBack();
                 } else {
+                    Log.d(TAG,"RAPP Ritter::RecentsActivity handleIntent() !mRecentsPanel.isShowing()");
                     final RecentTasksLoader recentTasksLoader = RecentTasksLoader.getInstance(this);
                     boolean waitingForWindowAnimation = checkWaitingForAnimationParam &&
                             intent.getBooleanExtra(WAITING_FOR_WINDOW_ANIMATION_PARAM, false);
diff --git a/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
index 788e843..18a81e7 100644
--- a/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
@@ -571,6 +571,7 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
     }
 
     public void onWindowAnimationStart() {
+        Log.d(TAG,"Ritter::RecentsPanelView onWindowAnimationStart()");
         mWaitingForWindowAnimation = false;
         mWindowAnimationStartTime = System.currentTimeMillis();
         animateInIconOfFirstTask();
@@ -593,25 +594,31 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
     }
 
     public void refreshViews() {
+        Log.d(TAG,"Ritter::RecentsPanelView refreshViews()");
         mListAdapter.notifyDataSetInvalidated();
         updateUiElements();
         showIfReady();
     }
 
     public void refreshRecentTasksList() {
+        Log.d(TAG,"Ritter::RecentsPanelView refreshRecentTasksList()");
         refreshRecentTasksList(null, false);
     }
 
     private void refreshRecentTasksList(
             ArrayList<TaskDescription> recentTasksList, boolean firstScreenful) {
+        Log.d(TAG,"Ritter::RecentsPanelView refreshRecentTasksList() firstScreenful:"+firstScreenful);
         if (mRecentTaskDescriptions == null && recentTasksList != null) {
+            Log.d(TAG,"Ritter::RecentsPanelView refreshRecentTasksList() mRecentTaskDescriptions == null && recentTasksList != null");
             onTasksLoaded(recentTasksList, firstScreenful);
         } else {
+            Log.d(TAG,"Ritter::RecentsPanelView refreshRecentTasksList() else");
             mRecentTasksLoader.loadTasksInBackground();
         }
     }
 
     public void onTasksLoaded(ArrayList<TaskDescription> tasks, boolean firstScreenful) {
+        Log.d(TAG,"Ritter::RecentsPanelView onTasksLoaded()");
         if (mRecentTaskDescriptions == null) {
             mRecentTaskDescriptions = new ArrayList<TaskDescription>(tasks);
         } else {
@@ -643,6 +650,7 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
     }
 
     public boolean simulateClick(int persistentTaskId) {
+        Log.d(TAG,"RAPP Ritter::RecentsPanelView simulateClick()");
         View v = mRecentsContainer.findViewForTask(persistentTaskId);
         if (v != null) {
             handleOnClick(v);
@@ -652,6 +660,7 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
     }
 
     public void handleOnClick(View view) {
+        Log.d(TAG,"RAPP Ritter::RecentsPanelView handleOnClick(): getCount():"+mRecentTaskDescriptions.size());
         ViewHolder holder = (ViewHolder) view.getTag();
         TaskDescription ad = holder.taskDescription;
         final Context context = view.getContext();
@@ -679,12 +688,19 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
         show(false);
         if (ad.taskId >= 0) {
             // This is an active task; it should just go to the foreground.
-            am.moveTaskToFront(ad.taskId, ActivityManager.MOVE_TASK_WITH_HOME,
-                    opts);
+            //Ritter_multi old
+//            am.moveTaskToFront(ad.taskId, ActivityManager.MOVE_TASK_WITH_HOME,
+//                    opts);
+            //Ritter_multi new
+            am.moveTaskToFront(ad.taskId, 0, null);
         } else {
             Intent intent = ad.intent;
-            intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
+            //Ritter_multi old
+            /*intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
                     | Intent.FLAG_ACTIVITY_TASK_ON_HOME
+                    | Intent.FLAG_ACTIVITY_NEW_TASK);*/
+            //Ritter_multi new
+            intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
                     | Intent.FLAG_ACTIVITY_NEW_TASK);
             if (DEBUG) Log.v(TAG, "Starting activity " + intent);
             try {
@@ -696,6 +712,11 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
                 Log.e(TAG, "Error launching activity " + intent, e);
             }
         }
+        //Ritter_multi new
+        //when click the recent app, dismiss the recent panel immediately
+//        dismissAndGoBack();
+        ((RecentsActivity) mContext).finish();
+
         if (usingDrawingCache) {
             holder.thumbnailViewImage.setDrawingCacheEnabled(false);
         }
@@ -712,6 +733,9 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
                     " tag=" + view.getTag());
             return;
         }
+        Log.d(TAG,
+                "Ritter RecentsPanelView::handleSwipe() ad.persistentTaskId:"
+                        + ad.persistentTaskId);
         if (DEBUG) Log.v(TAG, "Jettison " + ad.getLabel());
         mRecentTaskDescriptions.remove(ad);
         mRecentTasksLoader.remove(ad);
@@ -810,4 +834,9 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
         }
         mRecentsContainer.drawFadedEdges(canvas, left, right, top, bottom);
     }
+
+    //Ritter_multi new
+    public ArrayList<TaskDescription> getRecentTaskDescriptions(){
+        return mRecentTaskDescriptions;
+    }
 }
diff --git a/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsPreloadReceiver.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsPreloadReceiver.java
index eb58920..7980286 100644
--- a/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsPreloadReceiver.java
+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/recent/RecentsPreloadReceiver.java
@@ -19,13 +19,17 @@ package com.android.systemui.recent;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.util.Log;
 
 public class RecentsPreloadReceiver extends BroadcastReceiver {
     @Override
     public void onReceive(Context context, Intent intent) {
+        Log.d("TAG","Ritter::Recent RecentsPreloadReceiver::onReceive()");
         if (RecentsActivity.PRELOAD_INTENT.equals(intent.getAction())) {
+            Log.d("TAG","Ritter::Recent RecentsPreloadReceiver::onReceive() PRELOAD_INTENT");
             RecentTasksLoader.getInstance(context).preloadRecentTasksList();
         } else if (RecentsActivity.CANCEL_PRELOAD_INTENT.equals(intent.getAction())){
+            Log.d("TAG","Ritter::Recent RecentsPreloadReceiver::onReceive() CANCEL_PRELOAD_INTENT");
             RecentTasksLoader.getInstance(context).cancelPreloadingRecentTasksList();
         }
     }
diff --git a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java
index 1745bc7..5e3b918 100644
--- a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java
+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java
@@ -39,13 +39,19 @@ import com.android.internal.widget.ActionBarContextView;
 import com.android.internal.widget.ActionBarOverlayLayout;
 import com.android.internal.widget.ActionBarView;
 
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.AlertDialog;
 import android.app.KeyguardManager;
+import android.app.WindowAppsManager;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.pm.ActivityInfo;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
@@ -70,6 +76,7 @@ import android.view.ContextThemeWrapper;
 import android.view.Gravity;
 import android.view.IRotationWatcher;
 import android.view.IWindowManager;
+import android.view.IWindowSession;
 import android.view.InputEvent;
 import android.view.InputQueue;
 import android.view.KeyCharacterMap;
@@ -78,8 +85,12 @@ import android.view.LayoutInflater;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.MotionEvent;
+import android.view.Surface;
 import android.view.SurfaceHolder;
 import android.view.View;
+import android.view.WindowManagerGlobal;
+import android.view.View.OnClickListener;
+import android.view.View.OnTouchListener;
 import android.view.ViewGroup;
 import android.view.ViewManager;
 import android.view.ViewParent;
@@ -91,14 +102,21 @@ import android.view.accessibility.AccessibilityEvent;
 import android.view.accessibility.AccessibilityManager;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
+import android.widget.Button;
 import android.widget.FrameLayout;
+import android.widget.ImageButton;
 import android.widget.ImageView;
+import android.widget.LinearLayout;
 import android.widget.PopupWindow;
 import android.widget.ProgressBar;
+import android.widget.RelativeLayout;
 import android.widget.TextView;
+import android.widget.Toast;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 
 /**
  * Android-specific Window.
@@ -233,9 +251,29 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
 
     static final RotationWatcher sRotationWatcher = new RotationWatcher();
 
+    //Ritter_multi
+    private Context mContext;
+    private String mPKGName = "";
+    static int sDownX = 0;
+    static int sDownY = 0;
+    private long mExitTime = 0l;
+    //end
+
     public PhoneWindow(Context context) {
         super(context);
+        //Ritter_multi
+        mContext = context;
+        if (mContext instanceof Activity) {
+            Activity activity = (Activity) mContext;
+            if (activity != null && activity.getComponentName() != null) {
+                mPKGName = activity.getComponentName().getPackageName();
+            }
+        }
+        Log.d(TAG, "Ritter PW::PhoneWindow() mPKGName:"
+                + mPKGName);
+
         mLayoutInflater = LayoutInflater.from(context);
+        //end
     }
 
     @Override
@@ -1911,6 +1949,11 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
 
         private final Rect mFrameOffsets = new Rect();
 
+        //Ritter_multi
+        public Rect getDrawingBounds(){
+            return mDrawingBounds;
+        }
+
         private boolean mChanging;
 
         private Drawable mMenuBackground;
@@ -2362,6 +2405,7 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
 
         @Override
         public ActionMode startActionMode(ActionMode.Callback callback) {
+            Log.d(TAG,"Ritter::PW startActionMode()");
             if (mActionMode != null) {
                 mActionMode.finish();
             }
@@ -2744,7 +2788,18 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
 
     protected ViewGroup generateLayout(DecorView decor) {
         // Apply data from current theme.
-
+        //Ritter_multi new
+        Log.d(TAG, "Ritter PW::generateLayout() mPKGName:" + mPKGName);
+        if (mContext instanceof Activity) {
+            Activity activity = (Activity) mContext;
+            if (activity != null && activity.getComponentName() != null) {
+                mPKGName = activity.getComponentName().getPackageName();
+            }
+        }
+        Log.d(TAG, "Ritter PW::generateLayout() mPKGName2:"
+                + mPKGName);
+        boolean isAllowToAddWindowTitlebar = false;
+        //end
         TypedArray a = getWindowStyle();
 
         if (false) {
@@ -2757,6 +2812,19 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
             System.out.println(s);
         }
 
+        //Ritter_multi
+        if (true) {
+//            System.out.println("From style:");
+            String s = "Attrs:";
+            for (int i = 0; i < com.android.internal.R.styleable.Window.length; i++) {
+                s = s + " " + Integer.toHexString(com.android.internal.R.styleable.Window[i]) + "="
+                        + a.getString(i);
+            }
+            System.out.println(s);
+            Log.d(TAG, "Ritter PW::generateLayout() s:" + s);
+        }
+        //end
+
         mIsFloating = a.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating, false);
         int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR)
                 & (~getForcedWindowFlags());
@@ -2909,6 +2977,7 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
         int features = getLocalFeatures();
         // System.out.println("Features: 0x" + Integer.toHexString(features));
         if ((features & ((1 << FEATURE_LEFT_ICON) | (1 << FEATURE_RIGHT_ICON))) != 0) {
+            Log.d(TAG, "Ritter PW::generateLayout() features A");
             if (mIsFloating) {
                 TypedValue res = new TypedValue();
                 getContext().getTheme().resolveAttribute(
@@ -2922,11 +2991,13 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
             // System.out.println("Title Icons!");
         } else if ((features & ((1 << FEATURE_PROGRESS) | (1 << FEATURE_INDETERMINATE_PROGRESS))) != 0
                 && (features & (1 << FEATURE_ACTION_BAR)) == 0) {
+            Log.d(TAG, "Ritter PW::generateLayout() features B");
             // Special case for a window with only a progress bar (and title).
             // XXX Need to have a no-title version of embedded windows.
             layoutResource = com.android.internal.R.layout.screen_progress;
             // System.out.println("Progress!");
         } else if ((features & (1 << FEATURE_CUSTOM_TITLE)) != 0) {
+            Log.d(TAG, "Ritter PW::generateLayout() features C");
             // Special case for a window with a custom title.
             // If the window is floating, we need a dialog layout
             if (mIsFloating) {
@@ -2940,6 +3011,10 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
             // XXX Remove this once action bar supports these features.
             removeFeature(FEATURE_ACTION_BAR);
         } else if ((features & (1 << FEATURE_NO_TITLE)) == 0) {
+            //Ritter multi always action bar APPs
+            Log.d(TAG, "Ritter PW::generateLayout() features D");
+            isAllowToAddWindowTitlebar = true;
+            //end
             // If no other features and not embedded, only need a title.
             // If the window is floating, we need a dialog layout
             if (mIsFloating) {
@@ -2954,8 +3029,14 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
             }
             // System.out.println("Title!");
         } else if ((features & (1 << FEATURE_ACTION_MODE_OVERLAY)) != 0) {
+            //Ritter multi always dialog
+            Log.d(TAG, "Ritter PW::generateLayout() features E");
             layoutResource = com.android.internal.R.layout.screen_simple_overlay_action_mode;
         } else {
+            //Ritter multi always full screen APPs
+            Log.d(TAG, "Ritter PW::generateLayout() features F else");
+            isAllowToAddWindowTitlebar = true;
+            //end
             // Embedded, so no decoration is needed.
             layoutResource = com.android.internal.R.layout.screen_simple;
             // System.out.println("Simple!");
@@ -2963,8 +3044,150 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
 
         mDecor.startChanging();
 
-        View in = mLayoutInflater.inflate(layoutResource, null);
-        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
+
+        //Ritter_multi old
+//        View in = mLayoutInflater.inflate(layoutResource, null);
+//        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
+
+        // Ritter_multi new
+        // Get window apps from service
+        String APPs = "";
+        WindowAppsManager mWindowAppsManager = (WindowAppsManager) mContext
+                .getSystemService("window_apps");
+        try {
+            APPs = mWindowAppsManager.getWindowApps();
+        } catch (Exception e){
+            e.printStackTrace();
+        }
+        ArrayList<String> pkgList = new ArrayList<String>(Arrays.asList(APPs.split("#")));
+        Log.d(TAG, "Ritter PW::generateLayout() APPs:" + APPs);
+
+        Log.d(TAG, "Ritter PW::generateLayout() pkgList.size:" + pkgList.size()
+                + " ,pkgList:"+pkgList);
+
+        if (isAllowToAddWindowTitlebar
+                && pkgList.contains(mPKGName) && !mPKGName.isEmpty()) {
+            Log.d(TAG, "Ritter PW::generateLayout() mPKGName:" + mPKGName + " Add title");
+            Log.d(TAG, "Ritter PW::generateLayout() APPs:" + APPs);
+
+            View in = mLayoutInflater.inflate(layoutResource, null);
+
+            LinearLayout out = new LinearLayout(mContext);
+            out.setOrientation(LinearLayout.VERTICAL);
+
+            int window_title_id = com.android.internal.R.layout.window_title;
+            RelativeLayout title = (RelativeLayout) mLayoutInflater.inflate(window_title_id, null);
+            title.setBackgroundColor(Color.BLACK);
+
+            ImageButton closeBtn = (ImageButton) title.findViewById(R.id.IB_close);
+            closeBtn.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    Activity activity = (Activity) mContext;
+                    Log.d(TAG, "Ritter PW::close activity.getComponentName():"
+                            + activity.getComponentName());
+                    // showForceCloseDialog();
+                    if ((System.currentTimeMillis() - mExitTime) > 2000) {
+                        Toast.makeText(mContext, "One more click to exit",
+                                Toast.LENGTH_SHORT).show();
+                        mExitTime = System.currentTimeMillis();
+                    } else {
+                        killMyCurrentTask();
+                    }
+                }
+            });
+
+            ImageButton minimumBtn = (ImageButton)title.findViewById(R.id.IB_mini);
+            minimumBtn.setOnClickListener(new OnClickListener(){
+                @Override
+                public void onClick(View v) {
+                    Toast.makeText(mContext, "minimumBtn", Toast.LENGTH_SHORT).show();
+                }
+            });
+
+            final ImageButton resizeBtn = (ImageButton)title.findViewById(R.id.IB_resize);
+            final TextView tv = (TextView)title.findViewById(R.id.TV_drag);
+            ImageButton maxmumBtn = (ImageButton)title.findViewById(R.id.IB_max);
+            maxmumBtn.setOnClickListener(new OnClickListener(){
+                @Override
+                public void onClick(View v) {
+//                    resizeBtn.setEnabled(!resizeBtn.isEnabled());
+                    if(resizeBtn.getVisibility()==View.VISIBLE){
+                        resizeBtn.setVisibility(View.INVISIBLE);
+                        tv.setVisibility(View.INVISIBLE);
+                    } else {
+                        resizeBtn.setVisibility(View.VISIBLE);
+                        tv.setVisibility(View.VISIBLE);
+                    }
+//                    int screenWidth  = getWindowManager().getDefaultDisplay().getWidth();
+//                    int screenHeight = getWindowManager().getDefaultDisplay().getHeight();
+//                    Toast.makeText(mContext, "maxmumBtn screenWidth:"+screenWidth+",screenHeight:"+screenHeight, Toast.LENGTH_SHORT).show();
+                    toggleFullscreen();
+                    /**Ritter_multi
+                     * I don't know why the toggleFullScreen() sometimes won't refresh,
+                     * But the moveAndResizeWindows() always refresh, so I call it as a trick.
+                     * */
+                    moveAndResizeWindows(0, 0, 0, 0);
+                }
+            });
+
+            tv.setText("Drag Area");
+            tv.setTextSize(20);
+            tv.setOnTouchListener(new OnTouchListener() {
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    if (event.getAction() == MotionEvent.ACTION_DOWN) {
+                        sDownX = (int) event.getRawX();
+                        sDownY = (int) event.getRawY();
+                    } else if (event.getAction() == MotionEvent.ACTION_MOVE) {
+                        int newX = (int) event.getRawX();
+                        int newY = (int) event.getRawY();
+                        Log.d(TAG, "Ritter::PW onTouch TextView MOVE new x:"
+                                + newX + ",y:" + newY);
+                        moveAndResizeWindows((newX - sDownX), (newY - sDownY), 0, 0);
+                        sDownX = (int) event.getRawX();
+                        sDownY = (int) event.getRawY();
+                    } else if (event.getAction() == MotionEvent.ACTION_UP) {
+                    }
+                    return true;
+                }
+            });
+
+            resizeBtn.setOnTouchListener(new OnTouchListener(){
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    if (event.getAction() == MotionEvent.ACTION_DOWN) {
+                        sDownX = (int) event.getRawX();
+                        sDownY = (int) event.getRawY();
+                    } else if (event.getAction() == MotionEvent.ACTION_MOVE) {
+                        int newX = (int) event.getRawX();
+                        int newY = (int) event.getRawY();
+                        Log.d(TAG,"Ritter::PW onTouch resizeBtn MOVE new x:"+newX
+                                +",y:"+newY);
+                        moveAndResizeWindows(0,(newY - sDownY),(newX - sDownX), (sDownY - newY));
+                        sDownX = (int) event.getRawX();
+                        sDownY = (int) event.getRawY();
+                    } else if (event.getAction() == MotionEvent.ACTION_UP) {
+
+                    }
+                    return true;
+                }
+
+            });
+
+            out.addView(title);
+            out.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT,
+                    MATCH_PARENT));
+
+            decor.addView(out, new ViewGroup.LayoutParams(MATCH_PARENT,
+                    MATCH_PARENT));
+        } else {
+            Log.d(TAG, "Ritter PW::generateLayout() mPKGName:" + mPKGName + " don't add title");
+            View in = mLayoutInflater.inflate(layoutResource, null);
+            decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT,
+                    MATCH_PARENT));
+        }
+        // end
 
         ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
         if (contentParent == null) {
@@ -3017,7 +3240,9 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
     }
 
     private void installDecor() {
+        Log.d(TAG,"Ritter::PW installDecor()");
         if (mDecor == null) {
+            Log.d(TAG,"Ritter::PW installDecor() mDecor == null");
             mDecor = generateDecor();
             mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
             mDecor.setIsRootNamespace(true);
@@ -3026,6 +3251,7 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
             }
         }
         if (mContentParent == null) {
+            Log.d(TAG,"Ritter::PW installDecor() mContentParent == null");
             mContentParent = generateLayout(mDecor);
 
             // Set up decor part of UI to ignore fitsSystemWindows if appropriate.
@@ -3033,6 +3259,7 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
 
             mTitleView = (TextView)findViewById(com.android.internal.R.id.title);
             if (mTitleView != null) {
+                Log.d(TAG,"Ritter::PW installDecor() mContentParent == null mTitleView != null");
                 mTitleView.setLayoutDirection(mDecor.getLayoutDirection());
                 if ((getLocalFeatures() & (1 << FEATURE_NO_TITLE)) != 0) {
                     View titleContainer = findViewById(com.android.internal.R.id.title_container);
@@ -3048,6 +3275,7 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
                     mTitleView.setText(mTitle);
                 }
             } else {
+                Log.d(TAG,"Ritter::PW installDecor() mContentParent == null mTitleView == null mActionBar");
                 mActionBar = (ActionBarView) findViewById(com.android.internal.R.id.action_bar);
                 if (mActionBar != null) {
                     mActionBar.setWindowCallback(getCallback());
@@ -3833,4 +4061,219 @@ public class PhoneWindow extends Window implements MenuBuilder.Callback {
     void sendCloseSystemWindows(String reason) {
         PhoneWindowManager.sendCloseSystemWindows(getContext(), reason);
     }
+
+    private void moveAndResizeWindows(int deltaX, int deltaY, int deltaW, int deltaH) {
+        Log.d(TAG,"Ritter::PW moveAndResizeWindows deltaX:"+deltaX
+                +",deltaY:"+deltaY+",deltaW:"+deltaW+",deltaH:"+deltaH);
+        List<String> rootList = Arrays.asList(WindowManagerGlobal.getInstance()
+                .getViewRootNames());
+
+        ArrayList<WindowManager.LayoutParams> paramsList = WindowManagerGlobal
+                .getInstance().getWindowManagerLayoutParams();
+        Log.d(TAG,
+                "Ritter::PW moveAndResizeWindows paramsList.size:" + paramsList.size());
+
+        Log.d(TAG, "Ritter::PW moveAndResizeWindows rootList.size:" + rootList.size());
+        Log.d(TAG, "Ritter::PW moveAndResizeWindows rootList:" + rootList);
+        Activity activity = (Activity) mContext;
+        String activityName = activity.getLocalClassName();
+        Log.d(TAG, "Ritter::PW moveAndResizeWindows activity.getLocalClassName():"
+                + activity.getLocalClassName()
+                + ",activity.getComponentName():" + activity.getComponentName()
+                + ",activity.getComponentName().getClassName():"
+                + activity.getComponentName().getClassName());
+        String pkgName = "", className = "";
+        // int curRootIndex = 0 ;
+        for (int i = 0; i < rootList.size(); i++) {
+            ViewRootImpl root = WindowManagerGlobal.getInstance()
+                    .getRootView(rootList.get(i)).getViewRootImpl();
+            Rect outRect = new Rect();
+            if (root.getMyWindowStateAttrs(outRect)) {
+                Log.d(TAG, "Ritter::PW moveAndResizeWindows win.mAttrs.x:("
+                        + outRect.left + "," + outRect.top + ","
+                        + (outRect.right - outRect.left) + ","
+                        + (outRect.bottom - outRect.top) + "));");
+            }
+            WindowManager.LayoutParams windowAttributesInViewRootImpl = root
+                    .getLayoutParams();
+
+            if (!windowAttributesInViewRootImpl.isInWindowing) {
+
+            }
+
+            windowAttributesInViewRootImpl.x += deltaX;
+            windowAttributesInViewRootImpl.y += deltaY;
+            Log.d(TAG, "Ritter::PW moveAndResizeWindows " + "Down(" + sDownX + ","
+                    + sDownY + ")," + "Delta(" + deltaX + "," + deltaY + "),"
+                    + "windowAttributes.x:" + windowAttributesInViewRootImpl.x
+                    + ",windowAttributes.y:" + windowAttributesInViewRootImpl.y);
+            windowAttributesInViewRootImpl.width += deltaW;
+            windowAttributesInViewRootImpl.height += deltaH;
+
+            if(!windowAttributesInViewRootImpl.isFullscreen){
+                windowAttributesInViewRootImpl.setWindowingParam();
+            }
+            /**Ritter_multi
+             * Because when the window been touch, the moveTaskToFront()
+             * will be called, then the resume() called, setLayoutParams() called,
+             * it's will get the window's decor view to set into attrs, so I would
+             * better make its x and y changed too.
+             */
+            /**
+             * There are 2 attrs, one in Window, one in ViewRootImpl.
+             * */
+            WindowManager.LayoutParams windowAttributesInWindow = paramsList
+                    .get(i);
+            windowAttributesInWindow.x = windowAttributesInViewRootImpl.x;
+            windowAttributesInWindow.y = windowAttributesInViewRootImpl.y;
+            windowAttributesInWindow.width = windowAttributesInViewRootImpl.width;
+            windowAttributesInWindow.height = windowAttributesInViewRootImpl.height;
+
+            if(!windowAttributesInWindow.isFullscreen){
+                windowAttributesInWindow.setWindowingParam();
+            }
+
+            windowAttributesInViewRootImpl.isInWindowing = true;
+            root.relayoutWindowPublic(windowAttributesInViewRootImpl,
+                    View.VISIBLE, false);
+        }
+    }
+
+    //Ritter_multi
+    /** If use dialog, in some case: like a second activity in a task,
+     *  the dialog will be covered.
+     *  So I use double click instead of dialog.
+     * */
+    private void showForceCloseDialog() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
+        builder.setTitle("Force close this APP?")
+                // .setIcon(R.drawable.dialog_logo)
+//                .setView(inputPasswd)
+                .setNegativeButton("Cancel", null);
+        builder.setPositiveButton("OK",
+                new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int which) {
+                        killMyCurrentTask();
+                    }
+                });
+        builder.show();
+    }
+
+    private void killMyCurrentTask(){
+        Activity activity = (Activity) mContext;
+        final ActivityManager am = (ActivityManager) mContext
+                .getSystemService(Context.ACTIVITY_SERVICE);
+        if (am != null && activity != null) {
+            Toast.makeText(mContext, "Force close activity.getTaskId():"
+                    + activity.getTaskId(), Toast.LENGTH_SHORT).show();
+            am.removeTask(activity.getTaskId(), ActivityManager.REMOVE_TASK_KILL_PROCESS);
+
+            /*
+             * // Accessibility feedback setContentDescription(
+             * mContext
+             * .getString(R.string.accessibility_recents_item_dismissed
+             * , ad.getLabel()));
+             * sendAccessibilityEvent(AccessibilityEvent
+             * .TYPE_VIEW_SELECTED); setContentDescription(null);
+             */
+        }
+    }
+
+    private void toggleFullscreen() {
+        Log.d(TAG,"Ritter::PW toggleFullscreen()");
+        List<String> rootList = Arrays.asList(WindowManagerGlobal.getInstance()
+                .getViewRootNames());
+
+        ArrayList<WindowManager.LayoutParams> paramsList = WindowManagerGlobal
+                .getInstance().getWindowManagerLayoutParams();
+        Log.d(TAG,
+                "Ritter::PW toggleFullscreen paramsList.size:" + paramsList.size());
+
+        Log.d(TAG, "Ritter::PW toggleFullscreen rootList.size:" + rootList.size());
+        Log.d(TAG, "Ritter::PW toggleFullscreen rootList:" + rootList);
+        Activity activity = (Activity) mContext;
+        String activityName = activity.getLocalClassName();
+        Log.d(TAG, "Ritter::PW toggleFullscreen activity.getLocalClassName():"
+                + activity.getLocalClassName()
+                + ",activity.getComponentName():" + activity.getComponentName()
+                + ",activity.getComponentName().getClassName():"
+                + activity.getComponentName().getClassName());
+        String pkgName = "", className = "";
+        // int curRootIndex = 0 ;
+        for (int i = 0; i < rootList.size(); i++) {
+            ViewRootImpl root = WindowManagerGlobal.getInstance()
+                    .getRootView(rootList.get(i)).getViewRootImpl();
+            Rect outRect = new Rect();
+            if (root.getMyWindowStateAttrs(outRect)) {
+                Log.d(TAG, "Ritter::PW toggleFullscreen win.mAttrs.x:("
+                        + outRect.left + "," + outRect.top + ","
+                        + (outRect.right - outRect.left) + ","
+                        + (outRect.bottom - outRect.top) + "));");
+            }
+            WindowManager.LayoutParams windowAttributesInViewRootImpl = root
+                    .getLayoutParams();
+            WindowManager.LayoutParams windowAttributesInWindow = paramsList
+                    .get(i);
+            if (windowAttributesInViewRootImpl.isFullscreen) {
+                Log.d(TAG,"Ritter::PW toggleFullscreen() isFullscreen==true");
+                Log.d(TAG,"Ritter::PW toggleFullscreen() before getWindowingParam() windowAttributesInViewRootImpl x:"
+                +windowAttributesInViewRootImpl.x
+                +",y:"+windowAttributesInViewRootImpl.y
+                +",w:"+windowAttributesInViewRootImpl.width
+                +",h:"+windowAttributesInViewRootImpl.height
+                +",isFullscreen:"+windowAttributesInViewRootImpl.isFullscreen
+                +",isInWindowing:"+windowAttributesInViewRootImpl.isInWindowing);
+                windowAttributesInViewRootImpl.getWindowingParam();
+                Log.d(TAG,"Ritter::PW toggleFullscreen() after getWindowingParam() windowAttributesInViewRootImpl x:"
+                        +windowAttributesInViewRootImpl.x
+                        +",y:"+windowAttributesInViewRootImpl.y
+                        +",w:"+windowAttributesInViewRootImpl.width
+                        +",h:"+windowAttributesInViewRootImpl.height
+                        +",isFullscreen:"+windowAttributesInViewRootImpl.isFullscreen
+                        +",isInWindowing:"+windowAttributesInViewRootImpl.isInWindowing);
+                /**
+                 * Ritter_multi Because when the window been touch, the
+                 * moveTaskToFront() will be called, then the resume() called,
+                 * setLayoutParams() called, it's will get the window's decor
+                 * view to set into attrs, so I would better make its x and y
+                 * changed too.
+                 */
+                /**
+                 * There are 2 attrs, one in Window, one in ViewRootImpl.
+                 * */
+//                windowAttributesInWindow.getWindowingParam();
+                windowAttributesInWindow.x = windowAttributesInViewRootImpl.x;
+                windowAttributesInWindow.y = windowAttributesInViewRootImpl.y;
+                windowAttributesInWindow.width = windowAttributesInViewRootImpl.width;
+                windowAttributesInWindow.height = windowAttributesInViewRootImpl.height;
+            } else {
+                int screenWidth = getWindowManager().getDefaultDisplay().getWidth();
+                int screenHeight = getWindowManager().getDefaultDisplay().getHeight();
+                int notificationBarHeight = 50;
+                Log.d(TAG, "Ritter::PW toggleFullscreen() isFullscreen==false ("+screenWidth+","+screenHeight+")");
+                windowAttributesInViewRootImpl.x = 0;
+                windowAttributesInViewRootImpl.y = notificationBarHeight;
+                windowAttributesInViewRootImpl.width = screenWidth;
+                windowAttributesInViewRootImpl.height = screenHeight - notificationBarHeight;
+                /**
+                 * Ritter_multi Because when the window been touch, the
+                 * moveTaskToFront() will be called, then the resume() called,
+                 * setLayoutParams() called, it's will get the window's decor
+                 * view to set into attrs, so I would better make its x and y
+                 * changed too.
+                 */
+                /**
+                 * There are 2 attrs, one in Window, one in ViewRootImpl.
+                 * */
+                windowAttributesInWindow.x = windowAttributesInViewRootImpl.x;
+                windowAttributesInWindow.y = windowAttributesInViewRootImpl.y;
+                windowAttributesInWindow.width = windowAttributesInViewRootImpl.width;
+                windowAttributesInWindow.height = windowAttributesInViewRootImpl.height;
+            }
+            root.relayoutWindowPublic(windowAttributesInViewRootImpl,
+                    View.VISIBLE, false);
+            windowAttributesInViewRootImpl.isFullscreen = !windowAttributesInViewRootImpl.isFullscreen;
+            windowAttributesInWindow.isFullscreen = !windowAttributesInWindow.isFullscreen;
+       }
+    }
 }
diff --git a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index dcaf3d6..5bd2bb1 100644
--- a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -23,6 +23,7 @@ import android.app.ProgressDialog;
 import android.app.SearchManager;
 import android.app.StatusBarManager;
 import android.app.UiModeManager;
+import android.app.WindowAppsManager;
 import android.content.ActivityNotFoundException;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
@@ -90,6 +91,7 @@ import android.view.Window;
 import android.view.WindowManager;
 import android.view.WindowManagerGlobal;
 import android.view.WindowManagerPolicy;
+import android.view.WindowManagerPolicy.WindowState;
 import android.view.accessibility.AccessibilityEvent;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
@@ -105,6 +107,8 @@ import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Arrays;
 
 import static android.view.WindowManager.LayoutParams.*;
 import static android.view.WindowManagerPolicy.WindowManagerFuncs.LID_ABSENT;
@@ -122,12 +126,16 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     static final String TAG = "WindowManager";
     static final boolean DEBUG = false;
     static final boolean localLOGV = false;
-    static final boolean DEBUG_LAYOUT = false;
-    static final boolean DEBUG_INPUT = false;
+    static final boolean DEBUG_LAYOUT = true;
+    static final boolean DEBUG_INPUT = true;
     static final boolean DEBUG_STARTING_WINDOW = false;
     static final boolean SHOW_STARTING_ANIMATIONS = true;
     static final boolean SHOW_PROCESSES_ON_ALT_MENU = false;
 
+    public PhoneWindowManager(){
+        Log.d(TAG,"Ritter::PWM PhoneWindowManager()");
+    }
+
     // Whether to allow dock apps with METADATA_DOCK_HOME to temporarily take over the Home key.
     // No longer recommended for desk docks; still useful in car docks.
     static final boolean ENABLE_CAR_DOCK_HOME_CAPTURE = true;
@@ -551,7 +559,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         @Override
         public void onProposedRotationChanged(int rotation) {
-            if (localLOGV) Slog.v(TAG, "onProposedRotationChanged, rotation=" + rotation);
+            if (localLOGV) Log.d(TAG, "onProposedRotationChanged, rotation=" + rotation);
             updateRotation(false);
         }
     }
@@ -638,7 +646,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
         //Could have been invoked due to screen turning on or off or
         //change of the currently visible window's orientation
-        if (localLOGV) Slog.v(TAG, "Screen status="+mScreenOnEarly+
+        if (localLOGV) Log.d(TAG, "Screen status="+mScreenOnEarly+
                 ", current orientation="+mCurrentAppOrientation+
                 ", SensorEnabled="+mOrientationSensorEnabled);
         boolean disable = true;
@@ -648,7 +656,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 //enable listener if not already enabled
                 if (!mOrientationSensorEnabled) {
                     mOrientationListener.enable();
-                    if(localLOGV) Slog.v(TAG, "Enabling listeners");
+                    if(localLOGV) Log.d(TAG, "Enabling listeners");
                     mOrientationSensorEnabled = true;
                 }
             }
@@ -656,7 +664,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         //check if sensors need to be disabled
         if (disable && mOrientationSensorEnabled) {
             mOrientationListener.disable();
-            if(localLOGV) Slog.v(TAG, "Disabling listeners");
+            if(localLOGV) Log.d(TAG, "Disabling listeners");
             mOrientationSensorEnabled = false;
         }
     }
@@ -852,6 +860,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     @Override
     public void init(Context context, IWindowManager windowManager,
             WindowManagerFuncs windowManagerFuncs) {
+        Log.d(TAG,"Ritter::PWM init()");
         mContext = context;
         mWindowManager = windowManager;
         mWindowManagerFuncs = windowManagerFuncs;
@@ -1588,7 +1597,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         try {
             Context context = mContext;
-            if (DEBUG_STARTING_WINDOW) Slog.d(TAG, "addStartingWindow " + packageName
+            if (DEBUG_STARTING_WINDOW) Log.d(TAG, "addStartingWindow " + packageName
                     + ": nonLocalizedLabel=" + nonLocalizedLabel + " theme="
                     + Integer.toHexString(theme));
             if (theme != context.getThemeResId() || labelRes != 0) {
@@ -1662,7 +1671,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 return null;
             }
 
-            if (DEBUG_STARTING_WINDOW) Slog.d(
+            if (DEBUG_STARTING_WINDOW) Log.d(
                 TAG, "Adding starting window for " + packageName
                 + " / " + appToken + ": "
                 + (view.getParent() != null ? view : null));
@@ -1744,7 +1753,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 }
                 mNavigationBar = win;
                 mNavigationBarController.setWindow(win);
-                if (DEBUG_LAYOUT) Slog.i(TAG, "NAVIGATION BAR: " + mNavigationBar);
+                if (DEBUG_LAYOUT) Log.d(TAG, "NAVIGATION BAR: " + mNavigationBar);
                 break;
             case TYPE_NAVIGATION_BAR_PANEL:
                 mContext.enforceCallingOrSelfPermission(
@@ -1851,7 +1860,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     @Override
     public void selectRotationAnimationLw(int anim[]) {
-        if (PRINT_ANIM) Slog.i(TAG, "selectRotationAnimation mTopFullscreen="
+        if (PRINT_ANIM) Log.d(TAG, "selectRotationAnimation mTopFullscreen="
                 + mTopFullscreenOpaqueWindowState + " rotationAnimation="
                 + (mTopFullscreenOpaqueWindowState == null ?
                         "0" : mTopFullscreenOpaqueWindowState.getAttrs().rotationAnimation));
@@ -1942,6 +1951,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     @Override
     public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
+        Log.d(TAG,"Ritter::PWM interceptKeyBeforeDispatching()");
         final boolean keyguardOn = keyguardOn();
         final int keyCode = event.getKeyCode();
         final int repeatCount = event.getRepeatCount();
@@ -2198,7 +2208,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                                     + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                         }
                     } else {
-                        Slog.i(TAG, "Dropping unregistered shortcut key combination: "
+                        Log.d(TAG, "Dropping unregistered shortcut key combination: "
                                 + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                     }
                 }
@@ -2291,9 +2301,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     @Override
     public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) {
+        Log.d(TAG,"Ritter::PWM dispatchUnhandledKey()");
         // Note: This method is only called if the initial down was unhandled.
         if (DEBUG_INPUT) {
-            Slog.d(TAG, "Unhandled key: win=" + win + ", action=" + event.getAction()
+            Log.d(TAG, "Unhandled key: win=" + win + ", action=" + event.getAction()
                     + ", flags=" + event.getFlags()
                     + ", keyCode=" + event.getKeyCode()
                     + ", scanCode=" + event.getScanCode()
@@ -2320,7 +2331,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
             if (fallbackAction != null) {
                 if (DEBUG_INPUT) {
-                    Slog.d(TAG, "Fallback: keyCode=" + fallbackAction.keyCode
+                    Log.d(TAG, "Fallback: keyCode=" + fallbackAction.keyCode
                             + " metaState=" + Integer.toHexString(fallbackAction.metaState));
                 }
 
@@ -2348,9 +2359,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         if (DEBUG_INPUT) {
             if (fallbackEvent == null) {
-                Slog.d(TAG, "No fallback.");
+                Log.d(TAG, "No fallback.");
             } else {
-                Slog.d(TAG, "Performing fallback: " + fallbackEvent);
+                Log.d(TAG, "Performing fallback: " + fallbackEvent);
             }
         }
         return fallbackEvent;
@@ -2623,6 +2634,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     @Override
     public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight,
                               int displayRotation) {
+        Log.d(TAG,"Ritter::PWM beginLayoutLw()");
+        Log.d(TAG, "Ritter::PWM beginLayoutLw()");
         final int overscanLeft, overscanTop, overscanRight, overscanBottom;
         if (isDefaultDisplay) {
             switch (displayRotation) {
@@ -2697,6 +2710,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         dcf.setEmpty();  // Decor frame N/A for system bars.
 
         if (isDefaultDisplay) {
+            Log.d(TAG, "Ritter::PWM beginLayoutLw() isDefaultDisplay");
             // For purposes of putting out fake window up to steal focus, we will
             // drive nav being hidden only by whether it is requested.
             final int sysui = mLastSystemUiFlags;
@@ -2731,6 +2745,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
             boolean updateSysUiVisibility = false;
             if (mNavigationBar != null) {
+                Log.d(TAG, "Ritter::PWM beginLayoutLw() mNavigationBar != null");
                 boolean transientNavBarShowing = mNavigationBarController.isTransientShowing();
                 // Force the navigation bar to its appropriate place and
                 // size.  We need to do this directly, instead of relying on
@@ -2796,16 +2811,17 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 // And compute the final frame.
                 mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame,
                         mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, dcf);
-                if (DEBUG_LAYOUT) Slog.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
+                if (true) Log.d(TAG, "Ritter::PWM mNavigationBar frame: " + mTmpNavigationFrame);
                 if (mNavigationBarController.checkHiddenLw()) {
                     updateSysUiVisibility = true;
                 }
             }
-            if (DEBUG_LAYOUT) Slog.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)",
+            if (true) Log.d(TAG, String.format("Ritter::PWM mDock rect: (%d,%d - %d,%d)",
                     mDockLeft, mDockTop, mDockRight, mDockBottom));
 
             // decide where the status bar goes ahead of time
             if (mStatusBar != null) {
+                Log.d(TAG, "Ritter::PWM beginLayoutLw() mStatusBar != null");
                 // apply any navigation bar insets
                 pf.left = df.left = of.left = mUnrestrictedScreenLeft;
                 pf.top = df.top = of.top = mUnrestrictedScreenTop;
@@ -2842,7 +2858,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     mContentLeft = mCurLeft = mDockLeft;
                     mContentRight = mCurRight = mDockRight;
 
-                    if (DEBUG_LAYOUT) Slog.v(TAG, "Status bar: " +
+                    if (true) Log.d(TAG, "Ritter::PWM Status bar: " +
                         String.format(
                             "dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]",
                             mDockLeft, mDockTop, mDockRight, mDockBottom,
@@ -2951,6 +2967,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     @Override
     public void layoutWindowLw(WindowState win, WindowManager.LayoutParams attrs,
             WindowState attached) {
+        Log.d(TAG,"Ritter::PWM layoutWindowLw()");
         // we've already done the status bar
         if (win == mStatusBar || win == mNavigationBar) {
             return;
@@ -2959,7 +2976,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         final boolean needsToOffsetInputMethodTarget = isDefaultDisplay &&
                 (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
         if (needsToOffsetInputMethodTarget) {
-            if (DEBUG_LAYOUT) Slog.i(TAG, "Offset ime target window by the last ime window state");
+            if (DEBUG_LAYOUT) Log.d(TAG, "Offset ime target window by the last ime window state");
             offsetInputMethodWindowLw(mLastInputMethodWindow);
         }
 
@@ -2980,12 +2997,16 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
 
+        Log.d(TAG,"Ritter::PWM layoutWindowLw() isDefaultDisplay:"+isDefaultDisplay);
         if (!isDefaultDisplay) {
+            Log.d(TAG,"Ritter::PWM layoutWindowLw()A1 !isDefaultDisplay");
             if (attached != null) {
+                Log.d(TAG,"Ritter::PWM layoutWindowLw()B1 attached != null");
                 // If this window is attached to another, our display
                 // frame is the same as the one we are attached to.
                 setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
             } else {
+                Log.d(TAG,"Ritter::PWM layoutWindowLw()B2 attached == null");
                 // Give the window full screen.
                 pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                 pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
@@ -2995,6 +3016,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         = mOverscanScreenTop + mOverscanScreenHeight;
             }
         } else  if (attrs.type == TYPE_INPUT_METHOD) {
+            Log.d(TAG,"Ritter::PWM layoutWindowLw()A2 isDefaultDisplay && attrs.type == TYPE_INPUT_METHOD");
             pf.left = df.left = of.left = cf.left = vf.left = mDockLeft;
             pf.top = df.top = of.top = cf.top = vf.top = mDockTop;
             pf.right = df.right = of.right = cf.right = vf.right = mDockRight;
@@ -3006,7 +3028,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             attrs.gravity = Gravity.BOTTOM;
             mDockLayer = win.getSurfaceLayer();
         } else {
-
+            Log.d(TAG,"Ritter::PWM layoutWindowLw()A3 isDefaultDisplay");
             // Default policy decor for the default display
             dcf.left = mSystemLeft;
             dcf.top = mSystemTop;
@@ -3036,19 +3058,23 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
             if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR))
                     == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
-                if (DEBUG_LAYOUT) Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() 
+                if (true) Log.d(TAG, "Ritter::PWM layoutWindowLw(" + attrs.getTitle()
                             + "): IN_SCREEN, INSET_DECOR");
+                Log.d(TAG,"Ritter::PWM B1 This is the case for a normal activity window");
                 // This is the case for a normal activity window: we want it
                 // to cover all of the screen space, and it can take care of
                 // moving its contents to account for screen decorations that
                 // intrude into that space.
                 if (attached != null) {
+                    Log.d(TAG,"Ritter::PWM C1 attached != null");
                     // If this window is attached to another, our display
                     // frame is the same as the one we are attached to.
                     setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
                 } else {
+                    Log.d(TAG,"Ritter::PWM C2 attached == null");
                     if (attrs.type == TYPE_STATUS_BAR_PANEL
                             || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
+                        Log.d(TAG,"Ritter::PWM D1 Status bar panels");
                         // Status bar panels are the only windows who can go on top of
                         // the status bar.  They are protected by the STATUS_BAR_SERVICE
                         // permission, so they have the same privileges as the status
@@ -3066,12 +3092,13 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                                 ? mRestrictedScreenTop+mRestrictedScreenHeight
                                 : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
 
-                        if (DEBUG_LAYOUT) Slog.v(TAG, String.format(
-                                        "Laying out status bar window: (%d,%d - %d,%d)",
+                        if (true) Log.d(TAG, String.format(
+                                        "Ritter::PWM Laying out status bar window: (%d,%d - %d,%d)",
                                         pf.left, pf.top, pf.right, pf.bottom));
                     } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0
                             && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW
                             && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
+                        Log.d(TAG,"Ritter::PWM BBB D2 Asking to layout into the overscan region");
                         // Asking to layout into the overscan region, so give it that pure
                         // unrestricted area.
                         pf.left = df.left = of.left = mOverscanScreenLeft;
@@ -3084,6 +3111,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                             && (attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || (
                                 attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW
                              && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
+                        Log.d(TAG,"Ritter::PWM CCC D3 Asking for layout as if the nav bar is hidden");
                         // Asking for layout as if the nav bar is hidden, lets the
                         // application extend into the unrestricted overscan screen area.  We
                         // only do this for application windows to ensure no window that
@@ -3100,6 +3128,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                         of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                     } else {
+                        Log.d(TAG,"Ritter::PWM DDD D4");
                         pf.left = df.left = mRestrictedOverscanScreenLeft;
                         pf.top = df.top = mRestrictedOverscanScreenTop;
                         pf.right = df.right = mRestrictedOverscanScreenLeft
@@ -3113,9 +3142,33 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         of.top = mUnrestrictedScreenTop;
                         of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                         of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
+
+                        //Ritter_multi
+                        if(false&&attrs != null){
+                            Log.d(TAG,"Ritter::PWM DDD D4 attrs != null");
+                            Log.d(TAG,"Ritter::PWM DDD D4 attrs.getTitle():"+attrs.getTitle()+",attrs.packageName:"+attrs.packageName);
+                            if(attrs.packageName != null && (
+                                    attrs.packageName.equals("com.intel.aware.sensorbench")
+                                    || attrs.packageName.equals("com.example.hello")
+
+                                    )) {
+                                Log.d(TAG,"Ritter::PWM DDD D4 attrs.getTitle():"+attrs.getTitle()+",attrs.packageName:"+attrs.packageName);
+                                pf.left = df.left = mRestrictedOverscanScreenLeft+300;
+                                pf.top = df.top = mRestrictedOverscanScreenTop+300;
+                                pf.right = df.right = mRestrictedOverscanScreenLeft
+                                        + mRestrictedOverscanScreenWidth-300;
+                                pf.bottom = df.bottom = mRestrictedOverscanScreenTop
+                                        + mRestrictedOverscanScreenHeight-300;
+
+                            }
+                        } else {
+                            Log.d(TAG, "Ritter::PWM DDD D4 attrs == null");
+                        }
+
                     }
 
                     if ((fl & FLAG_FULLSCREEN) == 0) {
+                        Log.d(TAG,"Ritter::PWM D5 !fl & FLAG_FULLSCREEN");
                         if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                             cf.left = mDockLeft;
                             cf.top = mDockTop;
@@ -3128,6 +3181,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                             cf.bottom = mContentBottom;
                         }
                     } else {
+                        Log.d(TAG,"Ritter::PWM D6 fl & FLAG_FULLSCREEN");
                         // Full screen windows are always given a layout that is as if the
                         // status bar and other transient decors are gone.  This is to avoid
                         // bad states when moving from a window that is not hding the
@@ -3139,23 +3193,45 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     }
                     applyStableConstraints(sysUiFl, fl, cf);
                     if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
+                        Log.d(TAG,"Ritter::PWM D7 adjust != SOFT_INPUT_ADJUST_NOTHING");
                         vf.left = mCurLeft;
                         vf.top = mCurTop;
                         vf.right = mCurRight;
                         vf.bottom = mCurBottom;
+
+                        /**
+                         * Author: Ritter_Multi
+                         * Date: 18/01/2011
+                         *
+                         * Adjusts the size of pf, df, cf, vf rects.
+                         */
+                        if (attrs.type != TYPE_STATUS_BAR_PANEL
+                                || attrs.type != TYPE_STATUS_BAR_SUB_PANEL) {
+                            setWindowInFrame(win, attrs, pf, df, cf, vf);
+                        }
                     } else {
+                        Log.d(TAG,"Ritter::PWM D8 adjust == SOFT_INPUT_ADJUST_NOTHING");
                         vf.set(cf);
+                        /**
+                         * Author: Ritter_Multi
+                         * Date: 18/01/2011
+                         *
+                         * Adjusts the size of pf, df, cf, vf rects.
+                         */
+                        setWindowInFrame(win, attrs, pf, df, cf, vf);
                     }
                 }
             } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl
                     & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                             | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
-                if (DEBUG_LAYOUT) Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() +
+                if (DEBUG_LAYOUT) Log.d(TAG, "layoutWindowLw(" + attrs.getTitle() +
                         "): IN_SCREEN");
+                Log.d(TAG,"Ritter::PWM B2 A window that has requested to fill the entire screen");
                 // A window that has requested to fill the entire screen just
                 // gets everything, period.
                 if (attrs.type == TYPE_STATUS_BAR_PANEL
                         || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
+                    Log.d(TAG,"Ritter::PWM C1 STATUS_BAR_PANEL");
                     pf.left = df.left = of.left = cf.left = hasNavBar
                             ? mDockLeft : mUnrestrictedScreenLeft;
                     pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
@@ -3165,11 +3241,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     pf.bottom = df.bottom = of.bottom = cf.bottom = hasNavBar
                                           ? mRestrictedScreenTop+mRestrictedScreenHeight
                                           : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
-                    if (DEBUG_LAYOUT) Slog.v(TAG, String.format(
-                                    "Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)",
+                    if (true) Log.d(TAG, String.format(
+                                    "Ritter::WMS Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)",
                                     pf.left, pf.top, pf.right, pf.bottom));
                 } else if (attrs.type == TYPE_NAVIGATION_BAR
                         || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
+                    Log.d(TAG,"Ritter::PWM C2 TYPE_NAVIGATION_BAR");
                     // The navigation bar has Real Ultimate Power.
                     pf.left = df.left = of.left = mUnrestrictedScreenLeft;
                     pf.top = df.top = of.top = mUnrestrictedScreenTop;
@@ -3177,12 +3254,13 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                             + mUnrestrictedScreenWidth;
                     pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop
                             + mUnrestrictedScreenHeight;
-                    if (DEBUG_LAYOUT) Slog.v(TAG, String.format(
-                                    "Laying out navigation bar window: (%d,%d - %d,%d)",
+                    if (true) Log.d(TAG, String.format(
+                                    "Ritter::PWM Laying out navigation bar window: (%d,%d - %d,%d)",
                                     pf.left, pf.top, pf.right, pf.bottom));
                 } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY
                                 || attrs.type == TYPE_BOOT_PROGRESS)
                         && ((fl & FLAG_FULLSCREEN) != 0)) {
+                    Log.d(TAG,"Ritter::PWM C3 Fullscreen secure system overlays ");
                     // Fullscreen secure system overlays get what they ask for.
                     pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                     pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
@@ -3192,6 +3270,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                             + mOverscanScreenHeight;
                 } else if (attrs.type == TYPE_BOOT_PROGRESS
                         || attrs.type == TYPE_UNIVERSE_BACKGROUND) {
+                    Log.d(TAG,"Ritter::PWM C4 Boot progress screen ");
                     // Boot progress screen always covers entire display.
                     pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                     pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
@@ -3200,6 +3279,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop
                             + mOverscanScreenHeight;
                 } else if (attrs.type == TYPE_WALLPAPER) {
+                    Log.d(TAG,"Ritter::PWM C5 TYPE_WALLPAPER");
                     // The wallpaper also has Real Ultimate Power.
                     pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
                     pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
@@ -3210,6 +3290,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0
                         && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW
                         && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
+                    Log.d(TAG,"Ritter::PWM C6 Asking to layout into the overscan region");
                     // Asking to layout into the overscan region, so give it that pure
                     // unrestricted area.
                     pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
@@ -3223,6 +3304,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         && (attrs.type == TYPE_TOAST
                             || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW
                             && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
+                    Log.d(TAG,"Ritter::PWM C7 Asking for layout as if the nav bar is hidden");
                     // Asking for layout as if the nav bar is hidden, lets the
                     // application extend into the unrestricted screen area.  We
                     // only do this for application windows (or toasts) to ensure no window that
@@ -3237,6 +3319,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop
                             + mUnrestrictedScreenHeight;
                 } else {
+                    Log.d(TAG,"Ritter::PWM C8 else");
                     pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                     pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                     pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft
@@ -3248,25 +3331,30 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 applyStableConstraints(sysUiFl, fl, cf);
 
                 if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
+                    Log.d(TAG,"Ritter::PWM C9 adjust != SOFT_INPUT_ADJUST_NOTHING");
                     vf.left = mCurLeft;
                     vf.top = mCurTop;
                     vf.right = mCurRight;
                     vf.bottom = mCurBottom;
                 } else {
+                    Log.d(TAG,"Ritter::PWM C10 adjust == SOFT_INPUT_ADJUST_NOTHING");
                     vf.set(cf);
                 }
             } else if (attached != null) {
-                if (DEBUG_LAYOUT) Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() +
+                Log.d(TAG,"Ritter::PWM B3 attached != null A child window should be placed inside of the same visible frame that its parent had");
+                if (true) Log.d(TAG, "Ritter::PWM layoutWindowLw(" + attrs.getTitle() +
                         "): attached to " + attached);
                 // A child window should be placed inside of the same visible
                 // frame that its parent had.
                 setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, of, cf, vf);
             } else {
-                if (DEBUG_LAYOUT) Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() +
+                Log.d(TAG,"Ritter::PWM B4 else a normal window must be placed inside the content of all screen decorations.");
+                if (true) Log.d(TAG, "Ritter::PWM layoutWindowLw(" + attrs.getTitle() +
                         "): normal window");
                 // Otherwise, a normal window must be placed inside the content
                 // of all screen decorations.
                 if (attrs.type == TYPE_STATUS_BAR_PANEL) {
+                    Log.d(TAG,"Ritter::PWM C1 TYPE_STATUS_BAR_PANEL");
                     // Status bar panels are the only windows who can go on top of
                     // the status bar.  They are protected by the STATUS_BAR_SERVICE
                     // permission, so they have the same privileges as the status
@@ -3278,33 +3366,39 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop
                             + mRestrictedScreenHeight;
                 } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT) {
+                    Log.d(TAG,"Ritter::PWM C2 TYPE_TOAST || TYPE_SYSTEM_ALERT");
                     // Toasts are stable to interim decor changes.
                     pf.left = df.left = of.left = cf.left = mStableLeft;
                     pf.top = df.top = of.top = cf.top = mStableTop;
                     pf.right = df.right = of.right = cf.right = mStableRight;
                     pf.bottom = df.bottom = of.bottom = cf.bottom = mStableBottom;
                 } else {
+                    Log.d(TAG,"Ritter::PWM C3 else");
                     pf.left = mContentLeft;
                     pf.top = mContentTop;
                     pf.right = mContentRight;
                     pf.bottom = mContentBottom;
                     if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
+                        Log.d(TAG,"Ritter::PWM D1 adjust != SOFT_INPUT_ADJUST_RESIZE");
                         df.left = of.left = cf.left = mDockLeft;
                         df.top = of.top = cf.top = mDockTop;
                         df.right = of.right = cf.right = mDockRight;
                         df.bottom = of.bottom = cf.bottom = mDockBottom;
                     } else {
+                        Log.d(TAG,"Ritter::PWM D2 adjust == SOFT_INPUT_ADJUST_RESIZE");
                         df.left = of.left = cf.left = mContentLeft;
                         df.top = of.top = cf.top = mContentTop;
                         df.right = of.right = cf.right = mContentRight;
                         df.bottom = of.bottom = cf.bottom = mContentBottom;
                     }
                     if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
+                        Log.d(TAG,"Ritter::PWM D3 adjust != SOFT_INPUT_ADJUST_NOTHING");
                         vf.left = mCurLeft;
                         vf.top = mCurTop;
                         vf.right = mCurRight;
                         vf.bottom = mCurBottom;
                     } else {
+                        Log.d(TAG,"Ritter::PWM D4 adjust == SOFT_INPUT_ADJUST_NOTHING");
                         vf.set(cf);
                     }
                 }
@@ -3318,7 +3412,34 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     = vf.right = vf.bottom = 10000;
         }
 
-        if (DEBUG_LAYOUT) Slog.v(TAG, "Compute frame " + attrs.getTitle()
+        //Ritter_multi
+        // Get window apps from service
+        String APPs = "";
+        WindowAppsManager mWindowAppsManager = (WindowAppsManager) mContext
+                .getSystemService("window_apps");
+        try {
+            APPs = mWindowAppsManager.getWindowApps();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        ArrayList<String> pkgList = new ArrayList<String>(Arrays.asList(APPs
+                .split("#")));
+//        if(win.getAttrs().isInWindowing
+        if(true
+                && win.getAttrs().packageName != null
+                && !win.getAttrs().packageName.isEmpty()
+                && pkgList.contains(win.getAttrs().packageName)) {
+            Log.d(TAG, "Ritter::PWM Compute frame win.getAttrs().isInWindowing() win.getAttrs().packageName:"
+                    +win.getAttrs().packageName);
+//            win.getAttrs().isInWindowing = false;
+            pf.left = df.left = of.left = cf.left = win.getAttrs().x;
+            pf.top = df.top = of.top = cf.top = win.getAttrs().y;
+            pf.right = df.right = of.right = cf.right = win.getAttrs().x + win.getAttrs().width;
+            pf.bottom = df.bottom = of.bottom = cf.bottom = win.getAttrs().y + win.getAttrs().height;
+        }
+        //end
+
+		if (true) Log.d(TAG, "Ritter::PWM Compute frame " + attrs.getTitle()
                 + ": sim=#" + Integer.toHexString(sim)
                 + " attach=" + attached + " type=" + attrs.type 
                 + String.format(" flags=0x%08x", fl)
@@ -3349,7 +3470,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if (mCurBottom > top) {
             mCurBottom = top;
         }
-        if (DEBUG_LAYOUT) Slog.v(TAG, "Input method: mDockBottom="
+        if (DEBUG_LAYOUT) Log.d(TAG, "Input method: mDockBottom="
                 + mDockBottom + " mContentBottom="
                 + mContentBottom + " mCurBottom=" + mCurBottom);
     }
@@ -3357,6 +3478,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     @Override
     public void finishLayoutLw() {
+        Log.d(TAG,"Ritter::PWM finishLayoutLw()");
         return;
     }
 
@@ -3380,7 +3502,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     @Override
     public void applyPostLayoutPolicyLw(WindowState win,
                                 WindowManager.LayoutParams attrs) {
-        if (DEBUG_LAYOUT) Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw="
+        if (DEBUG_LAYOUT) Log.d(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw="
                 + win.isVisibleOrBehindKeyguardLw());
         if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags
                 &WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0
@@ -3417,16 +3539,16 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     && attrs.x == 0 && attrs.y == 0
                     && attrs.width == WindowManager.LayoutParams.MATCH_PARENT
                     && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
-                if (DEBUG_LAYOUT) Slog.v(TAG, "Fullscreen window: " + win);
+                if (DEBUG_LAYOUT) Log.d(TAG, "Fullscreen window: " + win);
                 mTopFullscreenOpaqueWindowState = win;
                 if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
-                    if (DEBUG_LAYOUT) Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
+                    if (DEBUG_LAYOUT) Log.d(TAG, "Setting mHideLockScreen to true by win " + win);
                     mHideLockScreen = true;
                     mForceStatusBarFromKeyguard = false;
                 }
                 if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0
                         && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
-                    if (DEBUG_LAYOUT) Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
+                    if (DEBUG_LAYOUT) Log.d(TAG, "Setting mDismissKeyguard true by win " + win);
                     mDismissKeyguard = mWinDismissingKeyguard == win ?
                             DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                     mWinDismissingKeyguard = win;
@@ -3458,19 +3580,19 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
 
         if (mStatusBar != null) {
-            if (DEBUG_LAYOUT) Slog.i(TAG, "force=" + mForceStatusBar
+            if (DEBUG_LAYOUT) Log.d(TAG, "force=" + mForceStatusBar
                     + " forcefkg=" + mForceStatusBarFromKeyguard
                     + " top=" + mTopFullscreenOpaqueWindowState);
             if (mForceStatusBar || mForceStatusBarFromKeyguard) {
-                if (DEBUG_LAYOUT) Slog.v(TAG, "Showing status bar: forced");
+                if (DEBUG_LAYOUT) Log.d(TAG, "Showing status bar: forced");
                 if (mStatusBarController.setBarShowingLw(true)) {
                     changes |= FINISH_LAYOUT_REDO_LAYOUT;
                 }
             } else if (mTopFullscreenOpaqueWindowState != null) {
                 if (localLOGV) {
-                    Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw()
+                    Log.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw()
                             + " shown frame: " + mTopFullscreenOpaqueWindowState.getShownFrameLw());
-                    Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs()
+                    Log.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs()
                             + " lp.flags=0x" + Integer.toHexString(lp.flags));
                 }
                 topIsFullscreen = (lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0
@@ -3484,14 +3606,14 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         changes |= FINISH_LAYOUT_REDO_LAYOUT;
                     }
                 } else if (topIsFullscreen) {
-                    if (DEBUG_LAYOUT) Slog.v(TAG, "** HIDING status bar");
+                    if (DEBUG_LAYOUT) Log.d(TAG, "** HIDING status bar");
                     if (mStatusBarController.setBarShowingLw(false)) {
                         changes |= FINISH_LAYOUT_REDO_LAYOUT;
                     } else {
-                        if (DEBUG_LAYOUT) Slog.v(TAG, "Status bar already hiding");
+                        if (DEBUG_LAYOUT) Log.d(TAG, "Status bar already hiding");
                     }
                 } else {
-                    if (DEBUG_LAYOUT) Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
+                    if (DEBUG_LAYOUT) Log.d(TAG, "** SHOWING status bar: top is not fullscreen");
                     if (mStatusBarController.setBarShowingLw(true)) {
                         changes |= FINISH_LAYOUT_REDO_LAYOUT;
                     }
@@ -3504,7 +3626,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         // Hide the key guard if a visible window explicitly specifies that it wants to be
         // displayed when the screen is locked.
         if (mKeyguard != null) {
-            if (localLOGV) Slog.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard="
+            if (localLOGV) Log.d(TAG, "finishPostLayoutPolicyLw: mHideKeyguard="
                     + mHideLockScreen);
             if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !mKeyguardDelegate.isSecure()) {
                 if (mKeyguard.hideLw(true)) {
@@ -3777,6 +3899,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     @Override
     public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags, boolean isScreenOn) {
+        Log.d(TAG,"Ritter::PWM interceptKeyBeforeQueueing()");
         if (!mSystemBooted) {
             // If we have not yet booted, don't let key events do anything.
             return 0;
@@ -4097,6 +4220,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     @Override
     public int interceptMotionBeforeQueueingWhenScreenOff(int policyFlags) {
+        Log.d(TAG,"Ritter::PWM interceptMotionBeforeQueueingWhenScreenOff()");
         int result = 0;
 
         final boolean isWakeMotion = (policyFlags
@@ -4109,12 +4233,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     void dispatchMediaKeyWithWakeLock(KeyEvent event) {
         if (DEBUG_INPUT) {
-            Slog.d(TAG, "dispatchMediaKeyWithWakeLock: " + event);
+            Log.d(TAG, "dispatchMediaKeyWithWakeLock: " + event);
         }
 
         if (mHavePendingMediaKeyRepeatWithWakeLock) {
             if (DEBUG_INPUT) {
-                Slog.d(TAG, "dispatchMediaKeyWithWakeLock: canceled repeat");
+                Log.d(TAG, "dispatchMediaKeyWithWakeLock: canceled repeat");
             }
 
             mHandler.removeMessages(MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK);
@@ -4143,7 +4267,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         KeyEvent repeatEvent = KeyEvent.changeTimeRepeat(event,
                 SystemClock.uptimeMillis(), 1, event.getFlags() | KeyEvent.FLAG_LONG_PRESS);
         if (DEBUG_INPUT) {
-            Slog.d(TAG, "dispatchMediaKeyRepeatWithWakeLock: " + repeatEvent);
+            Log.d(TAG, "dispatchMediaKeyRepeatWithWakeLock: " + repeatEvent);
         }
 
         dispatchMediaKeyWithWakeLockToAudioService(repeatEvent);
@@ -4227,7 +4351,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             if (sb || nb) {
                 WindowState barTarget = sb ? mStatusBar : mNavigationBar;
                 if (sb ^ nb && barTarget != swipeTarget) {
-                    if (DEBUG) Slog.d(TAG, "Not showing transient bar, wrong swipe target");
+                    if (DEBUG) Log.d(TAG, "Not showing transient bar, wrong swipe target");
                     return;
                 }
                 if (sb) mStatusBarController.showTransient();
@@ -4260,7 +4384,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if (false) {
             RuntimeException here = new RuntimeException("here");
             here.fillInStackTrace();
-            Slog.i(TAG, "Screen turning on...", here);
+            Log.d(TAG, "Screen turning on...", here);
         }
 
         synchronized (mLock) {
@@ -4286,7 +4410,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 mKeyguardDelegate.onScreenTurnedOn(null);
             }
         } else {
-            Slog.i(TAG, "No keyguard interface!");
+            Log.d(TAG, "No keyguard interface!");
         }
         finishScreenTurningOn(screenOnListener);
     }
@@ -4299,20 +4423,20 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         windowToken, new IRemoteCallback.Stub() {
                     @Override
                     public void sendResult(Bundle data) {
-                        Slog.i(TAG, "Lock screen displayed!");
+                        Log.d(TAG, "Lock screen displayed!");
                         finishScreenTurningOn(screenOnListener);
                     }
                 })) {
                     return;
                 }
-                Slog.i(TAG, "No lock screen! waitForWindowDrawn false");
+                Log.d(TAG, "No lock screen! waitForWindowDrawn false");
 
             } catch (RemoteException ex) {
                 // Can't happen in system process.
             }
         }
 
-        Slog.i(TAG, "No lock screen! windowToken=" + windowToken);
+        Log.d(TAG, "No lock screen! windowToken=" + windowToken);
         finishScreenTurningOn(screenOnListener);
     }
 
@@ -4414,7 +4538,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     @Override
     public int rotationForOrientationLw(int orientation, int lastRotation) {
         if (false) {
-            Slog.v(TAG, "rotationForOrientationLw(orient="
+            Log.d(TAG, "rotationForOrientationLw(orient="
                         + orientation + ", last=" + lastRotation
                         + "); user=" + mUserRotation + " "
                         + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED)
@@ -5417,4 +5541,110 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mStatusBarController.dump(pw, prefix);
         mNavigationBarController.dump(pw, prefix);
     }
+
+    /**
+     * Author: Ritter_Multi
+     * Date: 18/01/2011
+     *
+     * Sets the parent, display, content and visible Rects to the size of WindoState.mFrame rect.
+     */
+    private void setWindowInFrame(WindowState win, WindowManager.LayoutParams attrs, Rect pf, Rect df, Rect cf, Rect vf){
+        Log.d(TAG,"Ritter::setWindowInFrame()");
+        if(attrs != null){
+            if(attrs.packageName != null) {
+                Rect desiredRect = win.getFrameLw();
+                Log.d(TAG,"Ritter::setWindowInFrame() win.getFrameLw():l:"+desiredRect.left
+                        +",r:"+desiredRect.right+",t:"+desiredRect.top+",b:"+desiredRect.bottom);
+                //Default is to layout directly in the desired rectangle
+                pf.left = df.left = vf.left = cf.left = desiredRect.left;
+                pf.right = df.right = vf.right = cf.right = desiredRect.right;
+                pf.top = df.top = vf.top = cf.top= desiredRect.top;
+                pf.bottom = df.bottom = desiredRect.bottom;
+
+               /**
+                * Author: Onskreen
+                * Date: 05/04/2011
+                *
+                * If not an obstructed cs window, then behave as it used to.
+                * If SOFT_INPUT_ADJUST_RESIZE flag found, then reset the content and visible frame's bottom
+                * rect. It lays out the window's bottom position so that IME window doesn't hide the
+                * activity window underneath it.
+                */
+
+/*                //Only manipulate focused windows
+                if(win.isFocused()) {
+                    *//**
+                     * Author: Onskreen
+                     * Date: 16/06/2011
+                     *
+                     * Moved the obstructed cs window logic to setObstructedWindowInFrame
+                     * method.
+                     *//*
+                     setObstructedWindowInFrame(win, attrs, pf, df, cf, vf, desiredRect);
+                } else {
+                    //In case window was shifted somehow and then lost focus, make sure it reshifts
+                    //where it belongs.
+                    *//**
+                     * Author: Onskreen
+                     * Date: 16/06/2011
+                     *
+                     * Shift the unfocused window which is in the same window frame as
+                     * already shifted up the obstructed window when IME window is visible.
+                     *//*
+                    if(mWindowsShifted.size() == 0){
+                        if(mWindowsShifted.contains(win)) {
+                           if (DEBUG_LAYOUT) Log.v(TAG, "\tAction: Shift down " + mWindowShiftAmount + " pixels");
+                           //mWindowsShifted.remove(win);
+                           mWindowsShifted.clear();
+
+                           int modifiedTop = pf.top + mWindowShiftAmount;
+                           pf.top = df.top = cf.top = vf.top = modifiedTop;
+                           vf.bottom = cf.bottom = desiredRect.bottom + modifiedTop;
+                        } else {
+                           //set the bottom normally
+                           vf.bottom = cf.bottom = desiredRect.bottom;
+                        }
+                    *//**
+                     * Author: Onskreen
+                     * Date: 06/01/2011
+                     *
+                     * If shifted window loses focus, then it should move to its
+                     * default layout postion and removes the window from mWindowsShifted
+                     * list.
+                     *//*
+                    } else if (mWindowsShifted.contains(win)) {
+                        if (DEBUG_LAYOUT) Log.v(TAG, "\tAction: Shift down " + mWindowShiftAmount + " pixels");
+                        mWindowsShifted.remove(win);
+                        int modifiedTop = pf.top + mWindowShiftAmount;
+                        pf.top = df.top = cf.top = vf.top = modifiedTop;
+                        vf.bottom = cf.bottom = pf.bottom = df.bottom = desiredRect.bottom + modifiedTop;
+                    } else {
+                        WindowState w = (WindowState) mWindowsShifted.get(0);
+                        if(w != null) {
+                            IBinder token = win.getToken();
+                            boolean isWF = w.isInCornerstonePanelWindowPanel(token);
+                            if(isWF) {
+                               setObstructedWindowInFrame(win, attrs, pf, df, cf, vf, desiredRect);
+                            } else {
+                                //set the bottom normally
+                                vf.bottom = cf.bottom = desiredRect.bottom;
+                            }
+                        } else {
+                           //set the bottom normally
+                           vf.bottom = cf.bottom = desiredRect.bottom;
+                        }
+                    }
+                }*/
+
+               if (DEBUG_LAYOUT) {
+                  Log.v(TAG, "Final Rects for Window: " + win);
+                  Log.v(TAG, "pf: " + pf);
+                  Log.v(TAG, "df: " + df);
+                  Log.v(TAG, "cf: " + cf);
+                  Log.v(TAG, "vf: " + vf);
+               }
+            }
+        }
+    }
+
 }
diff --git a/frameworks/base/services/input/InputDispatcher.cpp b/frameworks/base/services/input/InputDispatcher.cpp
index 274009f..133c0ad 100644
--- a/frameworks/base/services/input/InputDispatcher.cpp
+++ b/frameworks/base/services/input/InputDispatcher.cpp
@@ -26,16 +26,16 @@
 #define DEBUG_OUTBOUND_EVENT_DETAILS 0
 
 // Log debug messages about the dispatch cycle.
-#define DEBUG_DISPATCH_CYCLE 0
+#define DEBUG_DISPATCH_CYCLE 1
 
 // Log debug messages about registrations.
 #define DEBUG_REGISTRATION 0
 
 // Log debug messages about input event injection.
-#define DEBUG_INJECTION 0
+#define DEBUG_INJECTION 1
 
 // Log debug messages about input focus tracking.
-#define DEBUG_FOCUS 0
+#define DEBUG_FOCUS 1
 
 // Log debug messages about the app switch latency optimization.
 #define DEBUG_APP_SWITCH 0
@@ -819,6 +819,7 @@ void InputDispatcher::logOutboundKeyDetailsLocked(const char* prefix, const KeyE
 
 bool InputDispatcher::dispatchMotionLocked(
         nsecs_t currentTime, MotionEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) {
+	ALOGD("Ritter InputDispatcher::dispatchMotionLocked");
     // Preprocessing.
     if (! entry->dispatchInProgress) {
         entry->dispatchInProgress = true;
@@ -909,6 +910,7 @@ void InputDispatcher::logOutboundMotionDetailsLocked(const char* prefix, const M
 
 void InputDispatcher::dispatchEventLocked(nsecs_t currentTime,
         EventEntry* eventEntry, const Vector<InputTarget>& inputTargets) {
+	ALOGD("Ritter InputDispatcher::dispatchEventLocked inputTargets.size:%d",inputTargets.size());
 #if DEBUG_DISPATCH_CYCLE
     ALOGD("dispatchEventToCurrentInputTargets");
 #endif
@@ -922,9 +924,15 @@ void InputDispatcher::dispatchEventLocked(nsecs_t currentTime,
 
         ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);
         if (connectionIndex >= 0) {
+            ALOGD("Ritter event delivery to target with channel '%s' because it "
+                    "connectionIndex>=0:%d",
+                    inputTarget.inputChannel->getName().string(),connectionIndex);
             sp<Connection> connection = mConnectionsByFd.valueAt(connectionIndex);
             prepareDispatchCycleLocked(currentTime, connection, eventEntry, &inputTarget);
         } else {
+            ALOGD("Ritter Dropping event delivery to target with channel '%s' because it "
+                    "is no longer registered with the input dispatcher.",
+                    inputTarget.inputChannel->getName().string());
 #if DEBUG_FOCUS
             ALOGD("Dropping event delivery to target with channel '%s' because it "
                     "is no longer registered with the input dispatcher.",
@@ -1118,6 +1126,7 @@ Unresponsive:
 int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
         const MotionEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime,
         bool* outConflictingPointerActions) {
+	ALOGD("Ritter InputDispatcher::findTouchedWindowTargetsLocked");
     enum InjectionPermission {
         INJECTION_PERMISSION_UNKNOWN,
         INJECTION_PERMISSION_GRANTED,
@@ -1196,6 +1205,7 @@ int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
     }
 
     if (newGesture || (isSplit && maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) {
+        ALOGD("Ritter InputDispatcher::findTouchedWindowTargetsLocked Case 1");
         /* Case 1: New splittable pointer going down, or need target for hover or scroll. */
 
         int32_t pointerIndex = getMotionEventActionPointerIndex(action);
@@ -1203,16 +1213,24 @@ int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
                 getAxisValue(AMOTION_EVENT_AXIS_X));
         int32_t y = int32_t(entry->pointerCoords[pointerIndex].
                 getAxisValue(AMOTION_EVENT_AXIS_Y));
+        ALOGD("Ritter InputDispatcher::findTouchedWindowTargetsLocked Case 1 x:%d,y:%d",x,y);
         sp<InputWindowHandle> newTouchedWindowHandle;
         sp<InputWindowHandle> topErrorWindowHandle;
         bool isTouchModal = false;
 
         // Traverse windows from front to back to find touched window and outside targets.
         size_t numWindows = mWindowHandles.size();
+        ALOGD("Ritter InputDispatcher::findTouchedWindowTargetsLocked Traverse windows from front to back to find touched window mWindowHandles.size:%d"
+        ,mWindowHandles.size());
         for (size_t i = 0; i < numWindows; i++) {
             sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);
             const InputWindowInfo* windowInfo = windowHandle->getInfo();
             if (windowInfo->displayId != displayId) {
+                ALOGD("Ritter wrong display windowInfo->name:%s,hasFocus:%d,paused:%d,canReceiveKeys:%d"
+                        ,windowInfo->name.string(),windowInfo->hasFocus,windowInfo->paused,windowInfo->canReceiveKeys);
+                ALOGD("Ritter wrong display windowInfo->l:%d,r:%d,t:%d,b:%d"
+                        ,windowInfo->frameLeft,windowInfo->frameRight,windowInfo->frameTop,windowInfo->frameBottom);
+                ALOGD("Ritter wrong display InputDispatcher::findTouchedWindowTargetsLocked Case 1 windowInfo->visible:%d",windowInfo->visible);
                 continue; // wrong display
             }
 
@@ -1224,6 +1242,11 @@ int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
             }
 
             int32_t flags = windowInfo->layoutParamsFlags;
+            ALOGD("Ritter windowInfo->name:%s,hasFocus:%d,paused:%d,canReceiveKeys:%d"
+                    ,windowInfo->name.string(),windowInfo->hasFocus,windowInfo->paused,windowInfo->canReceiveKeys);
+            ALOGD("Ritter windowInfo->l:%d,r:%d,t:%d,b:%d"
+                    ,windowInfo->frameLeft,windowInfo->frameRight,windowInfo->frameTop,windowInfo->frameBottom);
+            ALOGD("Ritter InputDispatcher::findTouchedWindowTargetsLocked Case 1 windowInfo->visible:%d",windowInfo->visible);
             if (windowInfo->visible) {
                 if (! (flags & InputWindowInfo::FLAG_NOT_TOUCHABLE)) {
                     isTouchModal = (flags & (InputWindowInfo::FLAG_NOT_FOCUSABLE
@@ -1261,6 +1284,7 @@ int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
             goto Unresponsive;
         }
 
+        ALOGD("Ritter Figure out whether splitting will be allowed for this window.");
         // Figure out whether splitting will be allowed for this window.
         if (newTouchedWindowHandle != NULL
                 && newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {
@@ -1271,7 +1295,7 @@ int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
             // Ignore the new window.
             newTouchedWindowHandle = NULL;
         }
-
+        ALOGD("Ritter isSplit:%d",isSplit);
         // Handle the case where we did not find a window.
         if (newTouchedWindowHandle == NULL) {
             // Try to assign the pointer to the first foreground window we find, if there is one.
@@ -1307,6 +1331,7 @@ int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
         }
         mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);
     } else {
+        ALOGD("Ritter InputDispatcher::findTouchedWindowTargetsLocked Case 2");
         /* Case 2: Pointer move, up, cancel or non-splittable pointer down. */
 
         // If the pointer is not currently down, then ignore the event.
@@ -1325,7 +1350,6 @@ int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
                 && mTempTouchState.isSlippery()) {
             int32_t x = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_X));
             int32_t y = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_Y));
-
             sp<InputWindowHandle> oldTouchedWindowHandle =
                     mTempTouchState.getFirstForegroundWindowHandle();
             sp<InputWindowHandle> newTouchedWindowHandle =
@@ -1593,9 +1617,13 @@ Unresponsive:
 
 void InputDispatcher::addWindowTargetLocked(const sp<InputWindowHandle>& windowHandle,
         int32_t targetFlags, BitSet32 pointerIds, Vector<InputTarget>& inputTargets) {
+	ALOGD("Ritter InputDispatcher::addWindowTargetLocked");
+
     inputTargets.push();
 
     const InputWindowInfo* windowInfo = windowHandle->getInfo();
+	ALOGD("Ritter InputDispatcher::addWindowTargetLocked name:%s,windowInfo->frameLeft:%d,windowInfo->frameTop:%d"
+			,windowInfo->name.string(),windowInfo->frameLeft,windowInfo->frameTop);
     InputTarget& target = inputTargets.editTop();
     target.inputChannel = windowInfo->inputChannel;
     target.flags = targetFlags;
@@ -4378,6 +4406,7 @@ void InputDispatcher::TouchState::copyFrom(const TouchState& other) {
 
 void InputDispatcher::TouchState::addOrUpdateWindow(const sp<InputWindowHandle>& windowHandle,
         int32_t targetFlags, BitSet32 pointerIds) {
+	ALOGD("Ritter InputDispatcher::TouchState::addOrUpdateWindow() ");
     if (targetFlags & InputTarget::FLAG_SPLIT) {
         split = true;
     }
diff --git a/frameworks/base/services/input/InputWindow.cpp b/frameworks/base/services/input/InputWindow.cpp
index fe61918..abcc836 100644
--- a/frameworks/base/services/input/InputWindow.cpp
+++ b/frameworks/base/services/input/InputWindow.cpp
@@ -25,6 +25,13 @@ namespace android {
 // --- InputWindowInfo ---
 
 bool InputWindowInfo::touchableRegionContainsPoint(int32_t x, int32_t y) const {
+	ALOGD("Ritter InputWindowInfo::touchableRegionContainsPoint x:%d,y:%d",x,y);
+	ALOGD("Ritter InputWindowInfo::touchableRegionContainsPoint touchableRegion:l:%d,r:%d,t:%d,b:%d"
+			,touchableRegion.getBounds().left()
+			,touchableRegion.getBounds().right()
+			,touchableRegion.getBounds().top()
+			,touchableRegion.getBounds().bottom());
+	ALOGD("Ritter InputWindowInfo::touchableRegionContainsPoint touchableRegion.contains(x, y):%d",touchableRegion.contains(x, y));
     return touchableRegion.contains(x, y);
 }
 
diff --git a/frameworks/base/services/java/com/android/server/SystemServer.java b/frameworks/base/services/java/com/android/server/SystemServer.java
index 0e0f156..9c6ca61 100644
--- a/frameworks/base/services/java/com/android/server/SystemServer.java
+++ b/frameworks/base/services/java/com/android/server/SystemServer.java
@@ -155,6 +155,9 @@ class ServerThread {
         InputManagerService inputManager = null;
         TelephonyRegistry telephonyRegistry = null;
         ConsumerIrService consumerIr = null;
+        //Ritter_multi add
+        WindowAppsService windowAppsService = null;
+        //end
 
         // Create a handler thread just for the window manager to enjoy.
         HandlerThread wmHandlerThread = new HandlerThread("WindowManager");
@@ -208,6 +211,11 @@ class ServerThread {
         boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
 
         try {
+            //Ritter_multi
+            Slog.i(TAG, "WindowAppsService Registry");
+            windowAppsService = new WindowAppsService(context);
+            ServiceManager.addService(Context.WINDOW_APPS_SERVICE, windowAppsService);
+            //end
             Slog.i(TAG, "Display Manager");
             display = new DisplayManagerService(context, wmHandler);
             ServiceManager.addService(Context.DISPLAY_SERVICE, display, true);
diff --git a/frameworks/base/services/java/com/android/server/WindowAppsService.java b/frameworks/base/services/java/com/android/server/WindowAppsService.java
new file mode 100644
index 0000000..c12968b
--- /dev/null
+++ b/frameworks/base/services/java/com/android/server/WindowAppsService.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import android.content.Context;
+import android.os.IWindowApps;
+import android.os.RemoteException;
+
+public class WindowAppsService extends IWindowApps.Stub {
+    private Context mContext;
+    private String mPkgName;
+
+    public WindowAppsService(Context context){
+        mContext = context;
+        mPkgName = "";
+    }
+
+    @Override
+    public void setWindowApps(String pkgName) throws RemoteException {
+        // TODO Auto-generated method stub
+        mPkgName = pkgName;
+    }
+
+    @Override
+    public String getWindowApps() throws RemoteException {
+        // TODO Auto-generated method stub
+        return mPkgName;
+    }
+
+}
diff --git a/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java b/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
index 3ba9098..274f897 100644
--- a/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
+++ b/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
@@ -213,11 +213,11 @@ public final class ActivityManagerService extends ActivityManagerNative
     static final boolean DEBUG_BACKGROUND_BROADCAST = DEBUG_BROADCAST || false;
     static final boolean DEBUG_CLEANUP = localLOGV || false;
     static final boolean DEBUG_CONFIGURATION = localLOGV || false;
-    static final boolean DEBUG_FOCUS = false;
+    static final boolean DEBUG_FOCUS = true;
     static final boolean DEBUG_IMMERSIVE = localLOGV || false;
     static final boolean DEBUG_MU = localLOGV || false;
     static final boolean DEBUG_OOM_ADJ = localLOGV || false;
-    static final boolean DEBUG_PAUSE = localLOGV || false;
+    static final boolean DEBUG_PAUSE = localLOGV || true;
     static final boolean DEBUG_POWER = localLOGV || false;
     static final boolean DEBUG_POWER_QUICK = DEBUG_POWER || false;
     static final boolean DEBUG_PROCESS_OBSERVERS = localLOGV || false;
@@ -226,14 +226,14 @@ public final class ActivityManagerService extends ActivityManagerNative
     static final boolean DEBUG_RESULTS = localLOGV || false;
     static final boolean DEBUG_SERVICE = localLOGV || false;
     static final boolean DEBUG_SERVICE_EXECUTING = localLOGV || false;
-    static final boolean DEBUG_STACK = localLOGV || false;
-    static final boolean DEBUG_SWITCH = localLOGV || false;
-    static final boolean DEBUG_TASKS = localLOGV || false;
+    static final boolean DEBUG_STACK = localLOGV || true;
+    static final boolean DEBUG_SWITCH = localLOGV || true;
+    static final boolean DEBUG_TASKS = localLOGV || true;
     static final boolean DEBUG_THUMBNAILS = localLOGV || false;
     static final boolean DEBUG_TRANSITION = localLOGV || false;
     static final boolean DEBUG_URI_PERMISSION = localLOGV || false;
     static final boolean DEBUG_USER_LEAVING = localLOGV || false;
-    static final boolean DEBUG_VISBILITY = localLOGV || false;
+    static final boolean DEBUG_VISBILITY = localLOGV || false || true;
     static final boolean DEBUG_PSS = localLOGV || false;
     static final boolean DEBUG_LOCKSCREEN = localLOGV || false;
     static final boolean VALIDATE_TOKENS = false;
@@ -365,7 +365,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     BroadcastQueue broadcastQueueForIntent(Intent intent) {
         final boolean isFg = (intent.getFlags() & Intent.FLAG_RECEIVER_FOREGROUND) != 0;
         if (DEBUG_BACKGROUND_BROADCAST) {
-            Slog.i(TAG, "Broadcast intent " + intent + " on "
+            Log.d(TAG, "Broadcast intent " + intent + " on "
                     + (isFg ? "foreground" : "background")
                     + " queue");
         }
@@ -988,7 +988,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         AppDeathRecipient(ProcessRecord app, int pid,
                 IApplicationThread thread) {
-            if (localLOGV) Slog.v(
+            if (localLOGV) Log.d(
                 TAG, "New death recipient " + this
                 + " for thread " + thread.asBinder());
             mApp = app;
@@ -998,7 +998,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         @Override
         public void binderDied() {
-            if (localLOGV) Slog.v(
+            if (localLOGV) Log.d(
                 TAG, "Death received in " + this
                 + " for thread " + mAppThread.asBinder());
             synchronized(ActivityManagerService.this) {
@@ -1055,7 +1055,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     final Handler mHandler = new Handler() {
         //public Handler() {
-        //    if (localLOGV) Slog.v(TAG, "Handler started!");
+        //    if (localLOGV) Log.d(TAG, "Handler started!");
         //}
 
         @Override
@@ -1561,7 +1561,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                             logBuilder.append(infos[Debug.MEMINFO_SWAP_FREE]);
                             logBuilder.append(" kB swap free\n");
                         }
-                        Slog.i(TAG, logBuilder.toString());
+                        Log.d(TAG, logBuilder.toString());
 
                         StringBuilder dropBuilder = new StringBuilder(1024);
                         /*
@@ -1599,8 +1599,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                         dropBuilder.append(catSw.toString());
                         addErrorToDropBox("lowmem", null, "system_server", null,
                                 null, tag.toString(), dropBuilder.toString(), null, null);
-                        //Slog.i(TAG, "Sent to dropbox:");
-                        //Slog.i(TAG, dropBuilder.toString());
+                        //Log.d(TAG, "Sent to dropbox:");
+                        //Log.d(TAG, dropBuilder.toString());
                         synchronized (ActivityManagerService.this) {
                             long now = SystemClock.uptimeMillis();
                             if (mLastMemUsageReportTime < now) {
@@ -1629,7 +1629,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 if (mUpdateLock.isHeld() != nextState) {
                     if (DEBUG_IMMERSIVE) {
                         final ActivityRecord r = (ActivityRecord) msg.obj;
-                        Slog.d(TAG, "Applying new update lock state '" + nextState + "' for " + r);
+                        Log.d(TAG, "Applying new update lock state '" + nextState + "' for " + r);
                     }
                     if (nextState) {
                         mUpdateLock.acquire();
@@ -1667,7 +1667,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     int pid;
                     synchronized (ActivityManagerService.this) {
                         if (i >= mPendingPssProcesses.size()) {
-                            if (DEBUG_PSS) Slog.d(TAG, "Collected PSS of " + num + " of " + i
+                            if (DEBUG_PSS) Log.d(TAG, "Collected PSS of " + num + " of " + i
                                     + " processes in " + (SystemClock.uptimeMillis()-start) + "ms");
                             mPendingPssProcesses.clear();
                             return;
@@ -1690,7 +1690,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                                 num++;
                                 proc.lastPssTime = SystemClock.uptimeMillis();
                                 proc.baseProcessTracker.addPss(pss, tmp[0], true, proc.pkgList);
-                                if (DEBUG_PSS) Slog.d(TAG, "PSS of " + proc.toShortString()
+                                if (DEBUG_PSS) Log.d(TAG, "PSS of " + proc.toShortString()
                                         + ": " + pss + " lastPss=" + proc.lastPss
                                         + " state=" + ProcessList.makeProcStateString(procState));
                                 if (proc.initialIdlePss == 0) {
@@ -1842,7 +1842,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
             // For debug builds, log event loop stalls to dropbox for analysis.
             if (StrictMode.conditionallyEnableDebugLogging()) {
-                Slog.i(TAG, "Enabled StrictMode logging for AThread's Looper");
+                Log.d(TAG, "Enabled StrictMode logging for AThread's Looper");
             }
 
             Looper.loop();
@@ -1934,7 +1934,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     private ActivityManagerService() {
-        Slog.i(TAG, "Memory class: " + ActivityManager.staticGetMemoryClass());
+        Log.d(TAG, "Memory class: " + ActivityManager.staticGetMemoryClass());
 
         mFgBroadcastQueue = new BroadcastQueue(this, "foreground", BROADCAST_FG_TIMEOUT, false);
         mBgBroadcastQueue = new BroadcastQueue(this, "background", BROADCAST_BG_TIMEOUT, true);
@@ -1993,7 +1993,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                                 final long now = SystemClock.uptimeMillis();
                                 long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;
                                 long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;
-                                //Slog.i(TAG, "Cpu delay=" + nextCpuDelay
+                                //Log.d(TAG, "Cpu delay=" + nextCpuDelay
                                 //        + ", write delay=" + nextWriteDelay);
                                 if (nextWriteDelay < nextCpuDelay) {
                                     nextCpuDelay = nextWriteDelay;
@@ -2080,8 +2080,8 @@ public final class ActivityManagerService extends ActivityManagerNative
                 mLastCpuTime.set(now);
                 haveNewCpuStats = true;
                 mProcessCpuTracker.update();
-                //Slog.i(TAG, mProcessCpu.printCurrentState());
-                //Slog.i(TAG, "Total CPU usage: "
+                //Log.d(TAG, mProcessCpu.printCurrentState());
+                //Log.d(TAG, "Total CPU usage: "
                 //        + mProcessCpu.getTotalCpuPercent() + "%");
 
                 // Slog the cpu usage if the property is set.
@@ -2201,8 +2201,9 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     final void setFocusedActivityLocked(ActivityRecord r) {
+        Log.d(TAG,"Ritter::AMS BACK_KEY setFocusedActivityLocked()");
         if (mFocusedActivity != r) {
-            if (DEBUG_FOCUS) Slog.d(TAG, "setFocusedActivityLocked: r=" + r);
+            if (DEBUG_FOCUS) Log.d(TAG, " BACK_KEY setFocusedActivityLocked: r=" + r);
             mFocusedActivity = r;
             mStackSupervisor.setFocusedStack(r);
             if (r != null) {
@@ -2214,7 +2215,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     @Override
     public void setFocusedStack(int stackId) {
-        if (DEBUG_FOCUS) Slog.d(TAG, "setFocusedStack: stackId=" + stackId);
+        if (DEBUG_FOCUS) Log.d(TAG, "setFocusedStack: stackId=" + stackId);
         synchronized (ActivityManagerService.this) {
             ActivityStack stack = mStackSupervisor.getStack(stackId);
             if (stack != null) {
@@ -2228,7 +2229,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     @Override
     public void notifyActivityDrawn(IBinder token) {
-        if (DEBUG_VISBILITY) Slog.d(TAG, "notifyActivityDrawn: token=" + token);
+        if (DEBUG_VISBILITY) Log.d(TAG, "notifyActivityDrawn: token=" + token);
         synchronized (this) {
             ActivityRecord r= mStackSupervisor.isInAnyStackLocked(token);
             if (r != null) {
@@ -2366,7 +2367,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
         }
 
-        //Slog.i(TAG, "Putting proc to front: " + app.processName);
+        //Log.d(TAG, "Putting proc to front: " + app.processName);
         if (oomAdj) {
             updateOomAdjLocked();
         }
@@ -2397,7 +2398,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         } else if (proc != null && !keepIfLarge
                 && mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL
                 && proc.setProcState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
-            if (DEBUG_PSS) Slog.d(TAG, "May not keep " + proc + ": pss=" + proc.lastCachedPss);
+            if (DEBUG_PSS) Log.d(TAG, "May not keep " + proc + ": pss=" + proc.lastCachedPss);
             if (proc.lastCachedPss >= mProcessList.getCachedRestoreThresholdKb()) {
                 if (proc.baseProcessTracker != null) {
                     proc.baseProcessTracker.reportCachedKill(proc.pkgList, proc.lastCachedPss);
@@ -2430,6 +2431,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             ApplicationInfo info, boolean knownToBeDead, int intentFlags,
             String hostingType, ComponentName hostingName, boolean allowWhileBooting,
             boolean isolated, boolean keepIfLarge) {
+        Log.d(TAG,"Ritter::AMS startProcessLocked()");
         ProcessRecord app;
         if (!isolated) {
             app = getProcessRecordLocked(processName, info.uid, keepIfLarge);
@@ -2443,7 +2445,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         //     object attached to it so we know it couldn't have crashed; and
         // (3) There is a pid assigned to it, so it is either starting or
         //     already running.
-        if (DEBUG_PROCESSES) Slog.v(TAG, "startProcess: name=" + processName
+        if (DEBUG_PROCESSES) Log.d(TAG, "startProcess: name=" + processName
                 + " app=" + app + " knownToBeDead=" + knownToBeDead
                 + " thread=" + (app != null ? app.thread : null)
                 + " pid=" + (app != null ? app.pid : -1));
@@ -2451,7 +2453,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (!knownToBeDead || app.thread == null) {
                 // We already have the app running, or are waiting for it to
                 // come up (we have a pid but not yet its thread), so keep it.
-                if (DEBUG_PROCESSES) Slog.v(TAG, "App already running: " + app);
+                if (DEBUG_PROCESSES) Log.d(TAG, "App already running: " + app);
                 // If this is a new package in the process, add the package to the list
                 app.addPackage(info.packageName, mProcessStats);
                 return app;
@@ -2459,7 +2461,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
             // An application record is attached to a previous process,
             // clean it up now.
-            if (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG, "App died: " + app);
+            if (DEBUG_PROCESSES || DEBUG_CLEANUP) Log.d(TAG, "App died: " + app);
             handleAppDiedLocked(app, true, true);
         }
 
@@ -2471,7 +2473,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 // If we are in the background, then check to see if this process
                 // is bad.  If so, we will just silently fail.
                 if (mBadProcesses.get(info.processName, info.uid) != null) {
-                    if (DEBUG_PROCESSES) Slog.v(TAG, "Bad process: " + info.uid
+                    if (DEBUG_PROCESSES) Log.d(TAG, "Bad process: " + info.uid
                             + "/" + info.processName);
                     return null;
                 }
@@ -2480,7 +2482,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 // crash count so that we won't make it bad until they see at
                 // least one crash dialog again, and make the process good again
                 // if it had been bad.
-                if (DEBUG_PROCESSES) Slog.v(TAG, "Clearing bad process: " + info.uid
+                if (DEBUG_PROCESSES) Log.d(TAG, "Clearing bad process: " + info.uid
                         + "/" + info.processName);
                 mProcessCrashTimes.remove(info.processName, info.uid);
                 if (mBadProcesses.get(info.processName, info.uid) != null) {
@@ -2519,7 +2521,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (!mProcessesOnHold.contains(app)) {
                 mProcessesOnHold.add(app);
             }
-            if (DEBUG_PROCESSES) Slog.v(TAG, "System not ready, putting on hold: " + app);
+            if (DEBUG_PROCESSES) Log.d(TAG, "System not ready, putting on hold: " + app);
             return app;
         }
 
@@ -2533,6 +2535,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     private final void startProcessLocked(ProcessRecord app,
             String hostingType, String hostingNameStr) {
+        Log.d(TAG,"Ritter::AMS startProcessLocked()2");
         if (app.pid > 0 && app.pid != MY_PID) {
             synchronized (mPidsSelfLocked) {
                 mPidsSelfLocked.remove(app.pid);
@@ -2541,7 +2544,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             app.setPid(0);
         }
 
-        if (DEBUG_PROCESSES && mProcessesOnHold.contains(app)) Slog.v(TAG,
+        if (DEBUG_PROCESSES && mProcessesOnHold.contains(app)) Log.d(TAG,
                 "startProcessLocked removing on hold: " + app);
         mProcessesOnHold.remove(app);
 
@@ -2662,7 +2665,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 }
             }
             buf.append("}");
-            Slog.i(TAG, buf.toString());
+            Log.d(TAG, buf.toString());
             app.setPid(startResult.pid);
             app.usingWrapper = startResult.usingWrapper;
             app.removed = false;
@@ -2681,7 +2684,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     void updateUsageStats(ActivityRecord component, boolean resumed) {
-        if (DEBUG_SWITCH) Slog.d(TAG, "updateUsageStats: comp=" + component + "res=" + resumed);
+        if (DEBUG_SWITCH) Log.d(TAG, "updateUsageStats: comp=" + component + "res=" + resumed);
         final BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
         if (resumed) {
             mUsageStatsService.noteResumeComponent(component.realActivity);
@@ -2889,7 +2892,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             mPendingProcessChanges.toArray(mActiveProcessChanges);
             mAvailProcessChanges.addAll(mPendingProcessChanges);
             mPendingProcessChanges.clear();
-            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG, "*** Delivering " + N + " process changes");
+            if (DEBUG_PROCESS_OBSERVERS) Log.d(TAG, "*** Delivering " + N + " process changes");
         }
 
         int i = mProcessObservers.beginBroadcast();
@@ -2901,14 +2904,14 @@ public final class ActivityManagerService extends ActivityManagerNative
                     for (int j=0; j<N; j++) {
                         ProcessChangeItem item = mActiveProcessChanges[j];
                         if ((item.changes&ProcessChangeItem.CHANGE_ACTIVITIES) != 0) {
-                            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG, "ACTIVITIES CHANGED pid="
+                            if (DEBUG_PROCESS_OBSERVERS) Log.d(TAG, "ACTIVITIES CHANGED pid="
                                     + item.pid + " uid=" + item.uid + ": "
                                     + item.foregroundActivities);
                             observer.onForegroundActivitiesChanged(item.pid, item.uid,
                                     item.foregroundActivities);
                         }
                         if ((item.changes&ProcessChangeItem.CHANGE_IMPORTANCE) != 0) {
-                            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG, "IMPORTANCE CHANGED pid="
+                            if (DEBUG_PROCESS_OBSERVERS) Log.d(TAG, "IMPORTANCE CHANGED pid="
                                     + item.pid + " uid=" + item.uid + ": " + item.importance);
                             observer.onImportanceChanged(item.pid, item.uid,
                                     item.importance);
@@ -3084,9 +3087,9 @@ public final class ActivityManagerService extends ActivityManagerNative
                             aInfo = resolves.get(i).activityInfo;
                         }
                         if (debug) {
-                            Slog.v(TAG, "Next matching activity: found current " + r.packageName
+                            Log.d(TAG, "Next matching activity: found current " + r.packageName
                                     + "/" + r.info.name);
-                            Slog.v(TAG, "Next matching activity: next is " + aInfo.packageName
+                            Log.d(TAG, "Next matching activity: next is " + aInfo.packageName
                                     + "/" + aInfo.name);
                         }
                         break;
@@ -3098,7 +3101,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (aInfo == null) {
                 // Nobody who is next!
                 ActivityOptions.abort(options);
-                if (debug) Slog.d(TAG, "Next matching activity: nothing found");
+                if (debug) Log.d(TAG, "Next matching activity: nothing found");
                 return false;
             }
 
@@ -3223,6 +3226,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     @Override
     public void setRequestedOrientation(IBinder token, int requestedOrientation) {
+        Log.d(TAG,"Ritter::AMS setRequestedOrientation()");
         synchronized (this) {
             ActivityRecord r = ActivityRecord.isInStackLocked(token);
             if (r == null) {
@@ -3264,6 +3268,7 @@ public final class ActivityManagerService extends ActivityManagerNative
      */
     @Override
     public final boolean finishActivity(IBinder token, int resultCode, Intent resultData) {
+        Log.d(TAG,"Ritter::AMS BACK_KEY finishActivity()");
         // Refuse possible leaked file descriptors
         if (resultData != null && resultData.hasFileDescriptors() == true) {
             throw new IllegalArgumentException("File descriptors passed in Intent");
@@ -3275,9 +3280,11 @@ public final class ActivityManagerService extends ActivityManagerNative
                 return true;
             }
             if (mController != null) {
+                Log.d(TAG,"Ritter::AMS BACK_KEY finishActivity: mController != null");
                 // Find the first activity that is not finishing.
                 ActivityRecord next = r.task.stack.topRunningActivityLocked(token, 0);
                 if (next != null) {
+                    Log.d(TAG,"Ritter::AMS BACK_KEY finishActivity: next != null");
                     // ask watcher if this is allowed
                     boolean resumeOK = true;
                     try {
@@ -3288,6 +3295,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     }
 
                     if (!resumeOK) {
+                        Log.d(TAG,"Ritter::AMS BACK_KEY finishActivity: !resumeOK return false");
                         return false;
                     }
                 }
@@ -3456,6 +3464,7 @@ public final class ActivityManagerService extends ActivityManagerNative
      */
     private final void handleAppDiedLocked(ProcessRecord app,
             boolean restarting, boolean allowRestart) {
+        Log.d(TAG,"Ritter::AMS handleAppDiedLocked()");
         cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1);
         if (!restarting) {
             removeLruProcessLocked(app);
@@ -3588,7 +3597,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             boolean doLowMem = app.instrumentationClass == null;
             boolean doOomAdj = doLowMem;
             if (!app.killedByAm) {
-                Slog.i(TAG, "Process " + app.processName + " (pid " + pid
+                Log.d(TAG, "Process " + app.processName + " (pid " + pid
                         + ") has died.");
                 mAllowLowerMemLevel = true;
             } else {
@@ -3598,7 +3607,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 doLowMem = false;
             }
             EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);
-            if (DEBUG_CLEANUP) Slog.v(
+            if (DEBUG_CLEANUP) Log.d(
                 TAG, "Dying app: " + app + ", pid: " + pid
                 + ", thread: " + thread.asBinder());
             handleAppDiedLocked(app, false, true);
@@ -3611,11 +3620,11 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
         } else if (app.pid != pid) {
             // A new process has already been started.
-            Slog.i(TAG, "Process " + app.processName + " (pid " + pid
+            Log.d(TAG, "Process " + app.processName + " (pid " + pid
                     + ") has died and restarted (pid " + app.pid + ").");
             EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);
         } else if (DEBUG_PROCESSES) {
-            Slog.d(TAG, "Received spurious death notification for thread "
+            Log.d(TAG, "Received spurious death notification for thread "
                     + thread.asBinder());
         }
     }
@@ -3835,13 +3844,13 @@ public final class ActivityManagerService extends ActivityManagerNative
         synchronized (this) {
             // PowerManager.reboot() can block for a long time, so ignore ANRs while shutting down.
             if (mShuttingDown) {
-                Slog.i(TAG, "During shutdown skipping ANR: " + app + " " + annotation);
+                Log.d(TAG, "During shutdown skipping ANR: " + app + " " + annotation);
                 return;
             } else if (app.notResponding) {
-                Slog.i(TAG, "Skipping duplicate ANR: " + app + " " + annotation);
+                Log.d(TAG, "Skipping duplicate ANR: " + app + " " + annotation);
                 return;
             } else if (app.crashing) {
-                Slog.i(TAG, "Crashing app skipping ANR: " + app + " " + annotation);
+                Log.d(TAG, "Crashing app skipping ANR: " + app + " " + annotation);
                 return;
             }
 
@@ -4016,7 +4025,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                         try {
                             observer.onRemoveCompleted(packageName, false);
                         } catch (RemoteException e) {
-                            Slog.i(TAG, "Observer no longer exists.");
+                            Log.d(TAG, "Observer no longer exists.");
                         }
                     }
                     return false;
@@ -4448,6 +4457,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     private final boolean forceStopPackageLocked(String name, int appId,
             boolean callerWillRestart, boolean purgeCache, boolean doit,
             boolean evenPersistent, int userId, String reason) {
+        Log.d(TAG,"Ritter::AMS forceStopPackageLocked()");
         int i;
         int N;
 
@@ -4465,10 +4475,10 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         if (doit) {
             if (name != null) {
-                Slog.i(TAG, "Force stopping " + name + " appid=" + appId
+                Log.d(TAG, "Force stopping " + name + " appid=" + appId
                         + " user=" + userId + ": " + reason);
             } else {
-                Slog.i(TAG, "Force stopping u" + userId + ": " + reason);
+                Log.d(TAG, "Force stopping u" + userId + ": " + reason);
             }
 
             final ArrayMap<String, SparseArray<Long>> pmap = mProcessCrashTimes.getMap();
@@ -4611,7 +4621,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             boolean callerWillRestart, boolean allowRestart, String reason) {
         final String name = app.processName;
         final int uid = app.uid;
-        if (DEBUG_PROCESSES) Slog.d(
+        if (DEBUG_PROCESSES) Log.d(
             TAG, "Force removing proc " + app.toShortString() + " (" + name
             + "/" + uid + ")");
 
@@ -4732,7 +4742,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         // Tell the process all about itself.
 
-        if (localLOGV) Slog.v(
+        if (localLOGV) Log.d(
                 TAG, "Binding process pid " + pid + " to record " + app);
 
         final String processName = app.processName;
@@ -4764,10 +4774,10 @@ public final class ActivityManagerService extends ActivityManagerNative
         List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
 
         if (!normalMode) {
-            Slog.i(TAG, "Launching preboot mode app: " + app);
+            Log.d(TAG, "Launching preboot mode app: " + app);
         }
 
-        if (localLOGV) Slog.v(
+        if (localLOGV) Log.d(
             TAG, "New app record " + app
             + " thread=" + thread.asBinder() + " pid=" + pid);
         try {
@@ -4811,7 +4821,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (app.instrumentationClass != null) {
                 ensurePackageDexOpt(app.instrumentationClass.getPackageName());
             }
-            if (DEBUG_CONFIGURATION) Slog.v(TAG, "Binding proc "
+            if (DEBUG_CONFIGURATION) Log.d(TAG, "Binding proc "
                     + processName + " with config " + mConfiguration);
             ApplicationInfo appInfo = app.instrumentationInfo != null
                     ? app.instrumentationInfo : app.info;
@@ -4842,7 +4852,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         // Remove this record from the list of starting applications.
         mPersistentStartingProcesses.remove(app);
-        if (DEBUG_PROCESSES && mProcessesOnHold.contains(app)) Slog.v(TAG,
+        if (DEBUG_PROCESSES && mProcessesOnHold.contains(app)) Log.d(TAG,
                 "Attach application locked removing on hold: " + app);
         mProcessesOnHold.remove(app);
 
@@ -4881,7 +4891,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         // Check whether the next backup agent is in this process...
         if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.uid) {
-            if (DEBUG_BACKUP) Slog.v(TAG, "New app is backup target, launching agent for " + app);
+            if (DEBUG_BACKUP) Log.d(TAG, "New app is backup target, launching agent for " + app);
             ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
             try {
                 thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,
@@ -4919,6 +4929,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     @Override
     public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {
+        Log.d(TAG,"Ritter::AMS activityIdle()");
         final long origId = Binder.clearCallingIdentity();
         synchronized (this) {
             ActivityStack stack = ActivityRecord.getStackLocked(token);
@@ -5003,7 +5014,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 ArrayList<ProcessRecord> procs =
                     new ArrayList<ProcessRecord>(mProcessesOnHold);
                 for (int ip=0; ip<NP; ip++) {
-                    if (DEBUG_PROCESSES) Slog.v(TAG, "Starting process on hold: "
+                    if (DEBUG_PROCESSES) Log.d(TAG, "Starting process on hold: "
                             + procs.get(ip));
                     startProcessLocked(procs.get(ip), "on-hold", null);
                 }
@@ -5092,7 +5103,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     @Override
     public final void activityStopped(IBinder token, Bundle icicle, Bitmap thumbnail,
             CharSequence description) {
-        if (localLOGV) Slog.v(
+        if (localLOGV) Log.d(
             TAG, "Activity stopped: token=" + token);
 
         // Refuse possible leaked file descriptors
@@ -5122,7 +5133,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     @Override
     public final void activityDestroyed(IBinder token) {
-        if (DEBUG_SWITCH) Slog.v(TAG, "ACTIVITY DESTROYED: " + token);
+        if (DEBUG_SWITCH) Log.d(TAG, "ACTIVITY DESTROYED: " + token);
         synchronized (this) {
             ActivityStack stack = ActivityRecord.getStackLocked(token);
             if (stack != null) {
@@ -5254,7 +5265,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             int requestCode, Intent[] intents, String[] resolvedTypes, int flags,
             Bundle options) {
         if (DEBUG_MU)
-            Slog.v(TAG_MU, "getIntentSenderLocked(): uid=" + callingUid);
+            Log.d(TAG_MU, "getIntentSenderLocked(): uid=" + callingUid);
         ActivityRecord activity = null;
         if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {
             activity = ActivityRecord.isInStackLocked(token);
@@ -5552,7 +5563,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         // client identity accordingly before proceeding.
         Identity tlsIdentity = sCallerIdentity.get();
         if (tlsIdentity != null) {
-            Slog.d(TAG, "checkComponentPermission() adjusting {pid,uid} to {"
+            Log.d(TAG, "checkComponentPermission() adjusting {pid,uid} to {"
                     + tlsIdentity.pid + "," + tlsIdentity.uid + "}");
             uid = tlsIdentity.uid;
             pid = tlsIdentity.pid;
@@ -5617,7 +5628,7 @@ public final class ActivityManagerService extends ActivityManagerNative
      */
     private final boolean checkHoldingPermissionsLocked(
             IPackageManager pm, ProviderInfo pi, Uri uri, int uid, int modeFlags) {
-        if (DEBUG_URI_PERMISSION) Slog.v(TAG,
+        if (DEBUG_URI_PERMISSION) Log.d(TAG,
                 "checkHoldingPermissionsLocked: uri=" + uri + " uid=" + uid);
 
         if (pi.applicationInfo.uid == uid) {
@@ -5655,7 +5666,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     if (pp.match(path)) {
                         if (!readMet) {
                             final String pprperm = pp.getReadPermission();
-                            if (DEBUG_URI_PERMISSION) Slog.v(TAG, "Checking read perm for "
+                            if (DEBUG_URI_PERMISSION) Log.d(TAG, "Checking read perm for "
                                     + pprperm + " for " + pp.getPath()
                                     + ": match=" + pp.match(path)
                                     + " check=" + pm.checkUidPermission(pprperm, uid));
@@ -5669,7 +5680,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                         }
                         if (!writeMet) {
                             final String ppwperm = pp.getWritePermission();
-                            if (DEBUG_URI_PERMISSION) Slog.v(TAG, "Checking write perm "
+                            if (DEBUG_URI_PERMISSION) Log.d(TAG, "Checking write perm "
                                     + ppwperm + " for " + pp.getPath()
                                     + ": match=" + pp.match(path)
                                     + " check=" + pm.checkUidPermission(ppwperm, uid));
@@ -5793,7 +5804,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
 
         if (targetPkg != null) {
-            if (DEBUG_URI_PERMISSION) Slog.v(TAG,
+            if (DEBUG_URI_PERMISSION) Log.d(TAG,
                     "Checking grant " + targetPkg + " permission to " + uri);
         }
         
@@ -5801,7 +5812,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         // If this is not a content: uri, we can't do anything with it.
         if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
-            if (DEBUG_URI_PERMISSION) Slog.v(TAG, 
+            if (DEBUG_URI_PERMISSION) Log.d(TAG,
                     "Can't grant URI permission for non-content URI: " + uri);
             return -1;
         }
@@ -5818,7 +5829,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             try {
                 targetUid = pm.getPackageUid(targetPkg, UserHandle.getUserId(callingUid));
                 if (targetUid < 0) {
-                    if (DEBUG_URI_PERMISSION) Slog.v(TAG,
+                    if (DEBUG_URI_PERMISSION) Log.d(TAG,
                             "Can't grant URI permission no uid for: " + targetPkg);
                     return -1;
                 }
@@ -5831,7 +5842,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             // First...  does the target actually need this permission?
             if (checkHoldingPermissionsLocked(pm, pi, uri, targetUid, modeFlags)) {
                 // No need to grant the target this permission.
-                if (DEBUG_URI_PERMISSION) Slog.v(TAG,
+                if (DEBUG_URI_PERMISSION) Log.d(TAG,
                         "Target " + targetPkg + " already has full permission to " + uri);
                 return -1;
             }
@@ -5917,7 +5928,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         // to the uri, and the target doesn't.  Let's now give this to
         // the target.
 
-        if (DEBUG_URI_PERMISSION) Slog.v(TAG, 
+        if (DEBUG_URI_PERMISSION) Log.d(TAG,
                 "Granting " + targetPkg + "/" + targetUid + " permission to " + uri);
 
         final String authority = uri.getAuthority();
@@ -5963,7 +5974,7 @@ public final class ActivityManagerService extends ActivityManagerNative
      */
     NeededUriGrants checkGrantUriPermissionFromIntentLocked(int callingUid,
             String targetPkg, Intent intent, int mode, NeededUriGrants needed) {
-        if (DEBUG_URI_PERMISSION) Slog.v(TAG,
+        if (DEBUG_URI_PERMISSION) Log.d(TAG,
                 "Checking URI perm to data=" + (intent != null ? intent.getData() : null)
                 + " clip=" + (intent != null ? intent.getClipData() : null)
                 + " from " + intent + "; flags=0x"
@@ -6078,7 +6089,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             ArrayMap<Uri, UriPermission> perms
                     = mGrantedUriPermissions.get(perm.targetUid);
             if (perms != null) {
-                if (DEBUG_URI_PERMISSION) Slog.v(TAG, 
+                if (DEBUG_URI_PERMISSION) Log.d(TAG,
                         "Removing " + perm.targetUid + " permission to " + perm.uri);
                 perms.remove(perm.uri);
                 if (perms.size() == 0) {
@@ -6089,7 +6100,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     private void revokeUriPermissionLocked(int callingUid, Uri uri, int modeFlags) {
-        if (DEBUG_URI_PERMISSION) Slog.v(TAG, "Revoking all granted permissions to " + uri);
+        if (DEBUG_URI_PERMISSION) Log.d(TAG, "Revoking all granted permissions to " + uri);
 
         final IPackageManager pm = AppGlobals.getPackageManager();
         final String authority = uri.getAuthority();
@@ -6139,7 +6150,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                             continue toploop;
                         }
                     }
-                    if (DEBUG_URI_PERMISSION) Slog.v(TAG, 
+                    if (DEBUG_URI_PERMISSION) Log.d(TAG,
                             "Revoking " + perm.targetUid + " permission to " + perm.uri);
                     persistChanged |= perm.clearModes(modeFlags, true);
                     if (perm.modeFlags == 0) {
@@ -6302,7 +6313,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     private void writeGrantedUriPermissions() {
-        if (DEBUG_URI_PERMISSION) Slog.v(TAG, "writeGrantedUriPermissions()");
+        if (DEBUG_URI_PERMISSION) Log.d(TAG, "writeGrantedUriPermissions()");
 
         // Snapshot permissions so we can persist without lock
         ArrayList<UriPermission.Snapshot> persist = Lists.newArrayList();
@@ -6347,7 +6358,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     private void readGrantedUriPermissionsLocked() {
-        if (DEBUG_URI_PERMISSION) Slog.v(TAG, "readGrantedUriPermissions()");
+        if (DEBUG_URI_PERMISSION) Log.d(TAG, "readGrantedUriPermissions()");
 
         final long now = System.currentTimeMillis();
 
@@ -6477,7 +6488,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             final UriPermission perm = persisted.get(i);
 
             if (DEBUG_URI_PERMISSION) {
-                Slog.v(TAG, "Trimming grant created at " + perm.persistedCreateTime);
+                Log.d(TAG, "Trimming grant created at " + perm.persistedCreateTime);
             }
 
             perm.releasePersistableModes(~0);
@@ -6582,7 +6593,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         ActivityRecord topRecord = null;
 
         synchronized(this) {
-            if (localLOGV) Slog.v(
+            if (localLOGV) Log.d(
                 TAG, "getTasks: max=" + maxNum + ", flags=" + flags
                 + ", receiver=" + receiver);
 
@@ -6612,10 +6623,10 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
         }
 
-        if (localLOGV) Slog.v(TAG, "We have pending thumbnails: " + pending);
+        if (localLOGV) Log.d(TAG, "We have pending thumbnails: " + pending);
 
         if (topRecord != null) {
-            if (localLOGV) Slog.v(TAG, "Requesting top thumbnail");
+            if (localLOGV) Log.d(TAG, "Requesting top thumbnail");
             try {
                 IApplicationThread topThumbnail = topRecord.app.thread;
                 topThumbnail.requestThumbnail(topRecord.appToken);
@@ -6646,6 +6657,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     @Override
     public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,
             int flags, int userId) {
+        Log.d(TAG,"Ritter::AMS getRecentTasks()");
         userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,
                 false, true, "getRecentTasks", null);
 
@@ -6659,6 +6671,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             IPackageManager pm = AppGlobals.getPackageManager();
 
             final int N = mRecentTasks.size();
+            Log.d(TAG,"Ritter::AMS getRecentTasks: mRecentTasks.size():"+N);
             ArrayList<ActivityManager.RecentTaskInfo> res
                     = new ArrayList<ActivityManager.RecentTaskInfo>(
                             maxNum < N ? maxNum : N);
@@ -6774,7 +6787,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     private void killUnneededProcessLocked(ProcessRecord pr, String reason) {
         if (!pr.killedByAm) {
-            Slog.i(TAG, "Killing " + pr.toShortString() + " (adj " + pr.setAdj + "): " + reason);
+            Log.d(TAG, "Killing " + pr.toShortString() + " (adj " + pr.setAdj + "): " + reason);
             EventLog.writeEvent(EventLogTags.AM_KILL, pr.userId, pr.pid,
                     pr.processName, pr.setAdj, reason);
             pr.killedByAm = true;
@@ -6835,8 +6848,10 @@ public final class ActivityManagerService extends ActivityManagerNative
     @Override
     public boolean removeTask(int taskId, int flags) {
         synchronized (this) {
-            enforceCallingPermission(android.Manifest.permission.REMOVE_TASKS,
-                    "removeTask()");
+            //Ritter_multi old
+            /*enforceCallingPermission(android.Manifest.permission.REMOVE_TASKS,
+                    "removeTask()");*/
+
             long ident = Binder.clearCallingIdentity();
             try {
                 TaskRecord tr = recentTaskForIdLocked(taskId);
@@ -6869,10 +6884,19 @@ public final class ActivityManagerService extends ActivityManagerNative
      */
     @Override
     public void moveTaskToFront(int task, int flags, Bundle options) {
-        enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,
+        //Ritter_Multi
+        /*enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,
                 "moveTaskToFront()");
+*/
+        if(options==null){
+            //Ritter not check permisson
+        }else{
+            enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,
+                    "moveTaskToFront()");
+        }
+
 
-        if (DEBUG_STACK) Slog.d(TAG, "moveTaskToFront: moving task=" + task);
+        if (DEBUG_STACK) Log.d(TAG, "moveTaskToFront: moving task=" + task);
         synchronized(this) {
             if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),
                     Binder.getCallingUid(), "Task to front")) {
@@ -6881,6 +6905,11 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
             final long origId = Binder.clearCallingIdentity();
             try {
+                /**Ritter_multi
+                 * Before move task, set mMoveTaskBackTaskInvisible = false.
+                 * */
+                mStackSupervisor.mMoveTaskBackTaskInvisible = false;
+                //end
                 mStackSupervisor.findTaskToMoveToFrontLocked(task, flags, options);
             } finally {
                 Binder.restoreCallingIdentity(origId);
@@ -6897,7 +6926,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         synchronized(this) {
             TaskRecord tr = recentTaskForIdLocked(taskId);
             if (tr != null) {
-                if (DEBUG_STACK) Slog.d(TAG, "moveTaskToBack: moving task=" + tr);
+                if (DEBUG_STACK) Log.d(TAG, "moveTaskToBack: moving task=" + tr);
                 ActivityStack stack = tr.stack;
                 if (stack.mResumedActivity != null && stack.mResumedActivity.task == tr) {
                     if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),
@@ -6962,7 +6991,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     public int createStack(int taskId, int relativeStackBoxId, int position, float weight) {
         enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,
                 "createStack()");
-        if (DEBUG_STACK) Slog.d(TAG, "createStack: taskId=" + taskId + " relStackBoxId=" +
+        if (DEBUG_STACK) Log.d(TAG, "createStack: taskId=" + taskId + " relStackBoxId=" +
                 relativeStackBoxId + " position=" + position + " weight=" + weight);
         synchronized (this) {
             long ident = Binder.clearCallingIdentity();
@@ -6990,7 +7019,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         synchronized (this) {
             long ident = Binder.clearCallingIdentity();
             try {
-                if (DEBUG_STACK) Slog.d(TAG, "moveTaskToStack: moving task=" + taskId + " to stackId="
+                if (DEBUG_STACK) Log.d(TAG, "moveTaskToStack: moving task=" + taskId + " to stackId="
                         + stackId + " toTop=" + toTop);
                 mStackSupervisor.moveTaskToStack(taskId, stackId, toTop);
             } finally {
@@ -7194,7 +7223,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         } catch (RemoteException ex) {
         }
         if (DEBUG_MU)
-            Slog.v(TAG_MU, "generateApplicationProvidersLocked, app.info.uid = " + app.uid);
+            Log.d(TAG_MU, "generateApplicationProvidersLocked, app.info.uid = " + app.uid);
         int userId = app.userId;
         if (providers != null) {
             int N = providers.size();
@@ -7222,7 +7251,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     mProviderMap.putProviderByClass(comp, cpr);
                 }
                 if (DEBUG_MU)
-                    Slog.v(TAG_MU, "generateApplicationProvidersLocked, cpi.uid = " + cpr.uid);
+                    Log.d(TAG_MU, "generateApplicationProvidersLocked, cpi.uid = " + cpr.uid);
                 app.pubProviders.put(cpi.name, cpr);
                 app.addPackage(cpi.applicationInfo.packageName, mProcessStats);
                 ensurePackageDexOpt(cpi.applicationInfo.packageName);
@@ -7301,7 +7330,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             for (int i=0; i<r.conProviders.size(); i++) {
                 ContentProviderConnection conn = r.conProviders.get(i);
                 if (conn.provider == cpr) {
-                    if (DEBUG_PROVIDER) Slog.v(TAG,
+                    if (DEBUG_PROVIDER) Log.d(TAG,
                             "Adding provider requested by "
                             + r.processName + " from process "
                             + cpr.info.processName + ": " + cpr.name.flattenToShortString()
@@ -7336,7 +7365,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) {
         if (conn != null) {
             cpr = conn.provider;
-            if (DEBUG_PROVIDER) Slog.v(TAG,
+            if (DEBUG_PROVIDER) Log.d(TAG,
                     "Removing provider requested by "
                     + conn.client.processName + " from process "
                     + cpr.info.processName + ": " + cpr.name.flattenToShortString()
@@ -7416,13 +7445,13 @@ public final class ActivityManagerService extends ActivityManagerNative
                     if (false) {
                         if (cpr.name.flattenToShortString().equals(
                                 "com.android.providers.calendar/.CalendarProvider2")) {
-                            Slog.v(TAG, "****************** KILLING "
+                            Log.d(TAG, "****************** KILLING "
                                 + cpr.name.flattenToShortString());
                             Process.killProcess(cpr.proc.pid);
                         }
                     }
                     boolean success = updateOomAdjLocked(cpr.proc);
-                    if (DEBUG_PROVIDER) Slog.i(TAG, "Adjust success: " + success);
+                    if (DEBUG_PROVIDER) Log.d(TAG, "Adjust success: " + success);
                     // NOTE: there is still a race here where a signal could be
                     // pending on the process even though we managed to update its
                     // adj level.  Not sure what to do about this, but at least
@@ -7432,7 +7461,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                         // has been killed on us.  We need to wait for a new
                         // process to be started, and make sure its death
                         // doesn't kill our process.
-                        Slog.i(TAG,
+                        Log.d(TAG,
                                 "Existing provider " + cpr.name.flattenToShortString()
                                 + " is crashing; detaching " + r);
                         boolean lastRef = decProviderCountLocked(conn, cpr, token, stable);
@@ -7560,7 +7589,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                                 cpi.processName, cpr.appInfo.uid, false);
                         if (proc != null && proc.thread != null) {
                             if (DEBUG_PROVIDER) {
-                                Slog.d(TAG, "Installing in existing process " + proc);
+                                Log.d(TAG, "Installing in existing process " + proc);
                             }
                             proc.pubProviders.put(cpi.name, cpr);
                             try {
@@ -7617,7 +7646,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 }
                 try {
                     if (DEBUG_MU) {
-                        Slog.v(TAG_MU, "Waiting to start provider " + cpr + " launchingApp="
+                        Log.d(TAG_MU, "Waiting to start provider " + cpr + " launchingApp="
                                 + cpr.launchingApp);
                     }
                     if (conn != null) {
@@ -7699,7 +7728,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             ContentProviderRecord cpr = mProviderMap.getProviderByName(name, userId);
             if(cpr == null) {
                 //remove from mProvidersByClass
-                if(localLOGV) Slog.v(TAG, name+" content provider not found in providers list");
+                if(localLOGV) Log.d(TAG, name+" content provider not found in providers list");
                 return;
             }
 
@@ -7731,7 +7760,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         synchronized (this) {
             final ProcessRecord r = getRecordForAppLocked(caller);
             if (DEBUG_MU)
-                Slog.v(TAG_MU, "ProcessRecord uid = " + r.uid);
+                Log.d(TAG_MU, "ProcessRecord uid = " + r.uid);
             if (r == null) {
                 throw new SecurityException(
                         "Unable to find app for caller " + caller
@@ -7749,7 +7778,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 }
                 ContentProviderRecord dst = r.pubProviders.get(src.info.name);
                 if (DEBUG_MU)
-                    Slog.v(TAG_MU, "ContentProviderRecord uid = " + dst.uid);
+                    Log.d(TAG_MU, "ContentProviderRecord uid = " + dst.uid);
                 if (dst != null) {
                     ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name);
                     mProviderMap.putProviderByClass(comp, dst);
@@ -7871,7 +7900,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
             // As far as we're concerned, this is just like receiving a
             // death notification...  just a bit prematurely.
-            Slog.i(TAG, "Process " + proc.processName + " (pid " + proc.pid
+            Log.d(TAG, "Process " + proc.processName + " (pid " + proc.pid
                     + ") early provider death");
             final long ident = Binder.clearCallingIdentity();
             try {
@@ -8085,7 +8114,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             // We've got the fd now, so we're done with the provider.
             removeContentProviderExternalUnchecked(name, null, userId);
         } else {
-            Slog.d(TAG, "Failed to get provider for authority '" + name + "'");
+            Log.d(TAG, "Failed to get provider for authority '" + name + "'");
         }
         return pfd;
     }
@@ -8147,7 +8176,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
     
     public final void activitySlept(IBinder token) {
-        if (localLOGV) Slog.v(TAG, "Activity slept: token=" + token);
+        if (localLOGV) Log.d(TAG, "Activity slept: token=" + token);
 
         final long origId = Binder.clearCallingIdentity();
 
@@ -8162,7 +8191,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     void logLockScreen(String msg) {
-        if (DEBUG_LOCKSCREEN) Slog.d(TAG, Debug.getCallers(2) + ":" + msg +
+        if (DEBUG_LOCKSCREEN) Log.d(TAG, Debug.getCallers(2) + ":" + msg +
                 " mLockScreenShown=" + mLockScreenShown + " mWentToSleep=" +
                 mWentToSleep + " mSleeping=" + mSleeping + " mDismissKeyguardOnNextActivity=" +
                 mStackSupervisor.mDismissKeyguardOnNextActivity);
@@ -8553,6 +8582,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     @Override
     public boolean convertFromTranslucent(IBinder token) {
+        Log.d(TAG,"Ritter::AMS convertFromTranslucent()");
         final long origId = Binder.clearCallingIdentity();
         try {
             synchronized (this) {
@@ -8574,6 +8604,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     @Override
     public boolean convertToTranslucent(IBinder token) {
+        Log.d(TAG,"Ritter::AMS convertToTranslucent()");
         final long origId = Binder.clearCallingIdentity();
         try {
             synchronized (this) {
@@ -8606,7 +8637,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             // update associated state if we're frontmost
             if (r == mFocusedActivity) {
                 if (DEBUG_IMMERSIVE) {
-                    Slog.d(TAG, "Frontmost changed immersion: "+ r);
+                    Log.d(TAG, "Frontmost changed immersion: "+ r);
                 }
                 applyUpdateLockStateLocked(r);
             }
@@ -8801,7 +8832,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         synchronized (this) {
             Watchdog.getInstance().setAllowRestart(allowRestart);
-            Slog.i(TAG, "Hanging system process at request of pid " + Binder.getCallingPid());
+            Log.d(TAG, "Hanging system process at request of pid " + Binder.getCallingPid());
             synchronized (death) {
                 while (who.isBinderAlive()) {
                     try {
@@ -8873,7 +8904,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             TimeUtils.formatDuration(timeSinceLastIdle, sb);
             sb.append(" low RAM for ");
             TimeUtils.formatDuration(lowRamSinceLastIdle, sb);
-            Slog.i(TAG, sb.toString());
+            Log.d(TAG, sb.toString());
 
             // If at least 1/3 of our time since the last idle period has been spent
             // with RAM low, then we want to kill processes.
@@ -8949,7 +8980,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             // This happens before any activities are started, so we can
             // change mConfiguration in-place.
             updateConfigurationLocked(configuration, null, false, true);
-            if (DEBUG_CONFIGURATION) Slog.v(TAG, "Initial config: " + mConfiguration);
+            if (DEBUG_CONFIGURATION) Log.d(TAG, "Initial config: " + mConfiguration);
         }
     }
 
@@ -9010,7 +9041,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         FileOutputStream fos = null;
         DataOutputStream dos = null;
         try {
-            Slog.i(TAG, "Writing new set of last done pre-boot receivers...");
+            Log.d(TAG, "Writing new set of last done pre-boot receivers...");
             fos = new FileOutputStream(file);
             dos = new DataOutputStream(new BufferedOutputStream(fos, 2048));
             dos.writeInt(LAST_DONE_VERSION);
@@ -9039,6 +9070,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
     
     public void systemReady(final Runnable goingCallback) {
+        Log.d(TAG,"Ritter::AMS systemReady()");
         synchronized(this) {
             if (mSystemReady) {
                 if (goingCallback != null) goingCallback.run();
@@ -9109,7 +9141,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                                     }
                                 };
                             }
-                            Slog.i(TAG, "Sending system update to " + intent.getComponent()
+                            Log.d(TAG, "Sending system update to " + intent.getComponent()
                                     + " for user " + users[j]);
                             broadcastIntentLocked(null, null, intent, null, finisher,
                                     0, null, null, null, AppOpsManager.OP_NONE,
@@ -9151,7 +9183,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (procsToKill != null) {
                 for (int i=procsToKill.size()-1; i>=0; i--) {
                     ProcessRecord proc = procsToKill.get(i);
-                    Slog.i(TAG, "Removing system update proc: " + proc);
+                    Log.d(TAG, "Removing system update proc: " + proc);
                     removeProcessLocked(proc, true, false, "system update done");
                 }
             }
@@ -9162,7 +9194,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             mProcessesReady = true;
         }
         
-        Slog.i(TAG, "System now ready");
+        Log.d(TAG, "System now ready");
         EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,
             SystemClock.uptimeMillis());
 
@@ -9343,6 +9375,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     private boolean handleAppCrashLocked(ProcessRecord app) {
+        Log.d(TAG,"Ritter::AMS handleAppCrashLocked()");
         if (mHeadless) {
             Log.e(TAG, "handleAppCrashLocked: " + app.processName);
             return false;
@@ -10130,7 +10163,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     if (app.adjTarget instanceof ComponentName) {
                         currApp.importanceReasonComponent = (ComponentName)app.adjTarget;
                     }
-                    //Slog.v(TAG, "Proc " + app.processName + ": imp=" + currApp.importance
+                    //Log.d(TAG, "Proc " + app.processName + ": imp=" + currApp.importance
                     //        + " lru=" + currApp.lru);
                     if (runList == null) {
                         runList = new ArrayList<ActivityManager.RunningAppProcessInfo>();
@@ -12235,7 +12268,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         // If the app is undergoing backup, tell the backup manager about it
         if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
-            if (DEBUG_BACKUP || DEBUG_CLEANUP) Slog.d(TAG, "App "
+            if (DEBUG_BACKUP || DEBUG_CLEANUP) Log.d(TAG, "App "
                     + mBackupTarget.appInfo + " died during backup");
             try {
                 IBackupManager bm = IBackupManager.Stub.asInterface(
@@ -12262,7 +12295,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
 
         if (!app.persistent || app.isolated) {
-            if (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG,
+            if (DEBUG_PROCESSES || DEBUG_CLEANUP) Log.d(TAG,
                     "Removing non-persistent process during cleanup: " + app);
             mProcessNames.remove(app.processName, app.uid);
             mIsolatedProcesses.remove(app.uid);
@@ -12280,7 +12313,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 restart = true;
             }
         }
-        if ((DEBUG_PROCESSES || DEBUG_CLEANUP) && mProcessesOnHold.contains(app)) Slog.v(TAG,
+        if ((DEBUG_PROCESSES || DEBUG_CLEANUP) && mProcessesOnHold.contains(app)) Log.d(TAG,
                 "Clean-up removing on hold: " + app);
         mProcessesOnHold.remove(app);
 
@@ -12357,7 +12390,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
 
         if (DEBUG_SERVICE)
-            Slog.v(TAG, "startService: " + service + " type=" + resolvedType);
+            Log.d(TAG, "startService: " + service + " type=" + resolvedType);
         synchronized(this) {
             final int callingPid = Binder.getCallingPid();
             final int callingUid = Binder.getCallingUid();
@@ -12374,7 +12407,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             Intent service, String resolvedType, int userId) {
         synchronized(this) {
             if (DEBUG_SERVICE)
-                Slog.v(TAG, "startServiceInPackage: " + service + " type=" + resolvedType);
+                Log.d(TAG, "startServiceInPackage: " + service + " type=" + resolvedType);
             final long origId = Binder.clearCallingIdentity();
             ComponentName res = mServices.startServiceLocked(null, service,
                     resolvedType, -1, uid, userId);
@@ -12503,7 +12536,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             result = true;
         }
         if (DEBUG_MU) {
-            Slog.v(TAG, "isSingleton(" + componentProcessName + ", " + aInfo
+            Log.d(TAG, "isSingleton(" + componentProcessName + ", " + aInfo
                     + ", " + className + ", 0x" + Integer.toHexString(flags) + ") = " + result);
         }
         return result;
@@ -12572,7 +12605,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     // instantiated.  The backup agent will invoke backupAgentCreated() on the
     // activity manager to announce its creation.
     public boolean bindBackupAgent(ApplicationInfo app, int backupMode) {
-        if (DEBUG_BACKUP) Slog.v(TAG, "bindBackupAgent: app=" + app + " mode=" + backupMode);
+        if (DEBUG_BACKUP) Log.d(TAG, "bindBackupAgent: app=" + app + " mode=" + backupMode);
         enforceCallingPermission("android.permission.BACKUP", "bindBackupAgent");
 
         synchronized(this) {
@@ -12615,7 +12648,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             // If the process is already attached, schedule the creation of the backup agent now.
             // If it is not yet live, this will be done when it attaches to the framework.
             if (proc.thread != null) {
-                if (DEBUG_BACKUP) Slog.v(TAG, "Agent proc already running: " + proc);
+                if (DEBUG_BACKUP) Log.d(TAG, "Agent proc already running: " + proc);
                 try {
                     proc.thread.scheduleCreateBackupAgent(app,
                             compatibilityInfoForPackageLocked(app), backupMode);
@@ -12623,7 +12656,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     // Will time out on the backup manager side
                 }
             } else {
-                if (DEBUG_BACKUP) Slog.v(TAG, "Agent proc not running, waiting for attach");
+                if (DEBUG_BACKUP) Log.d(TAG, "Agent proc not running, waiting for attach");
             }
             // Invariants: at this point, the target app process exists and the application
             // is either already running or in the process of coming up.  mBackupTarget and
@@ -12636,7 +12669,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     @Override
     public void clearPendingBackup() {
-        if (DEBUG_BACKUP) Slog.v(TAG, "clearPendingBackup");
+        if (DEBUG_BACKUP) Log.d(TAG, "clearPendingBackup");
         enforceCallingPermission("android.permission.BACKUP", "clearPendingBackup");
 
         synchronized (this) {
@@ -12647,7 +12680,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     // A backup agent has just come up                    
     public void backupAgentCreated(String agentPackageName, IBinder agent) {
-        if (DEBUG_BACKUP) Slog.v(TAG, "backupAgentCreated: " + agentPackageName
+        if (DEBUG_BACKUP) Log.d(TAG, "backupAgentCreated: " + agentPackageName
                 + " = " + agent);
 
         synchronized(this) {
@@ -12674,7 +12707,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     // done with this agent
     public void unbindBackupAgent(ApplicationInfo appInfo) {
-        if (DEBUG_BACKUP) Slog.v(TAG, "unbindBackupAgent: " + appInfo);
+        if (DEBUG_BACKUP) Log.d(TAG, "unbindBackupAgent: " + appInfo);
         if (appInfo == null) {
             Slog.w(TAG, "unbind backup agent for null app");
             return;
@@ -12815,7 +12848,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             // the client.
             Intent sticky = allSticky != null ? (Intent)allSticky.get(0) : null;
 
-            if (DEBUG_BROADCAST) Slog.v(TAG, "Register receiver " + filter
+            if (DEBUG_BROADCAST) Log.d(TAG, "Register receiver " + filter
                     + ": " + sticky);
 
             if (receiver == null) {
@@ -12882,7 +12915,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     public void unregisterReceiver(IIntentReceiver receiver) {
-        if (DEBUG_BROADCAST) Slog.v(TAG, "Unregister receiver: " + receiver);
+        if (DEBUG_BROADCAST) Log.d(TAG, "Unregister receiver: " + receiver);
 
         final long origId = Binder.clearCallingIdentity();
         try {
@@ -13027,7 +13060,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         // By default broadcasts do not go to stopped apps.
         intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
 
-        if (DEBUG_BROADCAST_LIGHT) Slog.v(
+        if (DEBUG_BROADCAST_LIGHT) Log.d(
             TAG, (sticky ? "Broadcast sticky: ": "Broadcast: ") + intent
             + " ordered=" + ordered + " userid=" + userId);
         if ((resultTo != null) && !ordered) {
@@ -13292,7 +13325,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         final boolean replacePending =
                 (intent.getFlags()&Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
         
-        if (DEBUG_BROADCAST) Slog.v(TAG, "Enqueing broadcast: " + intent.getAction()
+        if (DEBUG_BROADCAST) Log.d(TAG, "Enqueing broadcast: " + intent.getAction()
                 + " replacePending=" + replacePending);
         
         int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
@@ -13305,7 +13338,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     callerPackage, callingPid, callingUid, resolvedType, requiredPermission,
                     appOp, registeredReceivers, resultTo, resultCode, resultData, map,
                     ordered, sticky, false, userId);
-            if (DEBUG_BROADCAST) Slog.v(
+            if (DEBUG_BROADCAST) Log.d(
                     TAG, "Enqueueing parallel broadcast " + r);
             final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);
             if (!replaced) {
@@ -13395,12 +13428,12 @@ public final class ActivityManagerService extends ActivityManagerNative
                     callerPackage, callingPid, callingUid, resolvedType,
                     requiredPermission, appOp, receivers, resultTo, resultCode,
                     resultData, map, ordered, sticky, false, userId);
-            if (DEBUG_BROADCAST) Slog.v(
+            if (DEBUG_BROADCAST) Log.d(
                     TAG, "Enqueueing ordered broadcast " + r
                     + ": prev had " + queue.mOrderedBroadcasts.size());
             if (DEBUG_BROADCAST) {
                 int seq = r.intent.getIntExtra("seq", -1);
-                Slog.i(TAG, "Enqueueing broadcast " + r.intent.getAction() + " seq=" + seq);
+                Log.d(TAG, "Enqueueing broadcast " + r.intent.getAction() + " seq=" + seq);
             }
             boolean replaced = replacePending && queue.replaceOrderedBroadcastLocked(r); 
             if (!replaced) {
@@ -13540,7 +13573,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     public void finishReceiver(IBinder who, int resultCode, String resultData,
             Bundle resultExtras, boolean resultAbort) {
-        if (DEBUG_BROADCAST) Slog.v(TAG, "Finish receiver: " + who);
+        if (DEBUG_BROADCAST) Log.d(TAG, "Finish receiver: " + who);
 
         // Refuse possible leaked file descriptors
         if (resultExtras != null && resultExtras.hasFileDescriptors()) {
@@ -13799,6 +13832,7 @@ public final class ActivityManagerService extends ActivityManagerNative
      */
     boolean updateConfigurationLocked(Configuration values,
             ActivityRecord starting, boolean persistent, boolean initLocale) {
+        Log.d(TAG,"Ritter::AMS updateConfigurationLocked()");
         // do nothing if we are headless
         if (mHeadless) return true;
 
@@ -13809,7 +13843,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             changes = newConfig.updateFrom(values);
             if (changes != 0) {
                 if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
-                    Slog.i(TAG, "Updating configuration to: " + values);
+                    Log.d(TAG, "Updating configuration to: " + values);
                 }
                 
                 EventLog.writeEvent(EventLogTags.CONFIGURATION_CHANGED, changes);
@@ -13826,7 +13860,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 }
                 newConfig.seq = mConfigurationSeq;
                 mConfiguration = newConfig;
-                Slog.i(TAG, "Config changes=" + Integer.toHexString(changes) + " " + newConfig);
+                Log.d(TAG, "Config changes=" + Integer.toHexString(changes) + " " + newConfig);
 
                 final Configuration configCopy = new Configuration(mConfiguration);
                 
@@ -13858,7 +13892,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     ProcessRecord app = mLruProcesses.get(i);
                     try {
                         if (app.thread != null) {
-                            if (DEBUG_CONFIGURATION) Slog.v(TAG, "Sending to proc "
+                            if (DEBUG_CONFIGURATION) Log.d(TAG, "Sending to proc "
                                     + app.processName + " new config " + mConfiguration);
                             app.thread.scheduleConfigurationChanged(configCopy);
                         }
@@ -14100,7 +14134,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
             app.adjType = "exec-service";
             procState = ActivityManager.PROCESS_STATE_SERVICE;
-            //Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);
+            //Log.d(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);
         } else {
             // As far as we know the process is empty.  We may change our mind later.
             schedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
@@ -14243,7 +14277,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
         }
 
-        if (false) Slog.i(TAG, "OOM " + app + ": initial adj=" + adj
+        if (false) Log.d(TAG, "OOM " + app + ": initial adj=" + adj
                 + " reason=" + app.adjType);
 
         // By default, we use the computed adjustment.  It may be changed if
@@ -14257,7 +14291,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         if (mBackupTarget != null && app == mBackupTarget.app) {
             // If possible we want to avoid killing apps while they're being backed up
             if (adj > ProcessList.BACKUP_APP_ADJ) {
-                if (DEBUG_BACKUP) Slog.v(TAG, "oom BACKUP_APP_ADJ for " + app);
+                if (DEBUG_BACKUP) Log.d(TAG, "oom BACKUP_APP_ADJ for " + app);
                 adj = ProcessList.BACKUP_APP_ADJ;
                 if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                     procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
@@ -14613,7 +14647,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (doingAll) {
                 app.serviceb = mNewNumAServiceProcs > (mNumServiceProcs/3);
                 mNewNumServiceProcs++;
-                //Slog.i(TAG, "ADJ " + app + " serviceb=" + app.serviceb);
+                //Log.d(TAG, "ADJ " + app + " serviceb=" + app.serviceb);
                 if (!app.serviceb) {
                     // This service isn't far enough down on the LRU list to
                     // normally be a B service, but if we are low on RAM and it
@@ -14623,10 +14657,10 @@ public final class ActivityManagerService extends ActivityManagerNative
                             && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
                         app.serviceHighRam = true;
                         app.serviceb = true;
-                        //Slog.i(TAG, "ADJ " + app + " high ram!");
+                        //Log.d(TAG, "ADJ " + app + " high ram!");
                     } else {
                         mNewNumAServiceProcs++;
-                        //Slog.i(TAG, "ADJ " + app + " not high ram!");
+                        //Log.d(TAG, "ADJ " + app + " not high ram!");
                     }
                 } else {
                     app.serviceHighRam = false;
@@ -14639,7 +14673,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         app.curRawAdj = adj;
         
-        //Slog.i(TAG, "OOM ADJ " + app + ": pid=" + app.pid +
+        //Log.d(TAG, "OOM ADJ " + app + ": pid=" + app.pid +
         //      " adj=" + adj + " curAdj=" + app.curAdj + " maxAdj=" + app.maxAdj);
         if (adj > app.maxAdj) {
             adj = app.maxAdj;
@@ -14695,7 +14729,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
         }
         if (changes != 0) {
-            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG, "Changes in " + app + ": " + changes);
+            if (DEBUG_PROCESS_OBSERVERS) Log.d(TAG, "Changes in " + app + ": " + changes);
             app.memImportance = importance;
             app.foregroundActivities = foregroundActivities;
             int i = mPendingProcessChanges.size()-1;
@@ -14703,7 +14737,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             while (i >= 0) {
                 item = mPendingProcessChanges.get(i);
                 if (item.pid == app.pid) {
-                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG, "Re-using existing item: " + item);
+                    if (DEBUG_PROCESS_OBSERVERS) Log.d(TAG, "Re-using existing item: " + item);
                     break;
                 }
                 i--;
@@ -14713,16 +14747,16 @@ public final class ActivityManagerService extends ActivityManagerNative
                 final int NA = mAvailProcessChanges.size();
                 if (NA > 0) {
                     item = mAvailProcessChanges.remove(NA-1);
-                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG, "Retreiving available item: " + item);
+                    if (DEBUG_PROCESS_OBSERVERS) Log.d(TAG, "Retreiving available item: " + item);
                 } else {
                     item = new ProcessChangeItem();
-                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG, "Allocating new item: " + item);
+                    if (DEBUG_PROCESS_OBSERVERS) Log.d(TAG, "Allocating new item: " + item);
                 }
                 item.changes = 0;
                 item.pid = app.pid;
                 item.uid = app.info.uid;
                 if (mPendingProcessChanges.size() == 0) {
-                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG,
+                    if (DEBUG_PROCESS_OBSERVERS) Log.d(TAG,
                             "*** Enqueueing dispatch processes changed!");
                     mHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
                 }
@@ -14731,7 +14765,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             item.changes |= changes;
             item.importance = importance;
             item.foregroundActivities = foregroundActivities;
-            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG, "Item "
+            if (DEBUG_PROCESS_OBSERVERS) Log.d(TAG, "Item "
                     + Integer.toHexString(System.identityHashCode(item))
                     + " " + app.toShortString() + ": changes=" + item.changes
                     + " importance=" + item.importance
@@ -14753,7 +14787,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         if (mPendingPssProcesses.size() == 0) {
             mBgHandler.sendEmptyMessage(COLLECT_PSS_BG_MSG);
         }
-        if (DEBUG_PSS) Slog.d(TAG, "Requesting PSS of: " + proc);
+        if (DEBUG_PSS) Log.d(TAG, "Requesting PSS of: " + proc);
         proc.pssProcState = procState;
         mPendingPssProcesses.add(proc);
     }
@@ -14768,7 +14802,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 return;
             }
         }
-        if (DEBUG_PSS) Slog.d(TAG, "Requesting PSS of all procs!  memLowered=" + memLowered);
+        if (DEBUG_PSS) Log.d(TAG, "Requesting PSS of all procs!  memLowered=" + memLowered);
         mLastFullPssTime = now;
         mPendingPssProcesses.ensureCapacity(mLruProcesses.size());
         mPendingPssProcesses.clear();
@@ -14968,7 +15002,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     sb.append(" (");
                     sb.append((wtimeUsed*100)/realtimeSince);
                     sb.append("%)");
-                    Slog.i(TAG, sb.toString());
+                    Log.d(TAG, sb.toString());
                     sb.setLength(0);
                     sb.append("CPU for ");
                     app.toShortString(sb);
@@ -14979,7 +15013,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     sb.append(" (");
                     sb.append((cputimeUsed*100)/uptimeSince);
                     sb.append("%)");
-                    Slog.i(TAG, sb.toString());
+                    Log.d(TAG, sb.toString());
                 }
                 // If a process has held a wake lock for more
                 // than 50% of the time during this period,
@@ -15032,7 +15066,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         if (app.curAdj != app.setAdj) {
             if (Process.setOomAdj(app.pid, app.curAdj)) {
-                if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(
+                if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Log.d(
                     TAG, "Set " + app.pid + " " + app.processName +
                     " adj " + app.curAdj + ": " + app.adjType);
                 app.setAdj = app.curAdj;
@@ -15043,7 +15077,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
         if (app.setSchedGroup != app.curSchedGroup) {
             app.setSchedGroup = app.curSchedGroup;
-            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,
+            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Log.d(TAG,
                     "Setting process group of " + app.processName
                     + " to " + app.curSchedGroup);
             if (app.waitingToKill != null &&
@@ -15080,7 +15114,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 try {
                     if (false) {
                         //RuntimeException h = new RuntimeException("here");
-                        Slog.i(TAG, "Sending new process state " + app.repProcState
+                        Log.d(TAG, "Sending new process state " + app.repProcState
                                 + " to " + app /*, h*/);
                     }
                     app.thread.setProcessState(app.repProcState);
@@ -15093,7 +15127,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             app.lastStateTime = now;
             app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true,
                     mSleeping, now);
-            if (DEBUG_PSS) Slog.d(TAG, "Process state change from "
+            if (DEBUG_PSS) Log.d(TAG, "Process state change from "
                     + ProcessList.makeProcStateString(app.setProcState) + " to "
                     + ProcessList.makeProcStateString(app.curProcState) + " next pss in "
                     + (app.nextPssTime-now) + ": " + app);
@@ -15104,11 +15138,11 @@ public final class ActivityManagerService extends ActivityManagerNative
                 app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, false,
                         mSleeping, now);
             } else if (false && DEBUG_PSS) {
-                Slog.d(TAG, "Not requesting PSS of " + app + ": next=" + (app.nextPssTime-now));
+                Log.d(TAG, "Not requesting PSS of " + app + ": next=" + (app.nextPssTime-now));
             }
         }
         if (app.setProcState != app.curProcState) {
-            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,
+            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Log.d(TAG,
                     "Proc state change of " + app.processName
                     + " to " + app.curProcState);
             app.setProcState = app.curProcState;
@@ -15185,7 +15219,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         if (false) {
             RuntimeException e = new RuntimeException();
             e.fillInStackTrace();
-            Slog.i(TAG, "updateOomAdj: top=" + TOP_ACT, e);
+            Log.d(TAG, "updateOomAdj: top=" + TOP_ACT, e);
         }
 
         mAdjSeq++;
@@ -15380,13 +15414,13 @@ public final class ActivityManagerService extends ActivityManagerNative
         // We always allow the memory level to go up (better).  We only allow it to go
         // down if we are in a state where that is allowed, *and* the total number of processes
         // has gone down since last time.
-        if (DEBUG_OOM_ADJ) Slog.d(TAG, "oom: memFactor=" + memFactor + " last=" + mLastMemoryLevel
+        if (DEBUG_OOM_ADJ) Log.d(TAG, "oom: memFactor=" + memFactor + " last=" + mLastMemoryLevel
                 + " allowLow=" + mAllowLowerMemLevel + " numProcs=" + mLruProcesses.size()
                 + " last=" + mLastNumProcesses);
         if (memFactor > mLastMemoryLevel) {
             if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {
                 memFactor = mLastMemoryLevel;
-                if (DEBUG_OOM_ADJ) Slog.d(TAG, "Keeping last mem factor!");
+                if (DEBUG_OOM_ADJ) Log.d(TAG, "Keeping last mem factor!");
             }
         }
         mLastMemoryLevel = memFactor;
@@ -15426,7 +15460,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                         && !app.killedByAm) {
                     if (app.trimMemoryLevel < curLevel && app.thread != null) {
                         try {
-                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,
+                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Log.d(TAG,
                                     "Trimming memory of " + app.processName
                                     + " to " + curLevel);
                             app.thread.scheduleTrimMemory(curLevel);
@@ -15463,7 +15497,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND
                             && app.thread != null) {
                         try {
-                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,
+                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Log.d(TAG,
                                     "Trimming memory of heavy-weight " + app.processName
                                     + " to " + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
                             app.thread.scheduleTrimMemory(
@@ -15481,7 +15515,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                         final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
                         if (app.trimMemoryLevel < level && app.thread != null) {
                             try {
-                                if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,
+                                if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Log.d(TAG,
                                         "Trimming memory of bg-ui " + app.processName
                                         + " to " + level);
                                 app.thread.scheduleTrimMemory(level);
@@ -15492,7 +15526,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     }
                     if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
                         try {
-                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,
+                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Log.d(TAG,
                                     "Trimming memory of fg " + app.processName
                                     + " to " + fgTrimLevel);
                             app.thread.scheduleTrimMemory(fgTrimLevel);
@@ -15518,7 +15552,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
                             && app.thread != null) {
                         try {
-                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,
+                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Log.d(TAG,
                                     "Trimming memory of ui hidden " + app.processName
                                     + " to " + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
                             app.thread.scheduleTrimMemory(
@@ -15553,7 +15587,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
 
         if (DEBUG_OOM_ADJ) {
-            Slog.d(TAG, "Did OOM ADJ in " + (SystemClock.uptimeMillis()-now) + "ms");
+            Log.d(TAG, "Did OOM ADJ in " + (SystemClock.uptimeMillis()-now) + "ms");
         }
     }
 
@@ -15567,7 +15601,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                 final ProcessRecord app = mRemovedProcesses.get(i);
                 if (app.activities.size() == 0
                         && app.curReceiver == null && app.services.size() == 0) {
-                    Slog.i(
+                    Log.d(
                         TAG, "Exiting empty application process "
                         + app.processName + " ("
                         + (app.thread != null ? app.thread.asBinder() : null)
@@ -15816,6 +15850,7 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     @Override
     public boolean switchUser(final int userId) {
+        Log.d(TAG,"Ritter::AMS switchUser()");
         if (checkCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)
                 != PackageManager.PERMISSION_GRANTED) {
             String msg = "Permission Denial: switchUser() from pid="
@@ -16412,4 +16447,18 @@ public final class ActivityManagerService extends ActivityManagerNative
         info.applicationInfo = getAppInfoForUser(info.applicationInfo, userId);
         return info;
     }
+
+    //Ritter_Multi
+    @Override
+    public void moveHomeToTop() throws RemoteException {
+        Log.d(TAG,"Ritter::AMS moveHomeToTop()");
+        mStackSupervisor.moveHomeToTop();
+    }
+
+/*    //Ritter_Multi
+    @Override
+    public void moveTaskToTop_AM(int taskID) throws RemoteException {
+        Log.d(TAG,"Ritter::AMS moveTaskToTop_AM() taskID:"+taskID);
+        moveTaskToFront(taskID,0,null);
+    }*/
 }
diff --git a/frameworks/base/services/java/com/android/server/am/ActivityStack.java b/frameworks/base/services/java/com/android/server/am/ActivityStack.java
index 0397fd5..af48e65 100644
--- a/frameworks/base/services/java/com/android/server/am/ActivityStack.java
+++ b/frameworks/base/services/java/com/android/server/am/ActivityStack.java
@@ -52,6 +52,7 @@ import android.app.AppGlobals;
 import android.app.IActivityController;
 import android.app.IThumbnailReceiver;
 import android.app.ResultInfo;
+import android.app.WindowAppsManager;
 import android.app.ActivityManager.RunningTaskInfo;
 import android.content.ComponentName;
 import android.content.Context;
@@ -73,6 +74,7 @@ import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.UserHandle;
 import android.util.EventLog;
+import android.util.Log;
 import android.util.Slog;
 import android.view.Display;
 
@@ -80,6 +82,7 @@ import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 
@@ -255,7 +258,7 @@ final class ActivityStack {
 
     final class ActivityStackHandler extends Handler {
         //public Handler() {
-        //    if (localLOGV) Slog.v(TAG, "Handler started!");
+        //    if (localLOGV) Log.d(TAG, "Handler started!");
         //}
         ActivityStackHandler(Looper looper) {
             super(looper);
@@ -343,6 +346,7 @@ final class ActivityStack {
     }
 
     final ActivityRecord topRunningActivityLocked(ActivityRecord notTop) {
+        Log.d(TAG,"Ritter::AS BACK_KEY topRunningActivityLocked()");
         for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
             ActivityRecord r = mTaskHistory.get(taskNdx).topRunningActivityLocked(notTop);
             if (r != null) {
@@ -478,45 +482,45 @@ final class ActivityStack {
         }
         final int userId = UserHandle.getUserId(info.applicationInfo.uid);
 
-        if (DEBUG_TASKS) Slog.d(TAG, "Looking for task of " + target + " in " + this);
+        if (DEBUG_TASKS) Log.d(TAG, "Looking for task of " + target + " in " + this);
         for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
             final TaskRecord task = mTaskHistory.get(taskNdx);
             if (task.userId != userId) {
                 // Looking for a different task.
-                if (DEBUG_TASKS) Slog.d(TAG, "Skipping " + task + ": different user");
+                if (DEBUG_TASKS) Log.d(TAG, "Skipping " + task + ": different user");
                 continue;
             }
             final ActivityRecord r = task.getTopActivity();
             if (r == null || r.finishing || r.userId != userId ||
                     r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
-                if (DEBUG_TASKS) Slog.d(TAG, "Skipping " + task + ": mismatch root " + r);
+                if (DEBUG_TASKS) Log.d(TAG, "Skipping " + task + ": mismatch root " + r);
                 continue;
             }
 
-            if (DEBUG_TASKS) Slog.d(TAG, "Comparing existing cls="
+            if (DEBUG_TASKS) Log.d(TAG, "Comparing existing cls="
                     + r.task.intent.getComponent().flattenToShortString()
                     + "/aff=" + r.task.affinity + " to new cls="
                     + intent.getComponent().flattenToShortString() + "/aff=" + info.taskAffinity);
             if (task.affinity != null) {
                 if (task.affinity.equals(info.taskAffinity)) {
-                    if (DEBUG_TASKS) Slog.d(TAG, "Found matching affinity!");
+                    if (DEBUG_TASKS) Log.d(TAG, "Found matching affinity!");
                     return r;
                 }
             } else if (task.intent != null && task.intent.getComponent().equals(cls)) {
-                if (DEBUG_TASKS) Slog.d(TAG, "Found matching class!");
+                if (DEBUG_TASKS) Log.d(TAG, "Found matching class!");
                 //dump();
-                if (DEBUG_TASKS) Slog.d(TAG, "For Intent " + intent + " bringing to top: "
+                if (DEBUG_TASKS) Log.d(TAG, "For Intent " + intent + " bringing to top: "
                         + r.intent);
                 return r;
             } else if (task.affinityIntent != null
                     && task.affinityIntent.getComponent().equals(cls)) {
-                if (DEBUG_TASKS) Slog.d(TAG, "Found matching class!");
+                if (DEBUG_TASKS) Log.d(TAG, "Found matching class!");
                 //dump();
-                if (DEBUG_TASKS) Slog.d(TAG, "For Intent " + intent + " bringing to top: "
+                if (DEBUG_TASKS) Log.d(TAG, "For Intent " + intent + " bringing to top: "
                         + r.intent);
                 return r;
             } else if (DEBUG_TASKS) {
-                Slog.d(TAG, "Not a match: " + task);
+                Log.d(TAG, "Not a match: " + task);
             }
         }
 
@@ -544,9 +548,9 @@ final class ActivityStack {
             for (int activityNdx = activities.size() - 1; activityNdx >= 0; --activityNdx) {
                 ActivityRecord r = activities.get(activityNdx);
                 if (!r.finishing && r.intent.getComponent().equals(cls) && r.userId == userId) {
-                    //Slog.i(TAG, "Found matching class!");
+                    //Log.d(TAG, "Found matching class!");
                     //dump();
-                    //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
+                    //Log.d(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
                     return r;
                 }
             }
@@ -569,7 +573,7 @@ final class ActivityStack {
         for (int i = 0; i < index; ++i) {
             TaskRecord task = mTaskHistory.get(i);
             if (task.userId == userId) {
-                if (DEBUG_TASKS) Slog.d(TAG, "switchUserLocked: stack=" + getStackId() +
+                if (DEBUG_TASKS) Log.d(TAG, "switchUserLocked: stack=" + getStackId() +
                         " moving " + task + " to top");
                 mTaskHistory.remove(i);
                 mTaskHistory.add(task);
@@ -583,7 +587,7 @@ final class ActivityStack {
 
     void minimalResumeActivityLocked(ActivityRecord r) {
         r.state = ActivityState.RESUMED;
-        if (DEBUG_STATES) Slog.v(TAG, "Moving to RESUMED: " + r
+        if (DEBUG_STATES) Log.d(TAG, "Moving to RESUMED: " + r
                 + " (starting new instance)");
         r.stopped = false;
         mResumedActivity = r;
@@ -592,7 +596,7 @@ final class ActivityStack {
         completeResumeLocked(r);
         mStackSupervisor.checkReadyForSleepLocked();
         setLaunchTime(r);
-        if (DEBUG_SAVED_STATE) Slog.i(TAG, "Launch completed; removing icicle of " + r.icicle);
+        if (DEBUG_SAVED_STATE) Log.d(TAG, "Launch completed; removing icicle of " + r.icicle);
     }
 
     private void startLaunchTraces() {
@@ -649,14 +653,14 @@ final class ActivityStack {
     boolean checkReadyForSleepLocked() {
         if (mResumedActivity != null) {
             // Still have something resumed; can't sleep until it is paused.
-            if (DEBUG_PAUSE) Slog.v(TAG, "Sleep needs to pause " + mResumedActivity);
-            if (DEBUG_USER_LEAVING) Slog.v(TAG, "Sleep => pause with userLeaving=false");
+            if (DEBUG_PAUSE) Log.d(TAG, "Sleep needs to pause " + mResumedActivity);
+            if (DEBUG_USER_LEAVING) Log.d(TAG, "Sleep => pause with userLeaving=false");
             startPausingLocked(false, true);
             return true;
         }
         if (mPausingActivity != null) {
             // Still waiting for something to pause; can't sleep yet.
-            if (DEBUG_PAUSE) Slog.v(TAG, "Sleep still waiting to pause " + mPausingActivity);
+            if (DEBUG_PAUSE) Log.d(TAG, "Sleep still waiting to pause " + mPausingActivity);
             return true;
         }
 
@@ -664,6 +668,7 @@ final class ActivityStack {
     }
 
     void goToSleep() {
+        Log.d(TAG,"Ritter::AS goToSleep()");
         ensureActivitiesVisibleLocked(null, 0);
 
         // Make sure any stopped but visible activities are now sleeping.
@@ -719,6 +724,7 @@ final class ActivityStack {
     }
 
     final void startPausingLocked(boolean userLeaving, boolean uiSleeping) {
+        Log.d(TAG,"Ritter::AS startPausingLocked()");
         if (mPausingActivity != null) {
             Slog.e(TAG, "Trying to pause when pause is already pending for "
                   + mPausingActivity, new RuntimeException("here").fillInStackTrace());
@@ -730,8 +736,8 @@ final class ActivityStack {
             mStackSupervisor.resumeTopActivitiesLocked();
             return;
         }
-        if (DEBUG_STATES) Slog.v(TAG, "Moving to PAUSING: " + prev);
-        else if (DEBUG_PAUSE) Slog.v(TAG, "Start pausing: " + prev);
+        if (true||DEBUG_STATES) Log.d(TAG, "Moving to PAUSING: " + prev);
+        else if (true||DEBUG_PAUSE) Log.d(TAG, "Start pausing: " + prev);
         mResumedActivity = null;
         mPausingActivity = prev;
         mLastPausedActivity = prev;
@@ -746,14 +752,42 @@ final class ActivityStack {
         mService.updateCpuStats();
 
         if (prev.app != null && prev.app.thread != null) {
-            if (DEBUG_PAUSE) Slog.v(TAG, "Enqueueing pending pause: " + prev);
+            if (DEBUG_PAUSE) Log.d(TAG, "Enqueueing pending pause: " + prev);
             try {
                 EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,
                         prev.userId, System.identityHashCode(prev),
                         prev.shortComponentName);
                 mService.updateUsageStats(prev, false);
-                prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,
-                        userLeaving, prev.configChangeFlags);
+                //Ritter_Multi old
+//                prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,
+//                        userLeaving, prev.configChangeFlags);
+
+                // Ritter_Multi new
+                // Get window apps from service
+                String APPs = "";
+                WindowAppsManager mWindowAppsManager = (WindowAppsManager) mContext
+                        .getSystemService("window_apps");
+                try {
+                    APPs = mWindowAppsManager.getWindowApps();
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+                ArrayList<String> pkgList = new ArrayList<String>(
+                        Arrays.asList(APPs.split("#")));
+//                if (prev.packageName.equals("com.example.hello")
+//                        || prev.packageName.equals("com.example.activity")
+//                        || prev.packageName.equals("com.android.launcher2")) {
+                if ((!prev.packageName.isEmpty() && pkgList.contains(prev.packageName))
+                      || prev.packageName.equals("com.android.launcher2")) {
+                    completePauseLocked();
+                } else {
+                    prev.app.thread
+                            .schedulePauseActivity(prev.appToken,
+                                    prev.finishing, userLeaving,
+                                    prev.configChangeFlags);
+                }
+                // end
+
             } catch (Exception e) {
                 // Ignore exception, if process died other code will cleanup.
                 Slog.w(TAG, "Exception thrown during pause", e);
@@ -781,7 +815,7 @@ final class ActivityStack {
             if (!uiSleeping) {
                 prev.pauseKeyDispatchingLocked();
             } else {
-                if (DEBUG_PAUSE) Slog.v(TAG, "Key dispatch not paused for screen off");
+                if (DEBUG_PAUSE) Log.d(TAG, "Key dispatch not paused for screen off");
             }
 
             // Schedule a pause timeout in case the app doesn't respond.
@@ -791,24 +825,25 @@ final class ActivityStack {
             msg.obj = prev;
             prev.pauseTime = SystemClock.uptimeMillis();
             mHandler.sendMessageDelayed(msg, PAUSE_TIMEOUT);
-            if (DEBUG_PAUSE) Slog.v(TAG, "Waiting for pause to complete...");
+            if (DEBUG_PAUSE) Log.d(TAG, "Waiting for pause to complete...");
         } else {
             // This activity failed to schedule the
             // pause, so just treat it as being paused now.
-            if (DEBUG_PAUSE) Slog.v(TAG, "Activity not running, resuming next.");
+            if (DEBUG_PAUSE) Log.d(TAG, "Activity not running, resuming next.");
             mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
         }
     }
 
     final void activityPausedLocked(IBinder token, boolean timeout) {
-        if (DEBUG_PAUSE) Slog.v(
+        Log.d(TAG,"Ritter::AS activityPausedLocked()");
+        if (DEBUG_PAUSE) Log.d(
             TAG, "Activity paused: token=" + token + ", timeout=" + timeout);
 
         final ActivityRecord r = isInStackLocked(token);
         if (r != null) {
             mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);
             if (mPausingActivity == r) {
-                if (DEBUG_STATES) Slog.v(TAG, "Moving to PAUSED: " + r
+                if (DEBUG_STATES) Log.d(TAG, "Moving to PAUSED: " + r
                         + (timeout ? " (due to timeout)" : " (pause complete)"));
                 r.state = ActivityState.PAUSED;
                 completePauseLocked();
@@ -823,12 +858,13 @@ final class ActivityStack {
 
     final void activityStoppedLocked(ActivityRecord r, Bundle icicle, Bitmap thumbnail,
             CharSequence description) {
+        Log.d(TAG,"Ritter::AMS activityStoppedLocked()");
         if (r.state != ActivityState.STOPPING) {
-            Slog.i(TAG, "Activity reported stop, but no longer stopping: " + r);
+            Log.d(TAG, "Activity reported stop, but no longer stopping: " + r);
             mHandler.removeMessages(STOP_TIMEOUT_MSG, r);
             return;
         }
-        if (DEBUG_SAVED_STATE) Slog.i(TAG, "Saving icicle of " + r + ": " + icicle);
+        if (DEBUG_SAVED_STATE) Log.d(TAG, "Saving icicle of " + r + ": " + icicle);
         if (icicle != null) {
             // If icicle is null, this is happening due to a timeout, so we
             // haven't really saved the state.
@@ -838,7 +874,7 @@ final class ActivityStack {
             r.updateThumbnail(thumbnail, description);
         }
         if (!r.stopped) {
-            if (DEBUG_STATES) Slog.v(TAG, "Moving to STOPPED: " + r + " (stop complete)");
+            if (DEBUG_STATES) Log.d(TAG, "Moving to STOPPED: " + r + " (stop complete)");
             mHandler.removeMessages(STOP_TIMEOUT_MSG, r);
             r.stopped = true;
             r.state = ActivityState.STOPPED;
@@ -856,19 +892,20 @@ final class ActivityStack {
     }
 
     private void completePauseLocked() {
+        Log.d(TAG,"Ritter::AS completePauseLocked()");
         ActivityRecord prev = mPausingActivity;
-        if (DEBUG_PAUSE) Slog.v(TAG, "Complete pause: " + prev);
+        if (DEBUG_PAUSE) Log.d(TAG, "Complete pause: " + prev);
 
         if (prev != null) {
             if (prev.finishing) {
-                if (DEBUG_PAUSE) Slog.v(TAG, "Executing finish of activity: " + prev);
+                if (DEBUG_PAUSE) Log.d(TAG, "Executing finish of activity: " + prev);
                 prev = finishCurrentActivityLocked(prev, FINISH_AFTER_VISIBLE, false);
             } else if (prev.app != null) {
-                if (DEBUG_PAUSE) Slog.v(TAG, "Enqueueing pending stop: " + prev);
+                if (DEBUG_PAUSE) Log.d(TAG, "Enqueueing pending stop: " + prev);
                 if (prev.waitingVisible) {
                     prev.waitingVisible = false;
                     mStackSupervisor.mWaitingVisibleActivities.remove(prev);
-                    if (DEBUG_SWITCH || DEBUG_PAUSE) Slog.v(
+                    if (DEBUG_SWITCH || DEBUG_PAUSE) Log.d(
                             TAG, "Complete pause, no longer waiting: " + prev);
                 }
                 if (prev.configDestroy) {
@@ -877,7 +914,7 @@ final class ActivityStack {
                     // To juggle the fact that we are also starting a new
                     // instance right now, we need to first completely stop
                     // the current instance before starting the new one.
-                    if (DEBUG_PAUSE) Slog.v(TAG, "Destroying after pause: " + prev);
+                    if (DEBUG_PAUSE) Log.d(TAG, "Destroying after pause: " + prev);
                     destroyActivityLocked(prev, true, false, "pause-config");
                 } else {
                     mStackSupervisor.mStoppingActivities.add(prev);
@@ -887,20 +924,21 @@ final class ActivityStack {
                         // then give up on things going idle and start clearing
                         // them out. Or if r is the last of activity of the last task the stack
                         // will be empty and must be cleared immediately.
-                        if (DEBUG_PAUSE) Slog.v(TAG, "To many pending stops, forcing idle");
+                        if (DEBUG_PAUSE) Log.d(TAG, "To many pending stops, forcing idle");
                         mStackSupervisor.scheduleIdleLocked();
                     } else {
                         mStackSupervisor.checkReadyForSleepLocked();
                     }
                 }
             } else {
-                if (DEBUG_PAUSE) Slog.v(TAG, "App died during pause, not stopping: " + prev);
+                if (DEBUG_PAUSE) Log.d(TAG, "App died during pause, not stopping: " + prev);
                 prev = null;
             }
             mPausingActivity = null;
         }
 
         final ActivityStack topStack = mStackSupervisor.getFocusedStack();
+        Log.d(TAG,"Ritter::AS completePauseLocked: topStack:"+topStack.getStackId()+" isHomeStack:"+topStack.isHomeStack()+",numActivities:"+topStack.numActivities());
         if (!mService.isSleepingOrShuttingDown()) {
             mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null);
         } else {
@@ -948,6 +986,7 @@ final class ActivityStack {
      * this function updates the rest of our state to match that fact.
      */
     private void completeResumeLocked(ActivityRecord next) {
+        Log.d(TAG,"Ritter::AS completeResumeLocked()");
         next.idle = false;
         next.results = null;
         next.newIntents = null;
@@ -996,10 +1035,21 @@ final class ActivityStack {
      */
     final boolean ensureActivitiesVisibleLocked(ActivityRecord top, ActivityRecord starting,
             String onlyThisProcess, int configChanges, boolean forceHomeShown) {
-        if (DEBUG_VISBILITY) Slog.v(
-                TAG, "ensureActivitiesVisible behind " + top
+        if (true||DEBUG_VISBILITY) Log.d(
+                TAG, "Ritter::AS ensureActivitiesVisible: starting:" +starting+ ", behind " + top
                 + " configChanges=0x" + Integer.toHexString(configChanges));
 
+        /** Ritter_multi
+         * If this is called by moveTaskToFront() by touch window,
+         * return immediately.
+        */
+        if(mStackSupervisor.mMoveTaskBackTaskInvisible){
+            Log.d(TAG, "Ritter::AS ensureActivitiesVisible: mStackSupervisor.mMoveTaskBackTaskInvisible == true return");
+            return false;
+        } else {
+            Log.d(TAG, "Ritter::AS ensureActivitiesVisible: mStackSupervisor.mMoveTaskBackTaskInvisible == false");
+        }
+
         if (mTranslucentActivityWaiting != top) {
             mUndrawnActivitiesBelowTopTranslucent.clear();
             if (mTranslucentActivityWaiting != null) {
@@ -1013,14 +1063,62 @@ final class ActivityStack {
         // If the top activity is not fullscreen, then we need to
         // make sure any activities under it are now visible.
         boolean aboveTop = true;
+
+        //Ritter old
+//        boolean showHomeBehindStack = false;
+
+        //Ritter new
+        //means show launcher anytime
         boolean showHomeBehindStack = false;
+        //end
+
         boolean behindFullscreen = !mStackSupervisor.isFrontStack(this) &&
                 !(forceHomeShown && isHomeStack());
+
+        Log.d(TAG,"Ritter::AS ensureActivitiesVisibleLocked: behindFullscreen = !mStackSupervisor.isFrontStack(this) && !(forceHomeShown && isHomeStack()");
+        Log.d(TAG,"Ritter::AS ensureActivitiesVisibleLocked:behindFullscreen:"+behindFullscreen);
+        Log.d(TAG,"Ritter::AS ensureActivitiesVisibleLocked: !mStackSupervisor.isFrontStack(this):"+!mStackSupervisor.isFrontStack(this)
+                + ",forceHomeShown:"+forceHomeShown+",isHomeStack():"+isHomeStack());
+
+        //Ritter_multi
+        // Get window apps from service
+        String APPs = "";
+        WindowAppsManager mWindowAppsManager = (WindowAppsManager) mContext
+                .getSystemService("window_apps");
+        try {
+            APPs = mWindowAppsManager.getWindowApps();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        ArrayList<String> pkgList = new ArrayList<String>(
+                Arrays.asList(APPs.split("#")));
+        //end
+
         for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
             final TaskRecord task = mTaskHistory.get(taskNdx);
+            Log.d(TAG,"Ritter::AS ensureActivitiesVisibleLocked:taskNdx:"+taskNdx+",task.stringName:"+task.stringName+" =============");
             final ArrayList<ActivityRecord> activities = task.mActivities;
             for (int activityNdx = activities.size() - 1; activityNdx >= 0; --activityNdx) {
                 final ActivityRecord r = activities.get(activityNdx);
+                Log.d(TAG,"Ritter::AS ensureActivitiesVisibleLocked:activityNdx:"+activityNdx+",r.packageName:"+r.packageName+" +++++++++++++");
+                Log.d(TAG,"Ritter::AS ensureActivitiesVisibleLocked: task.mOnTopOfHome:"+task.mOnTopOfHome
+                        +",r.fullscreen:"+r.fullscreen);
+
+                //Ritter_multi
+//                if(r.packageName.equals("com.example.hello")
+//                        ||r.packageName.equals("com.example.activity")
+//                        ||r.packageName.equals("com.android.systemui")
+//                        ){
+                if((!r.packageName.isEmpty() && pkgList.contains(r.packageName))
+                        ||r.packageName.equals("com.android.systemui")
+                        ){
+                    r.fullscreen = false;
+                    showHomeBehindStack = true;
+
+//                    behindFullscreen = false;
+                }
+                //end
+
                 if (r.finishing) {
                     continue;
                 }
@@ -1029,7 +1127,8 @@ final class ActivityStack {
                 }
                 aboveTop = false;
                 if (!behindFullscreen) {
-                    if (DEBUG_VISBILITY) Slog.v(
+                    Log.d(TAG,"Ritter::AS ensureActivitiesVisible: !behindFullScreen");
+                    if (DEBUG_VISBILITY) Log.d(
                             TAG, "Make visible? " + r + " finishing=" + r.finishing
                             + " state=" + r.state);
 
@@ -1047,13 +1146,14 @@ final class ActivityStack {
                             // This activity needs to be visible, but isn't even
                             // running...  get it started, but don't resume it
                             // at this point.
-                            if (DEBUG_VISBILITY) Slog.v(TAG, "Start and freeze screen for " + r);
+                            if (DEBUG_VISBILITY) Log.d(TAG, "Start and freeze screen for " + r);
                             if (r != starting) {
                                 r.startFreezingScreenLocked(r.app, configChanges);
                             }
                             if (!r.visible) {
-                                if (DEBUG_VISBILITY) Slog.v(
+                                if (DEBUG_VISBILITY) Log.d(
                                         TAG, "Starting and making visible: " + r);
+                                Log.d(TAG,"Ritter::AS ensureActivitiesVisibleLocked: setAppVisibility true");
                                 mWindowManager.setAppVisibility(r.appToken, true);
                             }
                             if (r != starting) {
@@ -1064,7 +1164,7 @@ final class ActivityStack {
                     } else if (r.visible) {
                         // If this activity is already visible, then there is nothing
                         // else to do here.
-                        if (DEBUG_VISBILITY) Slog.v(TAG, "Skipping: already visible at " + r);
+                        if (DEBUG_VISBILITY) Log.d(TAG, "Skipping: already visible at " + r);
                         r.stopFreezingScreenLocked(false);
 
                     } else if (onlyThisProcess == null) {
@@ -1074,12 +1174,13 @@ final class ActivityStack {
                         if (r.state != ActivityState.RESUMED && r != starting) {
                             // If this activity is paused, tell it
                             // to now show its window.
-                            if (DEBUG_VISBILITY) Slog.v(
+                            if (DEBUG_VISBILITY) Log.d(
                                     TAG, "Making visible and scheduling visibility: " + r);
                             try {
                                 if (mTranslucentActivityWaiting != null) {
                                     mUndrawnActivitiesBelowTopTranslucent.add(r);
                                 }
+                                Log.d(TAG,"Ritter::AS ensureActivitiesVisibleLocked: setAppVisibility true 2");
                                 mWindowManager.setAppVisibility(r.appToken, true);
                                 r.sleeping = false;
                                 r.app.pendingUiClean = true;
@@ -1099,7 +1200,7 @@ final class ActivityStack {
 
                     if (r.fullscreen) {
                         // At this point, nothing else needs to be shown
-                        if (DEBUG_VISBILITY) Slog.v(TAG, "Fullscreen: at " + r);
+                        if (DEBUG_VISBILITY) Log.d(TAG, "Fullscreen: at " + r);
                         behindFullscreen = true;
                     } else if (task.mOnTopOfHome) {
                         // Work our way down from r to bottom of task and see if there are any
@@ -1108,35 +1209,37 @@ final class ActivityStack {
                         for ( --rIndex; rIndex >= 0; --rIndex) {
                             final ActivityRecord blocker = task.mActivities.get(rIndex);
                             if (!blocker.finishing) {
-                                if (DEBUG_VISBILITY) Slog.v(TAG, "Home visibility for " +
+                                if (DEBUG_VISBILITY) Log.d(TAG, "Home visibility for " +
                                         r + " blocked by " + blocker);
                                 break;
                             }
                         }
                         if (rIndex < 0) {
                             // Got to task bottom without finding a visible activity, show home.
-                            if (DEBUG_VISBILITY) Slog.v(TAG, "Showing home: at " + r);
+                            if (DEBUG_VISBILITY) Log.d(TAG, "Showing home: at " + r);
                             showHomeBehindStack = true;
                             behindFullscreen = true;
                         }
                     }
                 } else {
-                    if (DEBUG_VISBILITY) Slog.v(
+                    Log.d(TAG,"Ritter::AS ensureActivitiesVisible: behindFullScreen()");
+                    if (DEBUG_VISBILITY) Log.d(
                         TAG, "Make invisible? " + r + " finishing=" + r.finishing
                         + " state=" + r.state
                         + " behindFullscreen=" + behindFullscreen);
                     // Now for any activities that aren't visible to the user, make
                     // sure they no longer are keeping the screen frozen.
                     if (r.visible) {
-                        if (DEBUG_VISBILITY) Slog.v(TAG, "Making invisible: " + r);
+                        if (DEBUG_VISBILITY) Log.d(TAG, "Making invisible: " + r);
                         r.visible = false;
                         try {
+                            Log.d(TAG,"Ritter::AS ensureActivitiesVisibleLocked: setAppVisibility false 3");
                             mWindowManager.setAppVisibility(r.appToken, false);
                             switch (r.state) {
                                 case STOPPING:
                                 case STOPPED:
                                     if (r.app != null && r.app.thread != null) {
-                                        if (DEBUG_VISBILITY) Slog.v(
+                                        if (DEBUG_VISBILITY) Log.d(
                                                 TAG, "Scheduling invisibility: " + r);
                                         r.app.thread.scheduleWindowVisibility(r.appToken, false);
                                     }
@@ -1164,7 +1267,7 @@ final class ActivityStack {
                                     + r.intent.getComponent(), e);
                         }
                     } else {
-                        if (DEBUG_VISBILITY) Slog.v(TAG, "Already invisible: " + r);
+                        if (DEBUG_VISBILITY) Log.d(TAG, "Already invisible: " + r);
                     }
                 }
             }
@@ -1222,6 +1325,7 @@ final class ActivityStack {
     }
 
     final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {
+        Log.d(TAG,"Ritter::AS resumeTopActivityLocked()BBB");
         if (ActivityManagerService.DEBUG_LOCKSCREEN) mService.logLockScreen("");
 
         // Find the first activity that is not finishing.
@@ -1236,11 +1340,11 @@ final class ActivityStack {
             // There are no more activities!  Let's just start up the
             // Launcher...
             ActivityOptions.abort(options);
-            if (DEBUG_STATES) Slog.d(TAG, "resumeTopActivityLocked: No more activities go home");
+            if (true||DEBUG_STATES) Log.d(TAG, "Ritter::AS resumeTopActivityLocked(): No more activities go home");
             if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
             return mStackSupervisor.resumeHomeActivity(prev);
         }
-
+        Log.d(TAG,"Ritter::AS resumeTopActivityLocked()BBB next:"+next);
         next.delayedResume = false;
 
         // If the top activity is the resumed one, nothing to do.
@@ -1251,16 +1355,30 @@ final class ActivityStack {
             mWindowManager.executeAppTransition();
             mNoAnimActivities.clear();
             ActivityOptions.abort(options);
-            if (DEBUG_STATES) Slog.d(TAG, "resumeTopActivityLocked: Top activity resumed " + next);
+            if (true||DEBUG_STATES) Log.d(TAG, "Ritter::AS resumeTopActivityLocked: Top activity resumed " + next);
             if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
             return false;
         }
 
         final TaskRecord nextTask = next.task;
         final TaskRecord prevTask = prev != null ? prev.task : null;
+
+        //Ritter_multi
+        if(prev != null){
+            Log.d(TAG,"Ritter::AS resumeTopActivityLocked()BBB prev:"+prev);
+        }else{
+            Log.d(TAG,"Ritter::AS resumeTopActivityLocked()BBB prev==null");
+        }
+        if(prevTask != null){
+            Log.d(TAG,"Ritter::AS resumeTopActivityLocked()BBB prevTask:"+prevTask);
+        }else{
+            Log.d(TAG,"Ritter::AS resumeTopActivityLocked()BBB prevTask==null");
+        }
+
         if (prevTask != null && prevTask.mOnTopOfHome && prev.finishing && prev.frontOfTask) {
             if (DEBUG_STACK)  mStackSupervisor.validateTopActivitiesLocked();
             if (prevTask == nextTask) {
+                Log.d(TAG,"Ritter::AS resumeTopActivityLocked()BBB 1 prevTask == nextTask");
                 ArrayList<ActivityRecord> activities = prevTask.mActivities;
                 final int numActivities = activities.size();
                 for (int activityNdx = 0; activityNdx < numActivities; ++activityNdx) {
@@ -1273,13 +1391,32 @@ final class ActivityStack {
                     }
                 }
             } else if (prevTask != topTask()) {
+                Log.d(TAG,"Ritter::AS resumeTopActivityLocked()BBB 2 prevTask != topTask()");
                 // This task is going away but it was supposed to return to the home task.
                 // Now the task above it has to return to the home task instead.
                 final int taskNdx = mTaskHistory.indexOf(prevTask) + 1;
                 mTaskHistory.get(taskNdx).mOnTopOfHome = true;
             } else {
-                if (DEBUG_STATES) Slog.d(TAG, "resumeTopActivityLocked: Launching home next");
+                Log.d(TAG,"Ritter::AS resumeTopActivityLocked()BBB 3 preTask!=nextTask || prevTask == topTask()");
+                // Ritter_multi preTask!=nextTask || prevTask == topTask()
+                // This is the key part when BACK_KEY pressed and Home show up reason
+                if (true||DEBUG_STATES) Log.d(TAG, "Ritter::AS resumeTopActivityLocked: Launching home next");
+                //Ritter_Multi old
                 return mStackSupervisor.resumeHomeActivity(prev);
+
+                //Ritter_multi new
+//                ArrayList<ActivityRecord> activities = nextTask.mActivities;
+//                final int numActivities = activities.size();
+//                for (int activityNdx = 0; activityNdx < numActivities; ++activityNdx) {
+//                    final ActivityRecord r = activities.get(activityNdx);
+//                    // r is usually the same as next, but what if two activities were launched
+//                    // before prev finished?
+//                    if (!r.finishing) {
+//                        r.frontOfTask = true;
+//                        break;
+//                    }
+//                }
+
             }
         }
 
@@ -1293,7 +1430,7 @@ final class ActivityStack {
             mWindowManager.executeAppTransition();
             mNoAnimActivities.clear();
             ActivityOptions.abort(options);
-            if (DEBUG_STATES) Slog.d(TAG, "resumeTopActivityLocked: Going to sleep and all paused");
+            if (true||DEBUG_STATES) Log.d(TAG, "Ritter::AS resumeTopActivityLocked: Going to sleep and all paused");
             if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
             return false;
         }
@@ -1302,7 +1439,7 @@ final class ActivityStack {
         // we will just leave it as is because someone should be bringing
         // another user's activities to the top of the stack.
         if (mService.mStartedUsers.get(next.userId) == null) {
-            Slog.w(TAG, "Skipping resume of top activity " + next
+            Slog.w(TAG, "Ritter::AS resumeTopActivityLocked(): Skipping resume of top activity " + next
                     + ": user " + next.userId + " is stopped");
             if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
             return false;
@@ -1317,17 +1454,17 @@ final class ActivityStack {
 
         next.updateOptionsLocked(options);
 
-        if (DEBUG_SWITCH) Slog.v(TAG, "Resuming " + next);
+        if (true||DEBUG_SWITCH) Log.d(TAG, "Ritter::AS Resuming " + next);
 
         // If we are currently pausing an activity, then don't do anything
         // until that is done.
         if (!mStackSupervisor.allPausedActivitiesComplete()) {
-            if (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG,
+            if (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Log.d(TAG,
                     "resumeTopActivityLocked: Skip resume: some activity pausing.");
             if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
             return false;
         }
-
+        Log.d(TAG,"Ritter::AS resumeTopActivityLocked() works fine, start a switch to 'next'");
         // Okay we are now going to start a switch, to 'next'.  We may first
         // have to pause the current activity, but this is an important point
         // where we have decided to go to 'next' so keep track of that.
@@ -1356,18 +1493,24 @@ final class ActivityStack {
                 mLastStartedActivity = next;
             }
         }
-
+        Log.d(TAG,"Ritter::AS We need to start pausing the current activity");
+        Log.d(TAG,"Ritter::AS userLeaving:"+userLeaving);
         // We need to start pausing the current activity so the top one
         // can be resumed...
         boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving);
+        Log.d(TAG,"Ritter::AS pauseBackStacks:"+pausing);
         if (mResumedActivity != null) {
+            Log.d(TAG,"Ritter::AS mResumedActivity != null");
             pausing = true;
+            // Ritter_Multi this part can be modified
             startPausingLocked(userLeaving, false);
-            if (DEBUG_STATES) Slog.d(TAG, "resumeTopActivityLocked: Pausing " + mResumedActivity);
+
+            if (true||DEBUG_STATES) Log.d(TAG, "Ritter::AS resumeTopActivityLocked: Pausing " + mResumedActivity);
         }
         if (pausing) {
-            if (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG,
-                    "resumeTopActivityLocked: Skip resume: need to start pausing");
+            Log.d(TAG,"Ritter::AS pausing==true");
+            if (true||DEBUG_SWITCH || DEBUG_STATES) Log.d(TAG,
+                    "Ritter::AS resumeTopActivityLocked: Skip resume: need to start pausing");
             // At this point we want to put the upcoming activity's process
             // at the top of the LRU list, since we know we will be needing it
             // very soon and it would be a waste to let it get killed if it
@@ -1386,7 +1529,7 @@ final class ActivityStack {
         // sure to finish it as we're making a new activity topmost.
         if (mService.mSleeping && mLastNoHistoryActivity != null &&
                 !mLastNoHistoryActivity.finishing) {
-            if (DEBUG_STATES) Slog.d(TAG, "no-history finish of " + mLastNoHistoryActivity +
+            if (true||DEBUG_STATES) Log.d(TAG, "Ritter::AS resumeTopActivityLocked:no-history finish of " + mLastNoHistoryActivity +
                     " on new resume");
             requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,
                     null, "no-history", false);
@@ -1394,11 +1537,12 @@ final class ActivityStack {
         }
 
         if (prev != null && prev != next) {
+            Log.d(TAG,"Ritter::AS prev != null && prev != next");
             if (!prev.waitingVisible && next != null && !next.nowVisible) {
                 prev.waitingVisible = true;
                 mStackSupervisor.mWaitingVisibleActivities.add(prev);
-                if (DEBUG_SWITCH) Slog.v(
-                        TAG, "Resuming top, waiting visible to hide: " + prev);
+                if (true||DEBUG_SWITCH) Log.d(
+                        TAG, "Ritter::AS resumeTopActivityLocked:Resuming top, waiting visible to hide: " + prev);
             } else {
                 // The next activity is already visible, so hide the previous
                 // activity's windows right now so we can show the new one ASAP.
@@ -1409,13 +1553,15 @@ final class ActivityStack {
                 // previous should actually be hidden depending on whether the
                 // new one is found to be full-screen or not.
                 if (prev.finishing) {
+                    Log.d(TAG,"Ritter::AS resumeTopActivityLocked: set prev visibility:"+prev+" false");
+                    Log.d(TAG,"Ritter::AS resumeTopActivityLocked: setAppVisibility false 1");
                     mWindowManager.setAppVisibility(prev.appToken, false);
-                    if (DEBUG_SWITCH) Slog.v(TAG, "Not waiting for visible to hide: "
+                    if (true||DEBUG_SWITCH) Log.d(TAG, "Ritter::AS resumeTopActivityLocked:Not waiting for visible to hide: "
                             + prev + ", waitingVisible="
                             + (prev != null ? prev.waitingVisible : null)
                             + ", nowVisible=" + next.nowVisible);
                 } else {
-                    if (DEBUG_SWITCH) Slog.v(TAG, "Previous already visible but still waiting to hide: "
+                    if (true||DEBUG_SWITCH) Log.d(TAG, "Ritter::AS resumeTopActivityLocked:Previous already visible but still waiting to hide: "
                         + prev + ", waitingVisible="
                         + (prev != null ? prev.waitingVisible : null)
                         + ", nowVisible=" + next.nowVisible);
@@ -1440,8 +1586,8 @@ final class ActivityStack {
         boolean anim = true;
         if (prev != null) {
             if (prev.finishing) {
-                if (DEBUG_TRANSITION) Slog.v(TAG,
-                        "Prepare close transition: prev=" + prev);
+                if (true||DEBUG_TRANSITION) Log.d(TAG,
+                        "Ritter::AS resumeTopActivityLocked:Prepare close transition: prev=" + prev);
                 if (mNoAnimActivities.contains(prev)) {
                     anim = false;
                     mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false);
@@ -1451,9 +1597,10 @@ final class ActivityStack {
                             : AppTransition.TRANSIT_TASK_CLOSE, false);
                 }
                 mWindowManager.setAppWillBeHidden(prev.appToken);
+                Log.d(TAG,"Ritter::AS resumeTopActivityLocked: setAppVisibility false 2");
                 mWindowManager.setAppVisibility(prev.appToken, false);
             } else {
-                if (DEBUG_TRANSITION) Slog.v(TAG, "Prepare open transition: prev=" + prev);
+                if (true||DEBUG_TRANSITION) Log.d(TAG, "Ritter::AS Prepare open transition: prev=" + prev);
                 if (mNoAnimActivities.contains(next)) {
                     anim = false;
                     mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false);
@@ -1465,10 +1612,11 @@ final class ActivityStack {
             }
             if (false) {
                 mWindowManager.setAppWillBeHidden(prev.appToken);
+                Log.d(TAG,"Ritter::AS resumeTopActivityLocked: setAppVisibility false 3");
                 mWindowManager.setAppVisibility(prev.appToken, false);
             }
         } else {
-            if (DEBUG_TRANSITION) Slog.v(TAG, "Prepare open transition: no previous");
+            if (true||DEBUG_TRANSITION) Log.d(TAG, "Ritter::AS resumeTopActivityLocked:Prepare open transition: no previous");
             if (mNoAnimActivities.contains(next)) {
                 anim = false;
                 mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false);
@@ -1484,8 +1632,9 @@ final class ActivityStack {
 
         ActivityStack lastStack = mStackSupervisor.getLastStack();
         if (next.app != null && next.app.thread != null) {
-            if (DEBUG_SWITCH) Slog.v(TAG, "Resume running: " + next);
+            if (true||DEBUG_SWITCH) Log.d(TAG, "Ritter::AS resumeTopActivityLocked:Resume running: " + next);
 
+            Log.d(TAG,"Ritter::AS resumeTopActivityLocked: setAppVisibility true 4");
             // This activity is now becoming visible.
             mWindowManager.setAppVisibility(next.appToken, true);
 
@@ -1498,7 +1647,7 @@ final class ActivityStack {
 
             mService.updateCpuStats();
 
-            if (DEBUG_STATES) Slog.v(TAG, "Moving to RESUMED: " + next + " (in existing)");
+            if (true||DEBUG_STATES) Log.d(TAG, "Ritter::AS resumeTopActivityLocked:Moving to RESUMED: " + next + " (in existing)");
             next.state = ActivityState.RESUMED;
             mResumedActivity = next;
             next.task.touchActiveTime();
@@ -1526,10 +1675,11 @@ final class ActivityStack {
                 // is still at the top and schedule another run if something
                 // weird happened.
                 ActivityRecord nextNext = topRunningActivityLocked(null);
-                if (DEBUG_SWITCH || DEBUG_STATES) Slog.i(TAG,
-                        "Activity config changed during resume: " + next
+                if (true||DEBUG_SWITCH || DEBUG_STATES) Log.d(TAG,
+                        "Ritter::AS resumeTopActivityLocked:Activity config changed during resume: " + next
                         + ", new next: " + nextNext);
                 if (nextNext != next) {
+                    Log.d(TAG,"Ritter::AS Do Over!!!???");
                     // Do over!
                     mStackSupervisor.scheduleResumeTopActivities();
                 }
@@ -1548,8 +1698,8 @@ final class ActivityStack {
                 if (a != null) {
                     final int N = a.size();
                     if (!next.finishing && N > 0) {
-                        if (DEBUG_RESULTS) Slog.v(
-                                TAG, "Delivering results to " + next
+                        if (true||DEBUG_RESULTS) Log.d(
+                                TAG, "Ritter::AS resumeTopActivityLocked:Delivering results to " + next
                                 + ": " + a);
                         next.app.thread.scheduleSendResult(next.appToken, a);
                     }
@@ -1572,16 +1722,17 @@ final class ActivityStack {
 
                 mStackSupervisor.checkReadyForSleepLocked();
 
-                if (DEBUG_STATES) Slog.d(TAG, "resumeTopActivityLocked: Resumed " + next);
+                if (true||DEBUG_STATES) Log.d(TAG, "Ritter::ASresumeTopActivityLocked: resumeTopActivityLocked: Resumed " + next);
             } catch (Exception e) {
+                Log.d(TAG,"Ritter::AS Whoops, need to restart this activity!A");
                 // Whoops, need to restart this activity!
-                if (DEBUG_STATES) Slog.v(TAG, "Resume failed; resetting state to "
+                if (true||DEBUG_STATES) Log.d(TAG, "Ritter::AS Resume failed; resetting state to "
                         + lastState + ": " + next);
                 next.state = lastState;
                 if (lastStack != null) {
                     lastStack.mResumedActivity = lastResumedActivity;
                 }
-                Slog.i(TAG, "Restarting because process died: " + next);
+                Log.d(TAG, "Ritter::AS Restarting because process died: " + next);
                 if (!next.hasBeenLaunched) {
                     next.hasBeenLaunched = true;
                 } else  if (SHOW_APP_STARTING_PREVIEW && lastStack != null &&
@@ -1605,7 +1756,7 @@ final class ActivityStack {
             } catch (Exception e) {
                 // If any exception gets thrown, toss away this
                 // activity and try the next one.
-                Slog.w(TAG, "Exception thrown during resume of " + next, e);
+                Slog.w(TAG, "Ritter::AS resumeTopActivityLocked:Exception thrown during resume of " + next, e);
                 requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null,
                         "resume-exception", true);
                 if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
@@ -1614,6 +1765,7 @@ final class ActivityStack {
             next.stopped = false;
 
         } else {
+            Log.d(TAG,"Ritter::AS Whoops, need to restart this activity!B --myabe this means create a non-exist activity");
             // Whoops, need to restart this activity!
             if (!next.hasBeenLaunched) {
                 next.hasBeenLaunched = true;
@@ -1627,9 +1779,9 @@ final class ActivityStack {
                             next.labelRes, next.icon, next.logo, next.windowFlags,
                             null, true);
                 }
-                if (DEBUG_SWITCH) Slog.v(TAG, "Restarting: " + next);
+                if (DEBUG_SWITCH) Log.d(TAG, "Restarting: " + next);
             }
-            if (DEBUG_STATES) Slog.d(TAG, "resumeTopActivityLocked: Restarting " + next);
+            if (true||DEBUG_STATES) Log.d(TAG, "Ritter::AS resumeTopActivityLocked: Restarting " + next);
             mStackSupervisor.startSpecificActivityLocked(next, true, true);
         }
 
@@ -1663,6 +1815,7 @@ final class ActivityStack {
 
     final void startActivityLocked(ActivityRecord r, boolean newTask,
             boolean doResume, boolean keepCurTransition, Bundle options) {
+        Log.d(TAG,"Ritter::AS startActivityLocked()");
         TaskRecord rTask = r.task;
         final int taskId = rTask.taskId;
         if (taskForIdLocked(taskId) == null || newTask) {
@@ -1683,7 +1836,7 @@ final class ActivityStack {
                     // user, then just add it without starting; it will
                     // get started when the user navigates back to it.
                     if (!startIt) {
-                        if (DEBUG_ADD_REMOVE) Slog.i(TAG, "Adding activity " + r + " to task "
+                        if (DEBUG_ADD_REMOVE) Log.d(TAG, "Adding activity " + r + " to task "
                                 + task, new RuntimeException("here").fillInStackTrace());
                         task.addActivityToTop(r);
                         r.putInHistory();
@@ -1712,20 +1865,21 @@ final class ActivityStack {
         // activity
         if (task == r.task && mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) {
             mStackSupervisor.mUserLeaving = false;
-            if (DEBUG_USER_LEAVING) Slog.v(TAG,
-                    "startActivity() behind front, mUserLeaving=false");
+            if (true) Log.d(TAG,
+                    "Ritter::AS startActivityLocked() startActivity() behind front, mUserLeaving=false");
         }
 
         task = r.task;
 
         // Slot the activity into the history stack and proceed
-        if (DEBUG_ADD_REMOVE) Slog.i(TAG, "Adding activity " + r + " to stack to task " + task,
+        if (true) Log.d(TAG, "Ritter::AS startActivityLocked() Adding activity " + r + " to stack to task " + task,
                 new RuntimeException("here").fillInStackTrace());
         task.addActivityToTop(r);
 
         r.putInHistory();
         r.frontOfTask = newTask;
         if (!isHomeStack() || numActivities() > 0) {
+            Log.d(TAG,"Ritter::AS startActivityLocked() !isHomeStack() || numActivities() > 0");
             // We want to show the starting preview window if we are
             // switching to a new task, or the next activity's process is
             // not currently running.
@@ -1737,12 +1891,14 @@ final class ActivityStack {
             if (proc == null || proc.thread == null) {
                 showStartingIcon = true;
             }
-            if (DEBUG_TRANSITION) Slog.v(TAG,
-                    "Prepare open transition: starting " + r);
+            if (true||DEBUG_TRANSITION) Log.d(TAG,
+                    "Ritter::AS startActivityLocked() Prepare open transition: starting " + r);
             if ((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
+                Log.d(TAG,"Ritter::AS startActivityLocked() Intent.FLAG_ACTIVITY_NO_ANIMATION");
                 mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, keepCurTransition);
                 mNoAnimActivities.add(r);
             } else {
+                Log.d(TAG,"Ritter::AS startActivityLocked() !Intent.FLAG_ACTIVITY_NO_ANIMATION");
                 mWindowManager.prepareAppTransition(newTask
                         ? AppTransition.TRANSIT_TASK_OPEN
                         : AppTransition.TRANSIT_ACTIVITY_OPEN, keepCurTransition);
@@ -1790,6 +1946,7 @@ final class ActivityStack {
                         prev != null ? prev.appToken : null, showStartingIcon);
             }
         } else {
+            Log.d(TAG,"Ritter::AS startActivityLocked() this is the first activity, don't do any fancy animations");
             // If this is the first activity, don't do any fancy animations,
             // because there is nothing for it to animate on top of.
             mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,
@@ -1893,13 +2050,13 @@ final class ActivityStack {
                     // same task affinity as the one we are moving,
                     // then merge it into the same task.
                     target.setTask(bottom.task, bottom.thumbHolder, false);
-                    if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
+                    if (DEBUG_TASKS) Log.d(TAG, "Start pushing activity " + target
                             + " out to bottom task " + bottom.task);
                 } else {
                     target.setTask(createTaskRecord(mStackSupervisor.getNextTaskId(), target.info,
                             null, false), null, false);
                     target.task.affinityIntent = target.intent;
-                    if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
+                    if (DEBUG_TASKS) Log.d(TAG, "Start pushing activity " + target
                             + " out to new task " + target.task);
                 }
 
@@ -1923,10 +2080,10 @@ final class ActivityStack {
                             noOptions = false;
                         }
                     }
-                    if (DEBUG_ADD_REMOVE) Slog.i(TAG, "Removing activity " + p + " from task="
+                    if (DEBUG_ADD_REMOVE) Log.d(TAG, "Removing activity " + p + " from task="
                             + task + " adding to task=" + targetTask,
                             new RuntimeException("here").fillInStackTrace());
-                    if (DEBUG_TASKS) Slog.v(TAG, "Pushing next activity " + p
+                    if (DEBUG_TASKS) Log.d(TAG, "Pushing next activity " + p
                             + " out to target's task " + target.task);
                     p.setTask(targetTask, curThumbHolder, false);
                     targetTask.addActivityAtBottom(p);
@@ -2038,7 +2195,7 @@ final class ActivityStack {
                 // in a task that is not currently on top.)
                 if (forceReset || finishOnTaskLaunch) {
                     final int start = replyChainEnd >= 0 ? replyChainEnd : i;
-                    if (DEBUG_TASKS) Slog.v(TAG, "Finishing task at index " + start + " to " + i);
+                    if (DEBUG_TASKS) Log.d(TAG, "Finishing task at index " + start + " to " + i);
                     for (int srcPos = start; srcPos >= i; --srcPos) {
                         final ActivityRecord p = activities.get(srcPos);
                         if (p.finishing) {
@@ -2053,17 +2210,17 @@ final class ActivityStack {
                     }
 
                     final int start = replyChainEnd >= 0 ? replyChainEnd : i;
-                    if (DEBUG_TASKS) Slog.v(TAG, "Reparenting from task=" + affinityTask + ":"
+                    if (DEBUG_TASKS) Log.d(TAG, "Reparenting from task=" + affinityTask + ":"
                             + start + "-" + i + " to task=" + task + ":" + taskInsertionPoint);
                     for (int srcPos = start; srcPos >= i; --srcPos) {
                         final ActivityRecord p = activities.get(srcPos);
                         p.setTask(task, null, false);
                         task.addActivityAtIndex(taskInsertionPoint, p);
 
-                        if (DEBUG_ADD_REMOVE) Slog.i(TAG, "Removing and adding activity " + p
+                        if (DEBUG_ADD_REMOVE) Log.d(TAG, "Removing and adding activity " + p
                                 + " to stack at " + task,
                                 new RuntimeException("here").fillInStackTrace());
-                        if (DEBUG_TASKS) Slog.v(TAG, "Pulling activity " + p + " from " + srcPos
+                        if (DEBUG_TASKS) Log.d(TAG, "Pulling activity " + p + " from " + srcPos
                                 + " in to resetting task " + task);
                         mWindowManager.setAppGroupId(p.appToken, taskId);
                     }
@@ -2156,7 +2313,7 @@ final class ActivityStack {
                     data, r.getUriPermissionsLocked());
         }
 
-        if (DEBUG_RESULTS) Slog.v(TAG, "Send activity result to " + r
+        if (DEBUG_RESULTS) Log.d(TAG, "Send activity result to " + r
                 + " : who=" + resultWho + " req=" + requestCode
                 + " res=" + resultCode + " data=" + data);
         if (mResumedActivity == r && r.app != null && r.app.thread != null) {
@@ -2175,18 +2332,19 @@ final class ActivityStack {
     }
 
     final void stopActivityLocked(ActivityRecord r) {
-        if (DEBUG_SWITCH) Slog.d(TAG, "Stopping: " + r);
+        Log.d(TAG,"Ritter::AS stopActivityLocked r.packageName:"+r.packageName);
+        if (DEBUG_SWITCH) Log.d(TAG, "Stopping: " + r);
         if ((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                 || (r.info.flags&ActivityInfo.FLAG_NO_HISTORY) != 0) {
             if (!r.finishing) {
                 if (!mService.mSleeping) {
                     if (DEBUG_STATES) {
-                        Slog.d(TAG, "no-history finish of " + r);
+                        Log.d(TAG, "no-history finish of " + r);
                     }
                     requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,
                             "no-history", false);
                 } else {
-                    if (DEBUG_STATES) Slog.d(TAG, "Not finishing noHistory " + r
+                    if (DEBUG_STATES) Log.d(TAG, "Not finishing noHistory " + r
                             + " on stop because we're just sleeping");
                 }
             }
@@ -2201,12 +2359,13 @@ final class ActivityStack {
             r.resumeKeyDispatchingLocked();
             try {
                 r.stopped = false;
-                if (DEBUG_STATES) Slog.v(TAG, "Moving to STOPPING: " + r
+                if (DEBUG_STATES) Log.d(TAG, "Moving to STOPPING: " + r
                         + " (stop requested)");
                 r.state = ActivityState.STOPPING;
-                if (DEBUG_VISBILITY) Slog.v(
+                if (DEBUG_VISBILITY) Log.d(
                         TAG, "Stopping visible=" + r.visible + " for " + r);
                 if (!r.visible) {
+                    Log.d(TAG,"Ritter::AS stopActivityLocked: setAppVisibility false 1");
                     mWindowManager.setAppVisibility(r.appToken, false);
                 }
                 r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags);
@@ -2222,7 +2381,7 @@ final class ActivityStack {
                 Slog.w(TAG, "Exception thrown during pause", e);
                 // Just in case, assume it to be stopped.
                 r.stopped = true;
-                if (DEBUG_STATES) Slog.v(TAG, "Stop failed; moving to STOPPED: " + r);
+                if (DEBUG_STATES) Log.d(TAG, "Stop failed; moving to STOPPED: " + r);
                 r.state = ActivityState.STOPPED;
                 if (r.configDestroy) {
                     destroyActivityLocked(r, true, false, "stop-except");
@@ -2237,8 +2396,9 @@ final class ActivityStack {
      */
     final boolean requestFinishActivityLocked(IBinder token, int resultCode,
             Intent resultData, String reason, boolean oomAdj) {
+        Log.d(TAG,"Ritter::AS BACK_KEY requestFinishActivityLocked()");
         ActivityRecord r = isInStackLocked(token);
-        if (DEBUG_RESULTS || DEBUG_STATES) Slog.v(
+        if (DEBUG_RESULTS || DEBUG_STATES) Log.d(
                 TAG, "Finishing activity token=" + token + " r="
                 + ", result=" + resultCode + ", data=" + resultData
                 + ", reason=" + reason);
@@ -2318,10 +2478,11 @@ final class ActivityStack {
     }
 
     final void finishActivityResultsLocked(ActivityRecord r, int resultCode, Intent resultData) {
+        Log.d(TAG,"Ritter::AS BACK_KEY finishActivityResultsLocked()");
         // send the result
         ActivityRecord resultTo = r.resultTo;
         if (resultTo != null) {
-            if (DEBUG_RESULTS) Slog.v(TAG, "Adding result to " + resultTo
+            if (DEBUG_RESULTS) Log.d(TAG, "Adding result to " + resultTo
                     + " who=" + r.resultWho + " req=" + r.requestCode
                     + " res=" + resultCode + " data=" + resultData);
             if (r.info.applicationInfo.uid > 0) {
@@ -2333,7 +2494,7 @@ final class ActivityStack {
                                      resultData);
             r.resultTo = null;
         }
-        else if (DEBUG_RESULTS) Slog.v(TAG, "No result destination from " + r);
+        else if (DEBUG_RESULTS) Log.d(TAG, "No result destination from " + r);
 
         // Make sure this HistoryRecord is not holding on to other resources,
         // because clients have remote IPC references to this object so we
@@ -2350,6 +2511,7 @@ final class ActivityStack {
      */
     final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,
             String reason, boolean oomAdj) {
+        Log.d(TAG,"Ritter:AS BACK_KEY finishActivityLocked()");
         if (r.finishing) {
             Slog.w(TAG, "Duplicate finish request for " + r);
             return false;
@@ -2378,6 +2540,7 @@ final class ActivityStack {
         r.pauseKeyDispatchingLocked();
         if (mStackSupervisor.isFrontStack(this)) {
             if (mService.mFocusedActivity == r) {
+                Log.d(TAG,"Ritter:AS BACK_KEY finishActivityLocked: mService.mFocusedActivity == r");
                 mService.setFocusedActivityLocked(mStackSupervisor.topRunningActivityLocked());
             }
         }
@@ -2393,28 +2556,30 @@ final class ActivityStack {
 
         if (mResumedActivity == r) {
             boolean endTask = index <= 0;
-            if (DEBUG_VISBILITY || DEBUG_TRANSITION) Slog.v(TAG,
+            if (DEBUG_VISBILITY || DEBUG_TRANSITION) Log.d(TAG,
                     "Prepare close transition: finishing " + r);
-            mWindowManager.prepareAppTransition(endTask
-                    ? AppTransition.TRANSIT_TASK_CLOSE
-                    : AppTransition.TRANSIT_ACTIVITY_CLOSE, false);
+            //Ritter_multi old
+//            mWindowManager.prepareAppTransition(endTask
+//                    ? AppTransition.TRANSIT_TASK_CLOSE
+//                    : AppTransition.TRANSIT_ACTIVITY_CLOSE, false);
 
             // Tell window manager to prepare for this one to be removed.
+            Log.d(TAG,"Ritter::AS finishActivityLocked: setAppVisibility false");
             mWindowManager.setAppVisibility(r.appToken, false);
 
             if (mPausingActivity == null) {
-                if (DEBUG_PAUSE) Slog.v(TAG, "Finish needs to pause: " + r);
-                if (DEBUG_USER_LEAVING) Slog.v(TAG, "finish() => pause with userLeaving=false");
+                if (DEBUG_PAUSE) Log.d(TAG, "Finish needs to pause: " + r);
+                if (DEBUG_USER_LEAVING) Log.d(TAG, "finish() => pause with userLeaving=false");
                 startPausingLocked(false, false);
             }
 
         } else if (r.state != ActivityState.PAUSING) {
             // If the activity is PAUSING, we will complete the finish once
             // it is done pausing; else we can just directly finish it here.
-            if (DEBUG_PAUSE) Slog.v(TAG, "Finish not pausing: " + r);
+            if (DEBUG_PAUSE) Log.d(TAG, "Finish not pausing: " + r);
             return finishCurrentActivityLocked(r, FINISH_AFTER_PAUSE, oomAdj) == null;
         } else {
-            if (DEBUG_PAUSE) Slog.v(TAG, "Finish waiting for pause of: " + r);
+            if (DEBUG_PAUSE) Log.d(TAG, "Finish waiting for pause of: " + r);
         }
 
         return false;
@@ -2425,6 +2590,7 @@ final class ActivityStack {
     static final int FINISH_AFTER_VISIBLE = 2;
 
     final ActivityRecord finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj) {
+        Log.d(TAG,"Ritter::AMS finishCurrentActivityLocked()");
         // First things first: if this activity is currently visible,
         // and the resumed activity is not yet visible, then hold off on
         // finishing until the resumed one becomes visible.
@@ -2442,7 +2608,7 @@ final class ActivityStack {
                     mStackSupervisor.checkReadyForSleepLocked();
                 }
             }
-            if (DEBUG_STATES) Slog.v(TAG, "Moving to STOPPING: " + r
+            if (DEBUG_STATES) Log.d(TAG, "Moving to STOPPING: " + r
                     + " (finish requested)");
             r.state = ActivityState.STOPPING;
             if (oomAdj) {
@@ -2459,7 +2625,7 @@ final class ActivityStack {
             mResumedActivity = null;
         }
         final ActivityState prevState = r.state;
-        if (DEBUG_STATES) Slog.v(TAG, "Moving to FINISHING: " + r);
+        if (DEBUG_STATES) Log.d(TAG, "Moving to FINISHING: " + r);
         r.state = ActivityState.FINISHING;
 
         if (mode == FINISH_IMMEDIATELY
@@ -2477,7 +2643,7 @@ final class ActivityStack {
 
         // Need to go through the full pause cycle to get this
         // activity into the stopped state and then finish it.
-        if (localLOGV) Slog.v(TAG, "Enqueueing pending finish: " + r);
+        if (localLOGV) Log.d(TAG, "Enqueueing pending finish: " + r);
         mStackSupervisor.mFinishingActivities.add(r);
         mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
         return r;
@@ -2583,9 +2749,9 @@ final class ActivityStack {
         r.frozenBeforeDestroy = false;
 
         if (setState) {
-            if (DEBUG_STATES) Slog.v(TAG, "Moving to DESTROYED: " + r + " (cleaning up)");
+            if (DEBUG_STATES) Log.d(TAG, "Moving to DESTROYED: " + r + " (cleaning up)");
             r.state = ActivityState.DESTROYED;
-            if (DEBUG_APP) Slog.v(TAG, "Clearing app during cleanUp for activity " + r);
+            if (DEBUG_APP) Log.d(TAG, "Clearing app during cleanUp for activity " + r);
             r.app = null;
         }
 
@@ -2635,11 +2801,11 @@ final class ActivityStack {
         if (DEBUG_ADD_REMOVE) {
             RuntimeException here = new RuntimeException("here");
             here.fillInStackTrace();
-            Slog.i(TAG, "Removing activity " + r + " from stack");
+            Log.d(TAG, "Removing activity " + r + " from stack");
         }
         final TaskRecord task = r.task;
         if (task != null && task.removeActivity(r)) {
-            if (DEBUG_STACK) Slog.i(TAG,
+            if (DEBUG_STACK) Log.d(TAG,
                     "removeActivityFromHistoryLocked: last activity removed from " + this);
             if (mStackSupervisor.isFrontStack(this) && task == topTask() && task.mOnTopOfHome) {
                 mStackSupervisor.moveHomeToTop();
@@ -2648,9 +2814,9 @@ final class ActivityStack {
         }
         r.takeFromHistory();
         removeTimeoutsForActivityLocked(r);
-        if (DEBUG_STATES) Slog.v(TAG, "Moving to DESTROYED: " + r + " (removed from history)");
+        if (DEBUG_STATES) Log.d(TAG, "Moving to DESTROYED: " + r + " (removed from history)");
         r.state = ActivityState.DESTROYED;
-        if (DEBUG_APP) Slog.v(TAG, "Clearing app during remove for activity " + r);
+        if (DEBUG_APP) Log.d(TAG, "Clearing app during remove for activity " + r);
         r.app = null;
         mWindowManager.removeAppToken(r.appToken);
         if (VALIDATE_TOKENS) {
@@ -2682,6 +2848,7 @@ final class ActivityStack {
     }
 
     final void destroyActivitiesLocked(ProcessRecord owner, boolean oomAdj, String reason) {
+        Log.d(TAG,"Ritter::AMS destroyActivitiesLocked()");
         boolean lastIsOpaque = false;
         boolean activityRemoved = false;
         for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
@@ -2706,7 +2873,7 @@ final class ActivityStack {
                         && r.haveState && !r.visible && r.stopped
                         && r.state != ActivityState.DESTROYING
                         && r.state != ActivityState.DESTROYED) {
-                    if (DEBUG_SWITCH) Slog.v(TAG, "Destroying " + r + " in state " + r.state
+                    if (DEBUG_SWITCH) Log.d(TAG, "Destroying " + r + " in state " + r.state
                             + " resumed=" + mResumedActivity
                             + " pausing=" + mPausingActivity);
                     if (destroyActivityLocked(r, true, oomAdj, reason)) {
@@ -2729,7 +2896,7 @@ final class ActivityStack {
      */
     final boolean destroyActivityLocked(ActivityRecord r,
             boolean removeFromApp, boolean oomAdj, String reason) {
-        if (DEBUG_SWITCH || DEBUG_CLEANUP) Slog.v(
+        if (DEBUG_SWITCH || DEBUG_CLEANUP) Log.d(
             TAG, "Removing activity from " + reason + ": token=" + r
               + ", app=" + (r.app != null ? r.app.processName : "(null)"));
         EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,
@@ -2760,7 +2927,7 @@ final class ActivityStack {
             boolean skipDestroy = false;
 
             try {
-                if (DEBUG_SWITCH) Slog.i(TAG, "Destroying: " + r);
+                if (DEBUG_SWITCH) Log.d(TAG, "Destroying: " + r);
                 r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing,
                         r.configChangeFlags);
             } catch (Exception e) {
@@ -2785,15 +2952,15 @@ final class ActivityStack {
             // it in the destroyed state since we are not removing it from the
             // list.
             if (r.finishing && !skipDestroy) {
-                if (DEBUG_STATES) Slog.v(TAG, "Moving to DESTROYING: " + r
+                if (DEBUG_STATES) Log.d(TAG, "Moving to DESTROYING: " + r
                         + " (destroy requested)");
                 r.state = ActivityState.DESTROYING;
                 Message msg = mHandler.obtainMessage(DESTROY_TIMEOUT_MSG, r);
                 mHandler.sendMessageDelayed(msg, DESTROY_TIMEOUT);
             } else {
-                if (DEBUG_STATES) Slog.v(TAG, "Moving to DESTROYED: " + r + " (destroy skipped)");
+                if (DEBUG_STATES) Log.d(TAG, "Moving to DESTROYED: " + r + " (destroy skipped)");
                 r.state = ActivityState.DESTROYED;
-                if (DEBUG_APP) Slog.v(TAG, "Clearing app during destroy for activity " + r);
+                if (DEBUG_APP) Log.d(TAG, "Clearing app during destroy for activity " + r);
                 r.app = null;
             }
         } else {
@@ -2802,9 +2969,9 @@ final class ActivityStack {
                 removeActivityFromHistoryLocked(r);
                 removedFromHistory = true;
             } else {
-                if (DEBUG_STATES) Slog.v(TAG, "Moving to DESTROYED: " + r + " (no app)");
+                if (DEBUG_STATES) Log.d(TAG, "Moving to DESTROYED: " + r + " (no app)");
                 r.state = ActivityState.DESTROYED;
-                if (DEBUG_APP) Slog.v(TAG, "Clearing app during destroy for activity " + r);
+                if (DEBUG_APP) Log.d(TAG, "Clearing app during destroy for activity " + r);
                 r.app = null;
             }
         }
@@ -2819,6 +2986,7 @@ final class ActivityStack {
     }
 
     final void activityDestroyedLocked(IBinder token) {
+        Log.d(TAG,"Ritter::AMS activityDestroyedLocked()");
         final long origId = Binder.clearCallingIdentity();
         try {
             ActivityRecord r = ActivityRecord.forToken(token);
@@ -2841,15 +3009,15 @@ final class ActivityStack {
     private void removeHistoryRecordsForAppLocked(ArrayList<ActivityRecord> list,
             ProcessRecord app, String listName) {
         int i = list.size();
-        if (DEBUG_CLEANUP) Slog.v(
+        if (DEBUG_CLEANUP) Log.d(
             TAG, "Removing app " + app + " from list " + listName
             + " with " + i + " entries");
         while (i > 0) {
             i--;
             ActivityRecord r = list.get(i);
-            if (DEBUG_CLEANUP) Slog.v(TAG, "Record #" + i + " " + r);
+            if (DEBUG_CLEANUP) Log.d(TAG, "Record #" + i + " " + r);
             if (r.app == app) {
-                if (DEBUG_CLEANUP) Slog.v(TAG, "---> REMOVING this entry!");
+                if (DEBUG_CLEANUP) Log.d(TAG, "---> REMOVING this entry!");
                 list.remove(i);
                 removeTimeoutsForActivityLocked(r);
             }
@@ -2871,14 +3039,14 @@ final class ActivityStack {
 
         // Clean out the history list.
         int i = numActivities();
-        if (DEBUG_CLEANUP) Slog.v(
+        if (DEBUG_CLEANUP) Log.d(
             TAG, "Removing app " + app + " from history with " + i + " entries");
         for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
             final ArrayList<ActivityRecord> activities = mTaskHistory.get(taskNdx).mActivities;
             for (int activityNdx = activities.size() - 1; activityNdx >= 0; --activityNdx) {
                 final ActivityRecord r = activities.get(activityNdx);
                 --i;
-                if (DEBUG_CLEANUP) Slog.v(
+                if (DEBUG_CLEANUP) Log.d(
                     TAG, "Record #" + i + " " + r + ": app=" + r.app);
                 if (r.app == app) {
                     boolean remove;
@@ -2899,7 +3067,7 @@ final class ActivityStack {
                         if (DEBUG_ADD_REMOVE || DEBUG_CLEANUP) {
                             RuntimeException here = new RuntimeException("here");
                             here.fillInStackTrace();
-                            Slog.i(TAG, "Removing activity " + r + " from stack at " + i
+                            Log.d(TAG, "Removing activity " + r + " from stack at " + i
                                     + ": haveState=" + r.haveState
                                     + " stateNotNeeded=" + r.stateNotNeeded
                                     + " finishing=" + r.finishing
@@ -2920,17 +3088,17 @@ final class ActivityStack {
                     } else {
                         // We have the current state for this activity, so
                         // it can be restarted later when needed.
-                        if (localLOGV) Slog.v(
+                        if (localLOGV) Log.d(
                             TAG, "Keeping entry, setting app to null");
                         if (r.visible) {
                             hasVisibleActivities = true;
                         }
-                        if (DEBUG_APP) Slog.v(TAG, "Clearing app during removeHistory for activity "
+                        if (DEBUG_APP) Log.d(TAG, "Clearing app during removeHistory for activity "
                                 + r);
                         r.app = null;
                         r.nowVisible = false;
                         if (!r.haveState) {
-                            if (DEBUG_SAVED_STATE) Slog.i(TAG,
+                            if (DEBUG_SAVED_STATE) Log.d(TAG,
                                     "App died, clearing saved state of " + r);
                             r.icicle = null;
                         }
@@ -2961,7 +3129,7 @@ final class ActivityStack {
         for (int taskNdx = top; taskNdx >= 0; --taskNdx) {
             final TaskRecord task = mTaskHistory.get(taskNdx);
             if (task.isHomeTask()) {
-                if (DEBUG_TASKS || DEBUG_STACK) Slog.d(TAG, "moveHomeTaskToTop: moving " + task);
+                if (DEBUG_TASKS || DEBUG_STACK) Log.d(TAG, "moveHomeTaskToTop: moving " + task);
                 mTaskHistory.remove(taskNdx);
                 mTaskHistory.add(top, task);
                 mWindowManager.moveTaskToTop(task.taskId);
@@ -2971,6 +3139,7 @@ final class ActivityStack {
     }
 
     final boolean findTaskToMoveToFrontLocked(int taskId, int flags, Bundle options) {
+        Log.d(TAG,"Ritter::AS findTaskToMoveToFrontLocked() flags:"+flags);
         final TaskRecord task = taskForIdLocked(taskId);
         if (task != null) {
             if ((flags & ActivityManager.MOVE_TASK_NO_USER_ACTION) == 0) {
@@ -2981,6 +3150,15 @@ final class ActivityStack {
                 // we'll just indicate that this task returns to the home task.
                 task.mOnTopOfHome = true;
             }
+
+            //Ritter_multi
+            if ((flags & ActivityManager.MOVE_TASK_BACK_TASKS_INVISIBLE) != 0) {
+                Log.d(TAG,"Ritter::AS findTaskToMoveToFrontLocked() mStackSupervisor.mMoveTaskBackTaskInvisible = true");
+                mStackSupervisor.mMoveTaskBackTaskInvisible = true;
+            } else {
+                Log.d(TAG,"Ritter::AS findTaskToMoveToFrontLocked() mStackSupervisor.mMoveTaskBackTaskInvisible = false");
+            }
+
             moveTaskToFrontLocked(task, null, options);
             return true;
         }
@@ -2988,7 +3166,8 @@ final class ActivityStack {
     }
 
     final void moveTaskToFrontLocked(TaskRecord tr, ActivityRecord reason, Bundle options) {
-        if (DEBUG_SWITCH) Slog.v(TAG, "moveTaskToFront: " + tr);
+        Log.d(TAG,"Ritter::AS moveTaskToFrontLocked()");
+        if (DEBUG_SWITCH) Log.d(TAG, "moveTaskToFront: " + tr);
 
         final int numTasks = mTaskHistory.size();
         final int index = mTaskHistory.indexOf(tr);
@@ -3009,7 +3188,7 @@ final class ActivityStack {
         // of the stack, keeping them in the same internal order.
         insertTaskAtTop(tr);
 
-        if (DEBUG_TRANSITION) Slog.v(TAG, "Prepare to front transition: task=" + tr);
+        if (DEBUG_TRANSITION) Log.d(TAG, "Prepare to front transition: task=" + tr);
         if (reason != null &&
                 (reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
             mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false);
@@ -3044,7 +3223,8 @@ final class ActivityStack {
      * @return Returns true if the move completed, false if not.
      */
     final boolean moveTaskToBackLocked(int taskId, ActivityRecord reason) {
-        Slog.i(TAG, "moveTaskToBack: " + taskId);
+        Log.d(TAG,"Ritter::AMS moveTaskToBackLocked()");
+        Log.d(TAG, "moveTaskToBack: " + taskId);
 
         // If we have a watcher, preflight the move before committing to it.  First check
         // for *other* available tasks, but if none are available, then try again allowing the
@@ -3069,7 +3249,7 @@ final class ActivityStack {
             }
         }
 
-        if (DEBUG_TRANSITION) Slog.v(TAG,
+        if (DEBUG_TRANSITION) Log.d(TAG,
                 "Prepare to back transition: task=" + taskId);
 
         final TaskRecord tr = taskForIdLocked(taskId);
@@ -3141,27 +3321,28 @@ final class ActivityStack {
      */
     final boolean ensureActivityConfigurationLocked(ActivityRecord r,
             int globalChanges) {
+        Log.d(TAG,"Ritter::AS ensureActivityConfigurationLocked()");
         if (mConfigWillChange) {
-            if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
+            if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) Log.d(TAG,
                     "Skipping config check (will change): " + r);
             return true;
         }
 
-        if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
+        if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) Log.d(TAG,
                 "Ensuring correct configuration: " + r);
 
         // Short circuit: if the two configurations are the exact same
         // object (the common case), then there is nothing to do.
         Configuration newConfig = mService.mConfiguration;
         if (r.configuration == newConfig && !r.forceNewConfig) {
-            if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
+            if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) Log.d(TAG,
                     "Configuration unchanged in " + r);
             return true;
         }
 
         // We don't worry about activities that are finishing.
         if (r.finishing) {
-            if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
+            if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) Log.d(TAG,
                     "Configuration doesn't matter in finishing " + r);
             r.stopFreezingScreenLocked(false);
             return true;
@@ -3178,7 +3359,7 @@ final class ActivityStack {
         // activity and do nothing else.
         final int changes = oldConfig.diff(newConfig);
         if (changes == 0 && !r.forceNewConfig) {
-            if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
+            if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) Log.d(TAG,
                     "Configuration no differences in " + r);
             return true;
         }
@@ -3186,7 +3367,7 @@ final class ActivityStack {
         // If the activity isn't currently running, just leave the new
         // configuration and it will pick that up next time it starts.
         if (r.app == null || r.app.thread == null) {
-            if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
+            if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) Log.d(TAG,
                     "Configuration doesn't matter not running " + r);
             r.stopFreezingScreenLocked(false);
             r.forceNewConfig = false;
@@ -3194,8 +3375,8 @@ final class ActivityStack {
         }
 
         // Figure out how to handle the changes between the configurations.
-        if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
-            Slog.v(TAG, "Checking to restart " + r.info.name + ": changed=0x"
+        if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) {
+            Log.d(TAG, "Checking to restart " + r.info.name + ": changed=0x"
                     + Integer.toHexString(changes) + ", handles=0x"
                     + Integer.toHexString(r.info.getRealConfigChanged())
                     + ", newConfig=" + newConfig);
@@ -3206,14 +3387,14 @@ final class ActivityStack {
             r.startFreezingScreenLocked(r.app, globalChanges);
             r.forceNewConfig = false;
             if (r.app == null || r.app.thread == null) {
-                if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
+                if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) Log.d(TAG,
                         "Config is destroying non-running " + r);
                 destroyActivityLocked(r, true, false, "config");
             } else if (r.state == ActivityState.PAUSING) {
                 // A little annoying: we are waiting for this activity to
                 // finish pausing.  Let's not do anything now, but just
                 // flag that it needs to be restarted when done pausing.
-                if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
+                if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) Log.d(TAG,
                         "Config is skipping already pausing " + r);
                 r.configDestroy = true;
                 return true;
@@ -3222,12 +3403,12 @@ final class ActivityStack {
                 // and we need to restart the top, resumed activity.
                 // Instead of doing the normal handshaking, just say
                 // "restart!".
-                if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
+                if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) Log.d(TAG,
                         "Config is relaunching resumed " + r);
                 relaunchActivityLocked(r, r.configChangeFlags, true);
                 r.configChangeFlags = 0;
             } else {
-                if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
+                if (true||DEBUG_SWITCH || DEBUG_CONFIGURATION) Log.d(TAG,
                         "Config is relaunching non-resumed " + r);
                 relaunchActivityLocked(r, r.configChangeFlags, false);
                 r.configChangeFlags = 0;
@@ -3245,7 +3426,7 @@ final class ActivityStack {
         // it last got.
         if (r.app != null && r.app.thread != null) {
             try {
-                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Sending new config to " + r);
+                if (DEBUG_CONFIGURATION) Log.d(TAG, "Sending new config to " + r);
                 r.app.thread.scheduleActivityConfigurationChanged(r.appToken);
             } catch (RemoteException e) {
                 // If process died, whatever.
@@ -3264,7 +3445,7 @@ final class ActivityStack {
             results = r.results;
             newIntents = r.newIntents;
         }
-        if (DEBUG_SWITCH) Slog.v(TAG, "Relaunching: " + r
+        if (DEBUG_SWITCH) Log.d(TAG, "Relaunching: " + r
                 + " with results=" + results + " newIntents=" + newIntents
                 + " andResume=" + andResume);
         EventLog.writeEvent(andResume ? EventLogTags.AM_RELAUNCH_RESUME_ACTIVITY
@@ -3274,7 +3455,7 @@ final class ActivityStack {
         r.startFreezingScreenLocked(r.app, 0);
 
         try {
-            if (DEBUG_SWITCH || DEBUG_STATES) Slog.i(TAG,
+            if (DEBUG_SWITCH || DEBUG_STATES) Log.d(TAG,
                     (andResume ? "Relaunching to RESUMED " : "Relaunching to PAUSED ")
                     + r);
             r.forceNewConfig = false;
@@ -3284,7 +3465,7 @@ final class ActivityStack {
             // the caller will only pass in 'andResume' if this activity is
             // currently resumed, which implies we aren't sleeping.
         } catch (RemoteException e) {
-            if (DEBUG_SWITCH || DEBUG_STATES) Slog.i(TAG, "Relaunch failed", e);
+            if (DEBUG_SWITCH || DEBUG_STATES) Log.d(TAG, "Relaunch failed", e);
         }
 
         if (andResume) {
@@ -3349,7 +3530,7 @@ final class ActivityStack {
                         return true;
                     }
                     didSomething = true;
-                    Slog.i(TAG, "  Force finishing activity " + r);
+                    Log.d(TAG, "  Force finishing activity " + r);
                     if (samePackage) {
                         if (r.app != null) {
                             r.app.removed = true;
@@ -3394,7 +3575,7 @@ final class ActivityStack {
                     numRunning++;
                 }
 
-                if (localLOGV) Slog.v(
+                if (localLOGV) Log.d(
                     TAG, r.intent.getComponent().flattenToShortString()
                     + ": task=" + r.task);
             }
@@ -3413,7 +3594,7 @@ final class ActivityStack {
             //System.out.println(
             //    "#" + maxNum + ": " + " descr=" + ci.description);
             if (receiver != null) {
-                if (localLOGV) Slog.v(
+                if (localLOGV) Log.d(
                     TAG, "State=" + top.state + "Idle=" + top.idle
                     + " app=" + top.app
                     + " thr=" + (top.app != null ? top.app.thread : null));
@@ -3433,7 +3614,7 @@ final class ActivityStack {
 
     public void unhandledBackLocked() {
         final int top = mTaskHistory.size() - 1;
-        if (DEBUG_SWITCH) Slog.d(
+        if (DEBUG_SWITCH) Log.d(
             TAG, "Performing unhandledBack(): top activity at " + top);
         if (top >= 0) {
             final ArrayList<ActivityRecord> activities = mTaskHistory.get(top).mActivities;
@@ -3452,7 +3633,7 @@ final class ActivityStack {
      */
     boolean handleAppDiedLocked(ProcessRecord app) {
         if (mPausingActivity != null && mPausingActivity.app == app) {
-            if (DEBUG_PAUSE || DEBUG_CLEANUP) Slog.v(TAG,
+            if (DEBUG_PAUSE || DEBUG_CLEANUP) Log.d(TAG,
                     "App died while pausing: " + mPausingActivity);
             mPausingActivity = null;
         }
diff --git a/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java b/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
index 523015d..e564319 100644
--- a/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
+++ b/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
@@ -67,6 +67,7 @@ import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.UserHandle;
 import android.util.EventLog;
+import android.util.Log;
 import android.util.Slog;
 import android.util.SparseIntArray;
 
@@ -84,11 +85,11 @@ import java.util.ArrayList;
 import java.util.List;
 
 public final class ActivityStackSupervisor {
-    static final boolean DEBUG = ActivityManagerService.DEBUG || false;
+    static final boolean DEBUG = ActivityManagerService.DEBUG || true;
     static final boolean DEBUG_ADD_REMOVE = DEBUG || false;
     static final boolean DEBUG_APP = DEBUG || false;
     static final boolean DEBUG_SAVED_STATE = DEBUG || false;
-    static final boolean DEBUG_STATES = DEBUG || false;
+    static final boolean DEBUG_STATES = DEBUG || true;
     static final boolean DEBUG_IDLE = DEBUG || false;
 
     public static final int HOME_STACK_ID = 0;
@@ -206,6 +207,11 @@ public final class ActivityStackSupervisor {
     /** Stack id of the front stack when user switched, indexed by userId. */
     SparseIntArray mUserStackInFront = new SparseIntArray(2);
 
+    /** Ritter_multi
+     * A flag to indicate move task by touch situation.
+     **/
+    public boolean mMoveTaskBackTaskInvisible = false;
+
     public ActivityStackSupervisor(ActivityManagerService service, Context context,
             Looper looper) {
         mService = service;
@@ -237,21 +243,26 @@ public final class ActivityStackSupervisor {
     }
 
     ActivityStack getFocusedStack() {
+        Log.d(TAG,"Ritter::ASS getFocusedStack()");
         if (mFocusedStack == null) {
+            Log.d(TAG,"Ritter::ASS getFocusedStack() return HOME");
             return mHomeStack;
         }
         switch (mStackState) {
             case STACK_STATE_HOME_IN_FRONT:
             case STACK_STATE_HOME_TO_FRONT:
+                Log.d(TAG,"Ritter::ASS getFocusedStack() return HOME");
                 return mHomeStack;
             case STACK_STATE_HOME_IN_BACK:
             case STACK_STATE_HOME_TO_BACK:
             default:
+                Log.d(TAG,"Ritter::ASS getFocusedStack() return FOCUS");
                 return mFocusedStack;
         }
     }
 
     ActivityStack getLastStack() {
+        Log.d(TAG,"Ritter::ASS getLastStack() mFocusedStack:"+getFocusedStack().getStackId());
         switch (mStackState) {
             case STACK_STATE_HOME_IN_FRONT:
             case STACK_STATE_HOME_TO_BACK:
@@ -264,13 +275,14 @@ public final class ActivityStackSupervisor {
     }
 
     boolean isFrontStack(ActivityStack stack) {
+        Log.d(TAG,"Ritter::ASS isFrontStack()");
         return !(stack.isHomeStack() ^ getFocusedStack().isHomeStack());
     }
 
     void moveHomeStack(boolean toFront) {
         final boolean homeInFront = isFrontStack(mHomeStack);
         if (homeInFront ^ toFront) {
-            if (DEBUG_STACK) Slog.d(TAG, "moveHomeTask: mStackState old=" +
+            if (DEBUG_STACK) Log.d(TAG, "moveHomeTask: mStackState old=" +
                     stackStateToString(mStackState) + " new=" + stackStateToString(homeInFront ?
                     STACK_STATE_HOME_TO_BACK : STACK_STATE_HOME_TO_FRONT));
             mStackState = homeInFront ? STACK_STATE_HOME_TO_BACK : STACK_STATE_HOME_TO_FRONT;
@@ -332,6 +344,7 @@ public final class ActivityStackSupervisor {
     }
 
     void removeTask(TaskRecord task) {
+        Log.d(TAG,"Ritter::ASS removeTask() mFocusedStack:"+getFocusedStack().getStackId());
         mWindowManager.removeTask(task.taskId);
         final ActivityStack stack = task.stack;
         final ActivityRecord r = stack.mResumedActivity;
@@ -339,7 +352,7 @@ public final class ActivityStackSupervisor {
             stack.mResumedActivity = null;
         }
         if (stack.removeTask(task) && !stack.isHomeStack()) {
-            if (DEBUG_STACK) Slog.i(TAG, "removeTask: removing stack " + stack);
+            if (DEBUG_STACK) Log.d(TAG, "removeTask: removing stack " + stack);
             mStacks.remove(stack);
             final int stackId = stack.mStackId;
             final int nextStackId = mWindowManager.removeStack(stackId);
@@ -367,6 +380,7 @@ public final class ActivityStackSupervisor {
     }
 
     boolean attachApplicationLocked(ProcessRecord app, boolean headless) throws Exception {
+        Log.d(TAG,"Ritter::ASS attachApplicationLocked()");
         boolean didSomething = false;
         final String processName = app.processName;
         for (int stackNdx = mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
@@ -426,13 +440,13 @@ public final class ActivityStackSupervisor {
         // TODO: Not sure if this should check if all Paused are complete too.
         switch (mStackState) {
             case STACK_STATE_HOME_TO_BACK:
-                if (DEBUG_STACK) Slog.d(TAG, "allResumedActivitiesComplete: mStackState old=" +
+                if (DEBUG_STACK) Log.d(TAG, "allResumedActivitiesComplete: mStackState old=" +
                         stackStateToString(STACK_STATE_HOME_TO_BACK) + " new=" +
                         stackStateToString(STACK_STATE_HOME_IN_BACK));
                 mStackState = STACK_STATE_HOME_IN_BACK;
                 break;
             case STACK_STATE_HOME_TO_FRONT:
-                if (DEBUG_STACK) Slog.d(TAG, "allResumedActivitiesComplete: mStackState old=" +
+                if (DEBUG_STACK) Log.d(TAG, "allResumedActivitiesComplete: mStackState old=" +
                         stackStateToString(STACK_STATE_HOME_TO_FRONT) + " new=" +
                         stackStateToString(STACK_STATE_HOME_IN_FRONT));
                 mStackState = STACK_STATE_HOME_IN_FRONT;
@@ -459,10 +473,11 @@ public final class ActivityStackSupervisor {
      */
     boolean pauseBackStacks(boolean userLeaving) {
         boolean someActivityPaused = false;
+        //Ritter_Multi no modify
         for (int stackNdx = mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
             final ActivityStack stack = mStacks.get(stackNdx);
             if (!isFrontStack(stack) && stack.mResumedActivity != null) {
-                if (DEBUG_STATES) Slog.d(TAG, "pauseBackStacks: stack=" + stack +
+                if (true||DEBUG_STATES) Log.d(TAG, "pauseBackStacks: stack=" + stack +
                         " mResumedActivity=" + stack.mResumedActivity);
                 stack.startPausingLocked(userLeaving, false);
                 someActivityPaused = true;
@@ -480,7 +495,7 @@ public final class ActivityStackSupervisor {
                     && r.state != ActivityState.STOPPED
                     && r.state != ActivityState.STOPPING) {
                 if (DEBUG_STATES) {
-                    Slog.d(TAG, "allPausedActivitiesComplete: r=" + r + " state=" + r.state);
+                    Log.d(TAG, "allPausedActivitiesComplete: r=" + r + " state=" + r.state);
                     pausing = false;
                 } else {
                     return false;
@@ -519,9 +534,11 @@ public final class ActivityStackSupervisor {
     }
 
     ActivityRecord topRunningActivityLocked() {
+        Log.d(TAG,"Ritter::ASS BACK_KEY topRunningActivityLocked()");
         final ActivityStack focusedStack = getFocusedStack();
         ActivityRecord r = focusedStack.topRunningActivityLocked(null);
         if (r != null) {
+            Log.d(TAG,"Ritter::ASS BACK_KEY topRunningActivityLocked() return focusedStack");
             return r;
         }
 
@@ -530,6 +547,7 @@ public final class ActivityStackSupervisor {
             if (stack != focusedStack && isFrontStack(stack)) {
                 r = stack.topRunningActivityLocked(null);
                 if (r != null) {
+                    Log.d(TAG,"Ritter::ASS BACK_KEY topRunningActivityLocked() return !focusedStack");
                     return r;
                 }
             }
@@ -665,7 +683,7 @@ public final class ActivityStackSupervisor {
             final ActivityStack stack = getFocusedStack();
             stack.mConfigWillChange = config != null
                     && mService.mConfiguration.diff(config) != 0;
-            if (DEBUG_CONFIGURATION) Slog.v(TAG,
+            if (DEBUG_CONFIGURATION) Log.d(TAG,
                     "Starting activity when config will change = " + stack.mConfigWillChange);
 
             final long origId = Binder.clearCallingIdentity();
@@ -750,7 +768,7 @@ public final class ActivityStackSupervisor {
                 mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,
                         "updateConfiguration()");
                 stack.mConfigWillChange = false;
-                if (DEBUG_CONFIGURATION) Slog.v(TAG,
+                if (DEBUG_CONFIGURATION) Log.d(TAG,
                         "Updating to new configuration after starting activity.");
                 mService.updateConfigurationLocked(config, null, false, false);
             }
@@ -875,7 +893,8 @@ public final class ActivityStackSupervisor {
             throws RemoteException {
 
         r.startFreezingScreenLocked(app, 0);
-        if (false) Slog.d(TAG, "realStartActivity: setting app visibility true");
+        if (true) Log.d(TAG, "realStartActivity: setting app visibility true");
+        Log.d(TAG,"Ritter:ASS realStartActivityLocked: setAppVisibility true");
         mWindowManager.setAppVisibility(r.appToken, true);
 
         // schedule launch ticks to collect information about slow apps.
@@ -899,7 +918,7 @@ public final class ActivityStackSupervisor {
         r.launchCount++;
         r.lastLaunchTime = SystemClock.uptimeMillis();
 
-        if (localLOGV) Slog.v(TAG, "Launching: " + r);
+        if (localLOGV) Log.d(TAG, "Launching: " + r);
 
         int idx = app.activities.indexOf(r);
         if (idx < 0) {
@@ -918,7 +937,7 @@ public final class ActivityStackSupervisor {
                 results = r.results;
                 newIntents = r.newIntents;
             }
-            if (DEBUG_SWITCH) Slog.v(TAG, "Launching: " + r
+            if (DEBUG_SWITCH) Log.d(TAG, "Launching: " + r
                     + " icicle=" + r.icicle
                     + " with results=" + results + " newIntents=" + newIntents
                     + " andResume=" + andResume);
@@ -1024,7 +1043,7 @@ public final class ActivityStackSupervisor {
             // should look like we asked it to pause+stop (but remain visible),
             // and it has done so and reported back the current icicle and
             // other state.
-            if (DEBUG_STATES) Slog.v(TAG, "Moving to STOPPED: " + r
+            if (DEBUG_STATES) Log.d(TAG, "Moving to STOPPED: " + r
                     + " (starting in stopped state)");
             r.state = ActivityState.STOPPED;
             r.stopped = true;
@@ -1043,6 +1062,7 @@ public final class ActivityStackSupervisor {
 
     void startSpecificActivityLocked(ActivityRecord r,
             boolean andResume, boolean checkConfig) {
+        Log.d(TAG,"Ritter::ASS startSpecificActivityLocked() r.processName:"+r.processName);
         // Is this activity's application already running?
         ProcessRecord app = mService.getProcessRecordLocked(r.processName,
                 r.info.applicationInfo.uid, true);
@@ -1072,6 +1092,7 @@ public final class ActivityStackSupervisor {
             String resultWho, int requestCode,
             int callingPid, int callingUid, String callingPackage, int startFlags, Bundle options,
             boolean componentSpecified, ActivityRecord[] outActivity) {
+        Log.d(TAG,"Ritter::ASS startActivityLocked()");
         int err = ActivityManager.START_SUCCESS;
 
         ProcessRecord callerApp = null;
@@ -1090,7 +1111,7 @@ public final class ActivityStackSupervisor {
 
         if (err == ActivityManager.START_SUCCESS) {
             final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
-            Slog.i(TAG, "START u" + userId + " {" + intent.toShortString(true, true, true, false)
+            Log.d(TAG, "START u" + userId + " {" + intent.toShortString(true, true, true, false)
                     + "} from pid " + (callerApp != null ? callerApp.pid : callingPid));
         }
 
@@ -1098,7 +1119,7 @@ public final class ActivityStackSupervisor {
         ActivityRecord resultRecord = null;
         if (resultTo != null) {
             sourceRecord = isInAnyStackLocked(resultTo);
-            if (DEBUG_RESULTS) Slog.v(
+            if (DEBUG_RESULTS) Log.d(
                 TAG, "Will send result to " + resultTo + " " + sourceRecord);
             if (sourceRecord != null) {
                 if (requestCode >= 0 && !sourceRecord.finishing) {
@@ -1251,22 +1272,26 @@ public final class ActivityStackSupervisor {
     }
 
     ActivityStack adjustStackFocus(ActivityRecord r) {
+        Log.d(TAG,"Ritter::ASS adjustStackFocus() mFocusedStack:"+getFocusedStack().getStackId());
         final TaskRecord task = r.task;
-        if (r.isApplicationActivity() || (task != null && task.isApplicationTask())) {
+        if (r.isApplicationActivity() || (task != null && task.isApplicationTask())
+                //Ritter_multi make RecentApp stays in APP stack
+                ||r.isRecentsActivity()
+                ) {
             if (task != null) {
                 if (mFocusedStack != task.stack) {
-                    if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG,
+                    if (DEBUG_FOCUS || DEBUG_STACK) Log.d(TAG,
                             "adjustStackFocus: Setting focused stack to r=" + r + " task=" + task);
                     mFocusedStack = task.stack;
                 } else {
-                    if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG,
+                    if (DEBUG_FOCUS || DEBUG_STACK) Log.d(TAG,
                         "adjustStackFocus: Focused stack already=" + mFocusedStack);
                 }
                 return mFocusedStack;
             }
 
             if (mFocusedStack != null) {
-                if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG,
+                if (DEBUG_FOCUS || DEBUG_STACK) Log.d(TAG,
                         "adjustStackFocus: Have a focused stack=" + mFocusedStack);
                 return mFocusedStack;
             }
@@ -1274,7 +1299,7 @@ public final class ActivityStackSupervisor {
             for (int stackNdx = mStacks.size() - 1; stackNdx > 0; --stackNdx) {
                 ActivityStack stack = mStacks.get(stackNdx);
                 if (!stack.isHomeStack()) {
-                    if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG,
+                    if (DEBUG_FOCUS || DEBUG_STACK) Log.d(TAG,
                             "adjustStackFocus: Setting focused stack=" + stack);
                     mFocusedStack = stack;
                     return mFocusedStack;
@@ -1284,7 +1309,7 @@ public final class ActivityStackSupervisor {
             // Time to create the first app stack for this user.
             int stackId = mService.createStack(-1, HOME_STACK_ID,
                 StackBox.TASK_STACK_GOES_OVER, 1.0f);
-            if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG, "adjustStackFocus: New stack r=" + r +
+            if (DEBUG_FOCUS || DEBUG_STACK) Log.d(TAG, "adjustStackFocus: New stack r=" + r +
                     " stackId=" + stackId);
             mFocusedStack = getStack(stackId);
             return mFocusedStack;
@@ -1293,24 +1318,32 @@ public final class ActivityStackSupervisor {
     }
 
     void setFocusedStack(ActivityRecord r) {
+        Log.d(TAG,"Ritter::ASS BACK_KEY setFocusedStack()");
+        Log.d(TAG,"Ritter::ASS setFocusedStack() mFocusedStack:"+getFocusedStack().getStackId());
         if (r == null) {
             return;
         }
-        if (!r.isApplicationActivity() || (r.task != null && !r.task.isApplicationTask())) {
+        //Ritter_multi old
+//        if (!r.isApplicationActivity() || (r.task != null && !r.task.isApplicationTask())) {
+
+        //Ritter_multi new
+        if ((!r.isApplicationActivity() || (r.task != null && !r.task.isApplicationTask()))
+                //Ritter_multi RecentApp's focused stack is APP stack
+                &&!r.isRecentsActivity()) {
             if (mStackState != STACK_STATE_HOME_IN_FRONT) {
-                if (DEBUG_STACK || DEBUG_FOCUS) Slog.d(TAG, "setFocusedStack: mStackState old=" +
+                if (DEBUG_STACK || DEBUG_FOCUS) Log.d(TAG, "setFocusedStack: mStackState old=" +
                         stackStateToString(mStackState) + " new=" +
                         stackStateToString(STACK_STATE_HOME_TO_FRONT) +
                         " Callers=" + Debug.getCallers(3));
                 mStackState = STACK_STATE_HOME_TO_FRONT;
             }
         } else {
-            if (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG,
+            if (DEBUG_FOCUS || DEBUG_STACK) Log.d(TAG,
                     "setFocusedStack: Setting focused stack to r=" + r + " task=" + r.task +
                     " Callers=" + Debug.getCallers(3));
             mFocusedStack = r.task.stack;
             if (mStackState != STACK_STATE_HOME_IN_BACK) {
-                if (DEBUG_STACK) Slog.d(TAG, "setFocusedStack: mStackState old=" +
+                if (DEBUG_STACK) Log.d(TAG, "setFocusedStack: mStackState old=" +
                         stackStateToString(mStackState) + " new=" +
                         stackStateToString(STACK_STATE_HOME_TO_BACK) +
                         " Callers=" + Debug.getCallers(3));
@@ -1322,6 +1355,7 @@ public final class ActivityStackSupervisor {
     final int startActivityUncheckedLocked(ActivityRecord r,
             ActivityRecord sourceRecord, int startFlags, boolean doResume,
             Bundle options) {
+        Log.d(TAG,"Ritter:ASS startActivityUncheckedLocked() r.packageName:"+r.packageName);
         final Intent intent = r.intent;
         final int callingUid = r.launchedFromUid;
 
@@ -1330,7 +1364,7 @@ public final class ActivityStackSupervisor {
         // We'll invoke onUserLeaving before onPause only if the launching
         // activity did not explicitly state that this is an automated launch.
         mUserLeaving = (launchFlags&Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
-        if (DEBUG_USER_LEAVING) Slog.v(TAG, "startActivity() => mUserLeaving=" + mUserLeaving);
+        if (DEBUG_USER_LEAVING) Log.d(TAG, "startActivity() => mUserLeaving=" + mUserLeaving);
 
         // If the caller has asked not to resume at this point, we make note
         // of this in the record so that we can skip it when trying to find
@@ -1435,9 +1469,16 @@ public final class ActivityStackSupervisor {
                     }
                     targetStack = intentActivity.task.stack;
                     targetStack.mLastPausedActivity = null;
-                    if (DEBUG_TASKS) Slog.d(TAG, "Bring to front target: " + targetStack
+                    if (DEBUG_TASKS) Log.d(TAG, "Bring to front target: " + targetStack
                             + " from " + intentActivity);
+                    //Ritter_multi old
                     moveHomeStack(targetStack.isHomeStack());
+
+                    //Ritter_multi new
+//                    if(!r.packageName.equals("com.android.systemui")){
+//                        moveHomeStack(targetStack.isHomeStack());
+//                    }
+
                     if (intentActivity.task.intent == null) {
                         // This task was started because of movement of
                         // the activity based on affinity...  now that we
@@ -1487,7 +1528,7 @@ public final class ActivityStackSupervisor {
                         } else {
                             ActivityOptions.abort(options);
                         }
-                        if (r.task == null)  Slog.v(TAG,
+                        if (r.task == null)  Log.d(TAG,
                                 "startActivityUncheckedLocked: task left null",
                                 new RuntimeException("here").fillInStackTrace());
                         return ActivityManager.START_RETURN_INTENT_TO_CALLER;
@@ -1582,7 +1623,7 @@ public final class ActivityStackSupervisor {
                         } else {
                             ActivityOptions.abort(options);
                         }
-                        if (r.task == null)  Slog.v(TAG,
+                        if (r.task == null)  Log.d(TAG,
                             "startActivityUncheckedLocked: task left null",
                             new RuntimeException("here").fillInStackTrace());
                         return ActivityManager.START_TASK_TO_FRONT;
@@ -1593,9 +1634,9 @@ public final class ActivityStackSupervisor {
 
         //String uri = r.intent.toURI();
         //Intent intent2 = new Intent(uri);
-        //Slog.i(TAG, "Given intent: " + r.intent);
-        //Slog.i(TAG, "URI is: " + uri);
-        //Slog.i(TAG, "To intent: " + intent2);
+        //Log.d(TAG, "Given intent: " + r.intent);
+        //Log.d(TAG, "URI is: " + uri);
+        //Log.d(TAG, "To intent: " + intent2);
 
         if (r.packageName != null) {
             // If the activity being launched is the same as the one currently
@@ -1622,13 +1663,13 @@ public final class ActivityStackSupervisor {
                                 // We don't need to start a new activity, and
                                 // the client said not to do anything if that
                                 // is the case, so this is it!
-                                if (r.task == null)  Slog.v(TAG,
+                                if (r.task == null)  Log.d(TAG,
                                     "startActivityUncheckedLocked: task left null",
                                     new RuntimeException("here").fillInStackTrace());
                                 return ActivityManager.START_RETURN_INTENT_TO_CALLER;
                             }
                             top.deliverNewIntentLocked(callingUid, r.intent);
-                            if (r.task == null)  Slog.v(TAG,
+                            if (r.task == null)  Log.d(TAG,
                                 "startActivityUncheckedLocked: task left null",
                                 new RuntimeException("here").fillInStackTrace());
                             return ActivityManager.START_DELIVERED_TO_TOP;
@@ -1643,7 +1684,7 @@ public final class ActivityStackSupervisor {
                         r.requestCode, Activity.RESULT_CANCELED, null);
             }
             ActivityOptions.abort(options);
-            if (r.task == null)  Slog.v(TAG,
+            if (r.task == null)  Log.d(TAG,
                 "startActivityUncheckedLocked: task left null",
                 new RuntimeException("here").fillInStackTrace());
             return ActivityManager.START_CLASS_NOT_FOUND;
@@ -1656,11 +1697,17 @@ public final class ActivityStackSupervisor {
         if (r.resultTo == null && !addingToTask
                 && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
             targetStack = adjustStackFocus(r);
+            //Ritter_multi old
             moveHomeStack(targetStack.isHomeStack());
+            //Ritter_multi new
+//            if(!r.packageName.equals("com.android.systemui")){
+//                moveHomeStack(targetStack.isHomeStack());
+//            }
+
             if (reuseTask == null) {
                 r.setTask(targetStack.createTaskRecord(getNextTaskId(), r.info, intent, true),
                         null, true);
-                if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r + " in new task " +
+                if (DEBUG_TASKS) Log.d(TAG, "Starting new activity " + r + " in new task " +
                         r.task);
             } else {
                 r.setTask(reuseTask, reuseTask, true);
@@ -1724,7 +1771,7 @@ public final class ActivityStackSupervisor {
             // to keep the new one in the same task as the one that is starting
             // it.
             r.setTask(sourceTask, sourceRecord.thumbHolder, false);
-            if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
+            if (DEBUG_TASKS) Log.d(TAG, "Starting new activity " + r
                     + " in existing task " + r.task + " from source " + sourceRecord);
 
         } else {
@@ -1737,7 +1784,7 @@ public final class ActivityStackSupervisor {
             r.setTask(prev != null ? prev.task
                     : targetStack.createTaskRecord(getNextTaskId(), r.info, intent, true),
                     null, true);
-            if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
+            if (DEBUG_TASKS) Log.d(TAG, "Starting new activity " + r
                     + " in new guessed " + r.task);
         }
 
@@ -1768,7 +1815,7 @@ public final class ActivityStackSupervisor {
     // Checked.
     final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout,
             Configuration config) {
-        if (localLOGV) Slog.v(TAG, "Activity idle: " + token);
+        if (true||localLOGV) Log.d(TAG, "Ritter::ASS activityIdleInternalLocked() Activity idle: " + token + ",fromTimeout:"+fromTimeout);
 
         ArrayList<ActivityRecord> stops = null;
         ArrayList<ActivityRecord> finishes = null;
@@ -1782,7 +1829,7 @@ public final class ActivityStackSupervisor {
 
         ActivityRecord r = ActivityRecord.forToken(token);
         if (r != null) {
-            if (DEBUG_IDLE) Slog.d(TAG, "activityIdleInternalLocked: Callers=" +
+            if (DEBUG_IDLE) Log.d(TAG, "activityIdleInternalLocked: Callers=" +
                     Debug.getCallers(4));
             mHandler.removeMessages(IDLE_TIMEOUT_MSG, r);
             r.finishLaunchTickingLocked();
@@ -1808,7 +1855,7 @@ public final class ActivityStackSupervisor {
                 r.thumbnailNeeded = false;
             }
 
-            //Slog.i(TAG, "IDLE: mBooted=" + mBooted + ", fromTimeout=" + fromTimeout);
+            //Log.d(TAG, "IDLE: mBooted=" + mBooted + ", fromTimeout=" + fromTimeout);
             if (!mService.mBooted && isFrontStack(r.task.stack)) {
                 mService.mBooted = true;
                 enableScreen = true;
@@ -1831,9 +1878,22 @@ public final class ActivityStackSupervisor {
             ensureActivitiesVisibleLocked(null, 0);
         }
 
+        /** Ritter_multi
+         *  After moveTaskToFront() triggered by touch finish,
+         *  set mMoveTaskBackTaskInvisible=false to make the
+         *  ensureActivitiesVisibleLocked() works normal.
+         */
+        mMoveTaskBackTaskInvisible = false;
+
         // Atomically retrieve all of the other things to do.
         stops = processStoppingActivitiesLocked(true);
+        if(stops!=null){
+            Log.d(TAG,"Ritter::ASS activityIdleInternalLocked: stops.size:"+stops.size());
+        }else{
+            Log.d(TAG,"Ritter::ASS activityIdleInternalLocked: stops==null");
+        }
         NS = stops != null ? stops.size() : 0;
+        Log.d(TAG,"Ritter::ASS activityIdleInternalLocked: NS:"+NS);
         if ((NF=mFinishingActivities.size()) > 0) {
             finishes = new ArrayList<ActivityRecord>(mFinishingActivities);
             mFinishingActivities.clear();
@@ -1882,12 +1942,18 @@ public final class ActivityStackSupervisor {
 
         // Stop any activities that are scheduled to do so but have been
         // waiting for the next one to start.
+        Log.d(TAG,"Ritter::ASS activityIdleInternalLocked: NS:"+NS);
+        Log.d(TAG,"Ritter::ASS activityIdleInternalLocked: Stop any activities that are scheduled to do so but have been");
+        Log.d(TAG,"Ritter::ASS activityIdleInternalLocked: waiting for the next one to start");
         for (int i = 0; i < NS; i++) {
             r = stops.get(i);
             final ActivityStack stack = r.task.stack;
             if (r.finishing) {
+                Log.d(TAG,"Ritter::ASS stack.finishCurrentActivityLocked NS:"+NS);
                 stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false);
             } else {
+                Log.d(TAG,"Ritter::ASS stack.stopActivityLocked NS:"+NS);
+                //Ritter_Multi no modify
                 stack.stopActivityLocked(r);
             }
         }
@@ -1989,21 +2055,29 @@ public final class ActivityStackSupervisor {
     }
 
     boolean resumeTopActivitiesLocked() {
+        Log.d(TAG,"Ritter::ASS resumeTopActivitiesLocked()");
         return resumeTopActivitiesLocked(null, null, null);
     }
 
     boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,
             Bundle targetOptions) {
+        Log.d(TAG,"Ritter::ASS resumeTopActivitiesLocked()2");
         if (targetStack == null) {
+            Log.d(TAG,"Ritter::ASS resumeTopActivitiesLocked()2 targetStack == null");
             targetStack = getFocusedStack();
         }
+        Log.d(TAG,"Ritter::ASS resumeTopActivitiesLocked()2 targetStack.getStackId:"+targetStack.getStackId());
         boolean result = false;
         for (int stackNdx = mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
             final ActivityStack stack = mStacks.get(stackNdx);
+            //Ritter_multi no matter front stack or not, let other tasks resume
             if (isFrontStack(stack)) {
+                Log.d(TAG,"Ritter::ASS resumeTopActivitiesLocked()2 isFrontStack(stack)");
                 if (stack == targetStack) {
+                    Log.d(TAG,"Ritter::ASS resumeTopActivitiesLocked()2 stack == targetStack stack.id:"+stack.getStackId());
                     result = stack.resumeTopActivityLocked(target, targetOptions);
                 } else {
+                    Log.d(TAG,"Ritter::ASS resumeTopActivitiesLocked()2 stack != targetStack stack.id:"+stack.getStackId());
                     stack.resumeTopActivityLocked(null);
                 }
             }
@@ -2020,9 +2094,10 @@ public final class ActivityStackSupervisor {
     }
 
     void findTaskToMoveToFrontLocked(int taskId, int flags, Bundle options) {
+        Log.d(TAG, "Ritter::ASS findTaskToMoveToFrontLocked flags:"+flags);
         for (int stackNdx = mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
             if (mStacks.get(stackNdx).findTaskToMoveToFrontLocked(taskId, flags, options)) {
-                if (DEBUG_STACK) Slog.d(TAG, "findTaskToMoveToFront: moved to front of stack=" +
+                if (DEBUG_STACK) Log.d(TAG, "findTaskToMoveToFront: moved to front of stack=" +
                         mStacks.get(stackNdx));
                 return;
             }
@@ -2057,6 +2132,7 @@ public final class ActivityStackSupervisor {
     }
 
     void moveTaskToStack(int taskId, int stackId, boolean toTop) {
+        Log.d(TAG,"Ritter::ASS moveTaskToStack()");
         final TaskRecord task = anyTaskForIdLocked(taskId);
         if (task == null) {
             return;
@@ -2073,11 +2149,11 @@ public final class ActivityStackSupervisor {
     }
 
     ActivityRecord findTaskLocked(ActivityRecord r) {
-        if (DEBUG_TASKS) Slog.d(TAG, "Looking for task of " + r);
+        if (DEBUG_TASKS) Log.d(TAG, "Looking for task of " + r);
         for (int stackNdx = mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
             final ActivityStack stack = mStacks.get(stackNdx);
             if (!r.isApplicationActivity() && !stack.isHomeStack()) {
-                if (DEBUG_TASKS) Slog.d(TAG, "Skipping stack: " + stack);
+                if (DEBUG_TASKS) Log.d(TAG, "Skipping stack: " + stack);
                 continue;
             }
             final ActivityRecord ar = stack.findTaskLocked(r);
@@ -2085,7 +2161,7 @@ public final class ActivityStackSupervisor {
                 return ar;
             }
         }
-        if (DEBUG_TASKS) Slog.d(TAG, "No task found");
+        if (DEBUG_TASKS) Log.d(TAG, "No task found");
         return null;
     }
 
@@ -2149,6 +2225,7 @@ public final class ActivityStackSupervisor {
     }
 
     void comeOutOfSleepIfNeededLocked() {
+        Log.d(TAG,"Ritter::ASS comeOutOfSleepIfNeededLocked()");
         removeSleepTimeouts();
         if (mGoingToSleep.isHeld()) {
             mGoingToSleep.release();
@@ -2182,7 +2259,7 @@ public final class ActivityStackSupervisor {
 
             if (mStoppingActivities.size() > 0) {
                 // Still need to tell some activities to stop; can't sleep yet.
-                if (DEBUG_PAUSE) Slog.v(TAG, "Sleep still need to stop "
+                if (DEBUG_PAUSE) Log.d(TAG, "Sleep still need to stop "
                         + mStoppingActivities.size() + " activities");
                 scheduleIdleLocked();
                 dontSleep = true;
@@ -2190,7 +2267,7 @@ public final class ActivityStackSupervisor {
 
             if (mGoingToSleepActivities.size() > 0) {
                 // Still need to tell some activities to sleep; can't sleep yet.
-                if (DEBUG_PAUSE) Slog.v(TAG, "Sleep still need to sleep "
+                if (DEBUG_PAUSE) Log.d(TAG, "Sleep still need to sleep "
                         + mGoingToSleepActivities.size() + " activities");
                 dontSleep = true;
             }
@@ -2215,6 +2292,7 @@ public final class ActivityStackSupervisor {
     }
 
     boolean reportResumedActivityLocked(ActivityRecord r) {
+        Log.d(TAG,"Ritter::ASS reportResumedActivityLocked()");
         final ActivityStack stack = r.task.stack;
         if (isFrontStack(stack)) {
             mService.updateUsageStats(r, true);
@@ -2236,15 +2314,32 @@ public final class ActivityStackSupervisor {
     }
 
     void ensureActivitiesVisibleLocked(ActivityRecord starting, int configChanges) {
+        Log.d(TAG,"Ritter::ASS ensureActivitiesVisibleLocked()");
+
+        //Ritter_multi
+//        if(starting.packageName.equals("com.android.systemui")){
+//            Log.d(TAG,"Ritter::ASS ensureActivitiesVisibleLocked() starting.packageName.equals(com.android.systemui) return");
+//            return;
+//        }
+        if(starting != null && starting.packageName!=null){
+            Log.d(TAG,"Ritter::ASS ensureActivitiesVisibleLocked() starting pkgName:"+starting.packageName);
+        }else{
+            Log.d(TAG,"Ritter::ASS ensureActivitiesVisibleLocked() starting != null && starting.packageName!=null");
+        }
+
         // First the front stacks. In case any are not fullscreen and are in front of home.
         boolean showHomeBehindStack = false;
         for (int stackNdx = mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
+            Log.d(TAG,"Ritter::ASS ensureActivitiesVisibleLocked:stackNdx:"+stackNdx+",---------");
             final ActivityStack stack = mStacks.get(stackNdx);
             if (isFrontStack(stack)) {
+                Log.d(TAG,"Ritter::ASS ensureActivitiesVisibleLocked: isFrontStack(stack)==true");
                 showHomeBehindStack =
                         stack.ensureActivitiesVisibleLocked(starting, configChanges);
+                Log.d(TAG,"Ritter::ASS ensureActivitiesVisibleLocked: isFrontStack:showHomeBehindStack:"+showHomeBehindStack);
             }
         }
+        Log.d(TAG,"Ritter::ASS ensureActivitiesVisibleLocked: showHomeBehindStack:"+showHomeBehindStack);
         // Now do back stacks.
         for (int stackNdx = mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
             final ActivityStack stack = mStacks.get(stackNdx);
@@ -2283,6 +2378,7 @@ public final class ActivityStackSupervisor {
     }
 
     final ArrayList<ActivityRecord> processStoppingActivitiesLocked(boolean remove) {
+        Log.d(TAG,"Ritter::ASS processStoppingActivitiesLocked()");
         int N = mStoppingActivities.size();
         if (N <= 0) return null;
 
@@ -2291,7 +2387,7 @@ public final class ActivityStackSupervisor {
         final boolean nowVisible = allResumedActivitiesVisible();
         for (int i=0; i<N; i++) {
             ActivityRecord s = mStoppingActivities.get(i);
-            if (localLOGV) Slog.v(TAG, "Stopping " + s + ": nowVisible="
+            if (true||localLOGV) Log.d(TAG, "Ritter::ASS processStoppingActivitiesLocked:Stopping " + s + ": nowVisible="
                     + nowVisible + " waitingVisible=" + s.waitingVisible
                     + " finishing=" + s.finishing);
             if (s.waitingVisible && nowVisible) {
@@ -2303,12 +2399,13 @@ public final class ActivityStackSupervisor {
                     // so get rid of it.  Otherwise, we need to go through the
                     // normal flow and hide it once we determine that it is
                     // hidden by the activities in front of it.
-                    if (localLOGV) Slog.v(TAG, "Before stopping, can hide: " + s);
+                    if (true||localLOGV) Log.d(TAG, "Before stopping, can hide: " + s);
+                    Log.d(TAG,"Ritter::ASS processStoppingActivitiesLocked: setAppVisibility false 1");
                     mWindowManager.setAppVisibility(s.appToken, false);
                 }
             }
             if ((!s.waitingVisible || mService.isSleepingOrShuttingDown()) && remove) {
-                if (localLOGV) Slog.v(TAG, "Ready to stop: " + s);
+                if (localLOGV) Log.d(TAG, "Ready to stop: " + s);
                 if (stops == null) {
                     stops = new ArrayList<ActivityRecord>();
                 }
@@ -2535,7 +2632,7 @@ public final class ActivityStackSupervisor {
     }
 
     void scheduleIdleTimeoutLocked(ActivityRecord next) {
-        if (DEBUG_IDLE) Slog.d(TAG, "scheduleIdleTimeoutLocked: Callers=" + Debug.getCallers(4));
+        if (DEBUG_IDLE) Log.d(TAG, "scheduleIdleTimeoutLocked: Callers=" + Debug.getCallers(4));
         Message msg = mHandler.obtainMessage(IDLE_TIMEOUT_MSG, next);
         mHandler.sendMessageDelayed(msg, IDLE_TIMEOUT);
     }
@@ -2545,11 +2642,12 @@ public final class ActivityStackSupervisor {
     }
 
     void removeTimeoutsForActivityLocked(ActivityRecord r) {
-        if (DEBUG_IDLE) Slog.d(TAG, "removeTimeoutsForActivity: Callers=" + Debug.getCallers(4));
+        if (DEBUG_IDLE) Log.d(TAG, "removeTimeoutsForActivity: Callers=" + Debug.getCallers(4));
         mHandler.removeMessages(IDLE_TIMEOUT_MSG, r);
     }
 
     final void scheduleResumeTopActivities() {
+        Log.d(TAG,"Ritter:ASS scheduleResumeTopActivities()");
         mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
     }
 
@@ -2579,7 +2677,7 @@ public final class ActivityStackSupervisor {
         public void handleMessage(Message msg) {
             switch (msg.what) {
                 case IDLE_TIMEOUT_MSG: {
-                    if (DEBUG_IDLE) Slog.d(TAG, "handleMessage: IDLE_TIMEOUT_MSG: r=" + msg.obj);
+                    if (true||DEBUG_IDLE) Log.d(TAG, "Ritter::ASS ActivityStackSupervisorHandler.handleMessage: IDLE_TIMEOUT_MSG: r=" + msg.obj);
                     if (mService.mDidDexOpt) {
                         mService.mDidDexOpt = false;
                         Message nmsg = mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
@@ -2592,7 +2690,7 @@ public final class ActivityStackSupervisor {
                     activityIdleInternal((ActivityRecord)msg.obj);
                 } break;
                 case IDLE_NOW_MSG: {
-                    if (DEBUG_IDLE) Slog.d(TAG, "handleMessage: IDLE_NOW_MSG: r=" + msg.obj);
+                    if (DEBUG_IDLE) Log.d(TAG, "handleMessage: IDLE_NOW_MSG: r=" + msg.obj);
                     activityIdleInternal((ActivityRecord)msg.obj);
                 } break;
                 case RESUME_TOP_ACTIVITY_MSG: {
diff --git a/frameworks/base/services/java/com/android/server/am/CompatModePackages.java b/frameworks/base/services/java/com/android/server/am/CompatModePackages.java
index 59e6787..d554019 100644
--- a/frameworks/base/services/java/com/android/server/am/CompatModePackages.java
+++ b/frameworks/base/services/java/com/android/server/am/CompatModePackages.java
@@ -22,6 +22,7 @@ import android.os.Handler;
 import android.os.Message;
 import android.os.RemoteException;
 import android.util.AtomicFile;
+import android.util.Log;
 import android.util.Slog;
 import android.util.Xml;
 
@@ -241,6 +242,7 @@ public final class CompatModePackages {
     }
 
     private void setPackageScreenCompatModeLocked(ApplicationInfo ai, int mode) {
+        Log.d(TAG,"Ritter::CMP setPackageScreenCompatModeLocked()");
         final String packageName = ai.packageName;
 
         int curFlags = getPackageFlags(packageName);
diff --git a/frameworks/base/services/java/com/android/server/am/TaskRecord.java b/frameworks/base/services/java/com/android/server/am/TaskRecord.java
index 3d568ff..79bf109 100644
--- a/frameworks/base/services/java/com/android/server/am/TaskRecord.java
+++ b/frameworks/base/services/java/com/android/server/am/TaskRecord.java
@@ -28,6 +28,7 @@ import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.graphics.Bitmap;
 import android.os.UserHandle;
+import android.util.Log;
 import android.util.Slog;
 
 import java.io.PrintWriter;
@@ -150,6 +151,7 @@ final class TaskRecord extends ThumbnailHolder {
     }
 
     ActivityRecord topRunningActivityLocked(ActivityRecord notTop) {
+        Log.d(TAG,"Ritter::TR  BACK_KEY topRunningActivityLocked()");
         for (int activityNdx = mActivities.size() - 1; activityNdx >= 0; --activityNdx) {
             ActivityRecord r = mActivities.get(activityNdx);
             if (!r.finishing && r != notTop && stack.okToShow(r)) {
diff --git a/frameworks/base/services/java/com/android/server/wm/InputMonitor.java b/frameworks/base/services/java/com/android/server/wm/InputMonitor.java
index 3d2ec45..ee6df40 100644
--- a/frameworks/base/services/java/com/android/server/wm/InputMonitor.java
+++ b/frameworks/base/services/java/com/android/server/wm/InputMonitor.java
@@ -33,6 +33,7 @@ import android.view.WindowManager;
 import java.util.Arrays;
 
 final class InputMonitor implements InputManagerService.WindowManagerCallbacks {
+    static final String TAG = "InputMonitor";
     private final WindowManagerService mService;
     
     // Current window with input focus for keys and other non-touch events.  May be null.
@@ -168,15 +169,21 @@ final class InputMonitor implements InputManagerService.WindowManagerCallbacks {
     private void addInputWindowHandleLw(final InputWindowHandle inputWindowHandle,
             final WindowState child, int flags, int privateFlags, final int type,
             final boolean isVisible, final boolean hasFocus, final boolean hasWallpaper) {
+        Log.d(TAG,"Ritter::addInputWindowHandleLw() inputWindowHandle.name:"+child.toString());
         // Add a window to our list of input windows.
         inputWindowHandle.name = child.toString();
         final boolean modal = (flags & (WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                 | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) == 0;
         if (modal && child.mAppToken != null) {
+            Log.d(TAG,"Ritter::addInputWindowHandleLw() aaa");
             // Limit the outer touch to the activity stack region.
             flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;
-            inputWindowHandle.touchableRegion.set(child.getStackBounds());
+
+            // Ritter_Multi
+//            inputWindowHandle.touchableRegion.set(child.getStackBounds());
+            inputWindowHandle.touchableRegion.set(child.mFrame);
         } else {
+            Log.d(TAG,"Ritter::addInputWindowHandleLw() bbb");
             // Not modal or full screen modal
             child.getTouchableRegion(inputWindowHandle.touchableRegion);
         }
@@ -199,7 +206,8 @@ final class InputMonitor implements InputManagerService.WindowManagerCallbacks {
         inputWindowHandle.frameTop = frame.top;
         inputWindowHandle.frameRight = frame.right;
         inputWindowHandle.frameBottom = frame.bottom;
-
+        Log.d(TAG,"Ritter::addInputWindowHandleLw() inputWindowHandle.l:"+frame.left
+                +",r:"+frame.right+",t:"+frame.top+",b:"+frame.bottom);
         if (child.mGlobalScale != 1) {
             // If we are scaling the window, input coordinates need
             // to be inversely scaled to map from what is on screen
@@ -225,6 +233,7 @@ final class InputMonitor implements InputManagerService.WindowManagerCallbacks {
 
     /* Updates the cached window information provided to the input dispatcher. */
     public void updateInputWindowsLw(boolean force) {
+        Log.d(TAG,"Ritter::updateInputWindowsLw()");
         if (!force && !mUpdateInputWindowsNeeded) {
             return;
         }
@@ -263,17 +272,20 @@ final class InputMonitor implements InputManagerService.WindowManagerCallbacks {
 
         // Add all windows on the default display.
         final int numDisplays = mService.mDisplayContents.size();
+        Log.d(TAG,"Ritter::updateInputWindowsLw() Add all windows on the default display. numDisplays:"+numDisplays);
         for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
             WindowList windows = mService.mDisplayContents.valueAt(displayNdx).getWindowList();
+            Log.d(TAG,"Ritter::updateInputWindowsLw() windows:"+windows.size());
             for (int winNdx = windows.size() - 1; winNdx >= 0; --winNdx) {
                 final WindowState child = windows.get(winNdx);
                 final InputChannel inputChannel = child.mInputChannel;
                 final InputWindowHandle inputWindowHandle = child.mInputWindowHandle;
                 if (inputChannel == null || inputWindowHandle == null || child.mRemoved) {
                     // Skip this window because it cannot possibly receive input.
+                    Log.d(TAG,"Ritter::updateInputWindowsLw() Skip this window because it cannot possibly receive input :"+child.toString());
                     continue;
                 }
-
+                Log.d(TAG,"Ritter::updateInputWindowsLw() windows.name:"+child.toString());
                 final int flags = child.mAttrs.flags;
                 final int privateFlags = child.mAttrs.privateFlags;
                 final int type = child.mAttrs.type;
@@ -294,6 +306,7 @@ final class InputMonitor implements InputManagerService.WindowManagerCallbacks {
                         && child.mBaseLayer < aboveUniverseLayer && onDefaultDisplay) {
                     final WindowState u = universeBackground.mWin;
                     if (u.mInputChannel != null && u.mInputWindowHandle != null) {
+                        Log.d(TAG,"Ritter::updateInputWindowsLw() AAA");
                         addInputWindowHandleLw(u.mInputWindowHandle, u, u.mAttrs.flags,
                                 u.mAttrs.privateFlags, u.mAttrs.type,
                                 true, u == mInputFocus, false);
@@ -302,6 +315,7 @@ final class InputMonitor implements InputManagerService.WindowManagerCallbacks {
                 }
 
                 if (child.mWinAnimator != universeBackground) {
+                    Log.d(TAG,"Ritter::updateInputWindowsLw() BBB");
                     addInputWindowHandleLw(inputWindowHandle, child, flags, privateFlags, type,
                             isVisible, hasFocus, hasWallpaper);
                 }
diff --git a/frameworks/base/services/java/com/android/server/wm/Session.java b/frameworks/base/services/java/com/android/server/wm/Session.java
index 87cabc9..edb5847 100644
--- a/frameworks/base/services/java/com/android/server/wm/Session.java
+++ b/frameworks/base/services/java/com/android/server/wm/Session.java
@@ -35,6 +35,7 @@ import android.os.Process;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.UserHandle;
+import android.util.Log;
 import android.util.Slog;
 import android.view.Display;
 import android.view.IWindow;
@@ -185,13 +186,19 @@ final class Session extends IWindowSession.Stub
             int requestedWidth, int requestedHeight, int viewFlags,
             int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
             Rect outVisibleInsets, Configuration outConfig, Surface outSurface) {
-        if (false) Slog.d(WindowManagerService.TAG, ">>>>>> ENTERED relayout from "
+        if (true) Log.d(WindowManagerService.TAG, ">>>>>> ENTERED relayout from "
                 + Binder.getCallingPid());
+        if(attrs!=null)Log.d("Session","Ritter::Session relayout() attrs x:"+attrs.x
+                +",y:"+attrs.y
+                +",width:"+attrs.width
+                +",height:"+attrs.height
+                +",pkgName:"+attrs.packageName
+                +",isInWindowing:"+attrs.isInWindowing);
         int res = mService.relayoutWindow(this, window, seq, attrs,
                 requestedWidth, requestedHeight, viewFlags, flags,
                 outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,
                 outConfig, outSurface);
-        if (false) Slog.d(WindowManagerService.TAG, "<<<<<< EXITING relayout to "
+        if (true) Log.d(WindowManagerService.TAG, "<<<<<< EXITING relayout to "
                 + Binder.getCallingPid());
         return res;
     }
@@ -500,4 +507,24 @@ final class Session extends IWindowSession.Stub
     public String toString() {
         return mStringName;
     }
+
+    //Ritter_Multi
+    @Override
+    public void moveHomeToTop_WS(){
+        mService.moveHomeToTop();
+    }
+
+    //Ritter_Multi
+    @Override
+    public void moveTaskToTop_WS(int taskID){
+        mService.callAMSMoveTaskToTop(taskID);
+    }
+
+    //Ritter_multi new
+    @Override
+    public boolean getMyWindowStateAttrs(IWindow window, Rect outRect) {
+        boolean res = mService.getMyWindowStateAttrs(this, window, outRect);
+        return res;
+    }
+
 }
\ No newline at end of file
diff --git a/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java b/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java
index cfb10a0..b9fe9b0 100644
--- a/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java
+++ b/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java
@@ -45,10 +45,13 @@ import com.android.server.power.PowerManagerService;
 import com.android.server.power.ShutdownThread;
 
 import android.Manifest;
+import android.app.Activity;
 import android.app.ActivityManager.StackBoxInfo;
+import android.app.ActivityManager;
 import android.app.ActivityManagerNative;
 import android.app.IActivityManager;
 import android.app.StatusBarManager;
+import android.app.WindowAppsManager;
 import android.app.admin.DevicePolicyManager;
 import android.animation.ValueAnimator;
 import android.content.BroadcastReceiver;
@@ -117,6 +120,7 @@ import android.view.InputEventReceiver;
 import android.view.KeyEvent;
 import android.view.MagnificationSpec;
 import android.view.MotionEvent;
+import android.view.ViewRootImpl;
 import android.view.Surface.OutOfResourcesException;
 import android.view.Surface;
 import android.view.SurfaceControl;
@@ -147,6 +151,7 @@ import java.io.StringWriter;
 import java.net.Socket;
 import java.text.DateFormat;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -158,12 +163,12 @@ public class WindowManagerService extends IWindowManager.Stub
         implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs,
                 DisplayManagerService.WindowManagerFuncs, DisplayManager.DisplayListener {
     static final String TAG = "WindowManager";
-    static final boolean DEBUG = false;
+    static final boolean DEBUG = true;
     static final boolean DEBUG_ADD_REMOVE = false;
     static final boolean DEBUG_FOCUS = false;
     static final boolean DEBUG_FOCUS_LIGHT = DEBUG_FOCUS || false;
     static final boolean DEBUG_ANIM = false;
-    static final boolean DEBUG_LAYOUT = false;
+    static final boolean DEBUG_LAYOUT = true;
     static final boolean DEBUG_RESIZE = false;
     static final boolean DEBUG_LAYERS = false;
     static final boolean DEBUG_INPUT = false;
@@ -632,7 +637,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     } break;
 
                     case MotionEvent.ACTION_UP: {
-                        if (DEBUG_DRAG) Slog.d(TAG, "Got UP on move channel; dropping at "
+                        if (DEBUG_DRAG) Log.d(TAG, "Got UP on move channel; dropping at "
                                 + newX + "," + newY);
                         synchronized (mWindowMap) {
                             endDrag = mDragState.notifyDropLw(newX, newY);
@@ -640,13 +645,13 @@ public class WindowManagerService extends IWindowManager.Stub
                     } break;
 
                     case MotionEvent.ACTION_CANCEL: {
-                        if (DEBUG_DRAG) Slog.d(TAG, "Drag cancelled!");
+                        if (DEBUG_DRAG) Log.d(TAG, "Drag cancelled!");
                         endDrag = true;
                     } break;
                     }
 
                     if (endDrag) {
-                        if (DEBUG_DRAG) Slog.d(TAG, "Drag ended; tearing down state");
+                        if (DEBUG_DRAG) Log.d(TAG, "Drag ended; tearing down state");
                         // tell all the windows that the drag has ended
                         synchronized (mWindowMap) {
                             mDragState.endDragLw();
@@ -710,7 +715,7 @@ public class WindowManagerService extends IWindowManager.Stub
             @Override
             public void run() {
                 WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());
-
+                Log.d(TAG,"Ritter::WMS initPolicy run()");
                 mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this);
                 mAnimator.mAboveUniverseLayer = mPolicy.getAboveUniverseLayer()
                         * TYPE_LAYER_MULTIPLIER
@@ -722,6 +727,7 @@ public class WindowManagerService extends IWindowManager.Stub
     private WindowManagerService(Context context, PowerManagerService pm,
             DisplayManagerService displayManager, InputManagerService inputManager,
             boolean haveInputMethods, boolean showBootMsgs, boolean onlyCore) {
+        Log.d(TAG,"Ritter::WMS WindowManagerService()");
         mContext = context;
         mHaveInputMethods = haveInputMethods;
         mAllowBootMessages = showBootMsgs;
@@ -793,6 +799,7 @@ public class WindowManagerService extends IWindowManager.Stub
         SurfaceControl.openTransaction();
         try {
             createWatermarkInTransaction();
+            Log.d(TAG,"Ritter::WMS WindowManagerService after call createWatermarkInTransaction()");
             mFocusedStackFrame = new FocusedStackFrame(
                     getDefaultDisplayContentLocked().getDisplay(), mFxSession);
         } finally {
@@ -822,7 +829,7 @@ public class WindowManagerService extends IWindowManager.Stub
     private void placeWindowAfter(WindowState pos, WindowState window) {
         final WindowList windows = pos.getWindowList();
         final int i = windows.indexOf(pos);
-        if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(
+        if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Log.d(
             TAG, "Adding window " + window + " at "
             + (i+1) + " of " + windows.size() + " (after " + pos + ")");
         windows.add(i+1, window);
@@ -832,7 +839,7 @@ public class WindowManagerService extends IWindowManager.Stub
     private void placeWindowBefore(WindowState pos, WindowState window) {
         final WindowList windows = pos.getWindowList();
         int i = windows.indexOf(pos);
-        if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(
+        if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Log.d(
             TAG, "Adding window " + window + " at "
             + i + " of " + windows.size() + " (before " + pos + ")");
         if (i < 0) {
@@ -926,7 +933,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     //apptoken note that the window could be a floating window
                     //that was created later or a window at the top of the list of
                     //windows associated with this token.
-                    if (DEBUG_FOCUS_LIGHT || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(TAG,
+                    if (DEBUG_FOCUS_LIGHT || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Log.d(TAG,
                             "not Base app: Adding window " + win + " at " + (newIdx + 1) + " of " +
                             N);
                     windows.add(newIdx + 1, win);
@@ -944,7 +951,7 @@ public class WindowManagerService extends IWindowManager.Stub
         }
 
         // No windows from this token on this display
-        if (localLOGV) Slog.v(TAG, "Figuring out where to add app window " + client.asBinder()
+        if (localLOGV) Log.d(TAG, "Figuring out where to add app window " + client.asBinder()
                 + " (token=" + token + ")");
         // Figure out where the window should go, based on the
         // order of applications.
@@ -1048,7 +1055,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 break;
             }
         }
-        if (DEBUG_FOCUS_LIGHT || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(TAG,
+        if (DEBUG_FOCUS_LIGHT || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Log.d(TAG,
                 "Based on layer: Adding window " + win + " at " + i + " of " + N);
         windows.add(i, win);
         mWindowsChanged = true;
@@ -1067,7 +1074,7 @@ public class WindowManagerService extends IWindowManager.Stub
             }
         }
         i++;
-        if (DEBUG_FOCUS_LIGHT || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(TAG,
+        if (DEBUG_FOCUS_LIGHT || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Log.d(TAG,
                 "Free window: Adding window " + win + " at " + i + " of " + windows.size());
         windows.add(i, win);
         mWindowsChanged = true;
@@ -1099,7 +1106,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 // in the same sublayer.
                 if (wSublayer >= sublayer) {
                     if (addToToken) {
-                        if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);
+                        if (DEBUG_ADD_REMOVE) Log.d(TAG, "Adding " + win + " to " + token);
                         token.windows.add(i, win);
                     }
                     placeWindowBefore(wSublayer >= 0 ? attached : w, win);
@@ -1110,7 +1117,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 // in the same sublayer.
                 if (wSublayer > sublayer) {
                     if (addToToken) {
-                        if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);
+                        if (DEBUG_ADD_REMOVE) Log.d(TAG, "Adding " + win + " to " + token);
                         token.windows.add(i, win);
                     }
                     placeWindowBefore(w, win);
@@ -1120,7 +1127,7 @@ public class WindowManagerService extends IWindowManager.Stub
         }
         if (i >= NA) {
             if (addToToken) {
-                if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);
+                if (DEBUG_ADD_REMOVE) Log.d(TAG, "Adding " + win + " to " + token);
                 token.windows.add(win);
             }
             if (sublayer < 0) {
@@ -1135,7 +1142,7 @@ public class WindowManagerService extends IWindowManager.Stub
     }
 
     private void addWindowToListInOrderLocked(final WindowState win, boolean addToToken) {
-        if (DEBUG_FOCUS_LIGHT) Slog.d(TAG, "addWindowToListInOrderLocked: win=" + win +
+        if (DEBUG_FOCUS_LIGHT) Log.d(TAG, "addWindowToListInOrderLocked: win=" + win +
                 " Callers=" + Debug.getCallers(4));
         if (win.mAttachedWindow == null) {
             final WindowToken token = win.mToken;
@@ -1146,7 +1153,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 addFreeWindowToListLocked(win);
             }
             if (addToToken) {
-                if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);
+                if (DEBUG_ADD_REMOVE) Log.d(TAG, "Adding " + win + " to " + token);
                 token.windows.add(tokenWindowsPos, win);
             }
         } else {
@@ -1164,16 +1171,16 @@ public class WindowManagerService extends IWindowManager.Stub
         if (fl == 0 || fl == (FLAG_NOT_FOCUSABLE|FLAG_ALT_FOCUSABLE_IM)
                 || w.mAttrs.type == TYPE_APPLICATION_STARTING) {
             if (DEBUG_INPUT_METHOD) {
-                Slog.i(TAG, "isVisibleOrAdding " + w + ": " + w.isVisibleOrAdding());
+                Log.d(TAG, "isVisibleOrAdding " + w + ": " + w.isVisibleOrAdding());
                 if (!w.isVisibleOrAdding()) {
-                    Slog.i(TAG, "  mSurface=" + w.mWinAnimator.mSurfaceControl
+                    Log.d(TAG, "  mSurface=" + w.mWinAnimator.mSurfaceControl
                             + " relayoutCalled=" + w.mRelayoutCalled + " viewVis=" + w.mViewVisibility
                             + " policyVis=" + w.mPolicyVisibility
                             + " policyVisAfterAnim=" + w.mPolicyVisibilityAfterAnim
                             + " attachHid=" + w.mAttachedHidden
                             + " exiting=" + w.mExiting + " destroying=" + w.mDestroying);
                     if (w.mAppToken != null) {
-                        Slog.i(TAG, "  mAppToken.hiddenRequested=" + w.mAppToken.hiddenRequested);
+                        Log.d(TAG, "  mAppToken.hiddenRequested=" + w.mAppToken.hiddenRequested);
                     }
                 }
             }
@@ -1197,11 +1204,11 @@ public class WindowManagerService extends IWindowManager.Stub
         for (i = windows.size() - 1; i >= 0; --i) {
             WindowState win = windows.get(i);
 
-            if (DEBUG_INPUT_METHOD && willMove) Slog.i(TAG, "Checking window @" + i
+            if (DEBUG_INPUT_METHOD && willMove) Log.d(TAG, "Checking window @" + i
                     + " " + win + " fl=0x" + Integer.toHexString(win.mAttrs.flags));
             if (canBeImeTarget(win)) {
                 w = win;
-                //Slog.i(TAG, "Putting input method here!");
+                //Log.d(TAG, "Putting input method here!");
 
                 // Yet more tricksyness!  If this window is a "starting"
                 // window, we do actually want to be on top of it, but
@@ -1223,7 +1230,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
         // Now w is either mWindows[0] or an IME (or null if mWindows is empty).
 
-        if (DEBUG_INPUT_METHOD && willMove) Slog.v(TAG, "Proposed new IME target: " + w);
+        if (DEBUG_INPUT_METHOD && willMove) Log.d(TAG, "Proposed new IME target: " + w);
 
         // Now, a special case -- if the last target's window is in the
         // process of exiting, and is above the new target, keep on the
@@ -1236,11 +1243,11 @@ public class WindowManagerService extends IWindowManager.Stub
                 && curTarget.isDisplayedLw()
                 && curTarget.isClosing()
                 && (w == null || curTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer)) {
-            if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Current target higher, not changing");
+            if (DEBUG_INPUT_METHOD) Log.d(TAG, "Current target higher, not changing");
             return windows.indexOf(curTarget) + 1;
         }
 
-        if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Desired input method target="
+        if (DEBUG_INPUT_METHOD) Log.d(TAG, "Desired input method target="
                 + w + " willMove=" + willMove);
 
         if (willMove && w != null) {
@@ -1273,7 +1280,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
 
                 if (highestTarget != null) {
-                    if (DEBUG_INPUT_METHOD) Slog.v(TAG, mAppTransition + " " + highestTarget
+                    if (DEBUG_INPUT_METHOD) Log.d(TAG, mAppTransition + " " + highestTarget
                             + " animating=" + highestTarget.mWinAnimator.isAnimating()
                             + " layer=" + highestTarget.mWinAnimator.mAnimLayer
                             + " new layer=" + w.mWinAnimator.mAnimLayer);
@@ -1298,7 +1305,7 @@ public class WindowManagerService extends IWindowManager.Stub
             }
         }
 
-        //Slog.i(TAG, "Placing input method @" + (i+1));
+        //Log.d(TAG, "Placing input method @" + (i+1));
         if (w != null) {
             if (willMove) {
                 if (DEBUG_INPUT_METHOD) Slog.w(TAG, "Moving IM target from " + curTarget + " to "
@@ -1326,7 +1333,7 @@ public class WindowManagerService extends IWindowManager.Stub
         int pos = findDesiredInputMethodWindowIndexLocked(true);
         if (pos >= 0) {
             win.mTargetAppToken = mInputMethodTarget.mAppToken;
-            if (DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(
+            if (DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Log.d(
                     TAG, "Adding input method window " + win + " at " + pos);
             // TODO(multidisplay): IMEs are only supported on the default display.
             getDefaultWindowListLocked().add(pos, win);
@@ -1340,19 +1347,19 @@ public class WindowManagerService extends IWindowManager.Stub
     }
 
     void setInputMethodAnimLayerAdjustment(int adj) {
-        if (DEBUG_LAYERS) Slog.v(TAG, "Setting im layer adj to " + adj);
+        if (DEBUG_LAYERS) Log.d(TAG, "Setting im layer adj to " + adj);
         mInputMethodAnimLayerAdjustment = adj;
         WindowState imw = mInputMethodWindow;
         if (imw != null) {
             imw.mWinAnimator.mAnimLayer = imw.mLayer + adj;
-            if (DEBUG_LAYERS) Slog.v(TAG, "IM win " + imw
+            if (DEBUG_LAYERS) Log.d(TAG, "IM win " + imw
                     + " anim layer: " + imw.mWinAnimator.mAnimLayer);
             int wi = imw.mChildWindows.size();
             while (wi > 0) {
                 wi--;
                 WindowState cw = imw.mChildWindows.get(wi);
                 cw.mWinAnimator.mAnimLayer = cw.mLayer + adj;
-                if (DEBUG_LAYERS) Slog.v(TAG, "IM win " + cw
+                if (DEBUG_LAYERS) Log.d(TAG, "IM win " + cw
                         + " anim layer: " + cw.mWinAnimator.mAnimLayer);
             }
         }
@@ -1361,7 +1368,7 @@ public class WindowManagerService extends IWindowManager.Stub
             di --;
             imw = mInputMethodDialogs.get(di);
             imw.mWinAnimator.mAnimLayer = imw.mLayer + adj;
-            if (DEBUG_LAYERS) Slog.v(TAG, "IM win " + imw
+            if (DEBUG_LAYERS) Log.d(TAG, "IM win " + imw
                     + " anim layer: " + imw.mWinAnimator.mAnimLayer);
         }
     }
@@ -1371,7 +1378,7 @@ public class WindowManagerService extends IWindowManager.Stub
         int wpos = windows.indexOf(win);
         if (wpos >= 0) {
             if (wpos < interestingPos) interestingPos--;
-            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Temp removing at " + wpos + ": " + win);
+            if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG, "Temp removing at " + wpos + ": " + win);
             windows.remove(wpos);
             mWindowsChanged = true;
             int NC = win.mChildWindows.size();
@@ -1381,7 +1388,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 int cpos = windows.indexOf(cw);
                 if (cpos >= 0) {
                     if (cpos < interestingPos) interestingPos--;
-                    if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Temp removing child at "
+                    if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG, "Temp removing child at "
                             + cpos + ": " + cw);
                     windows.remove(cpos);
                 }
@@ -1398,7 +1405,7 @@ public class WindowManagerService extends IWindowManager.Stub
         WindowList windows = win.getWindowList();
         int wpos = windows.indexOf(win);
         if (wpos >= 0) {
-            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "ReAdd removing from " + wpos + ": " + win);
+            if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG, "ReAdd removing from " + wpos + ": " + win);
             windows.remove(wpos);
             mWindowsChanged = true;
             reAddWindowLocked(wpos, win);
@@ -1409,7 +1416,7 @@ public class WindowManagerService extends IWindowManager.Stub
         int N = windows.size();
         while (N > 0) {
             N--;
-            Slog.v(TAG, prefix + "#" + N + ": " + windows.get(N));
+            Log.d(TAG, prefix + "#" + N + ": " + windows.get(N));
         }
     }
 
@@ -1419,12 +1426,12 @@ public class WindowManagerService extends IWindowManager.Stub
         // TODO(multidisplay): IMEs are only supported on the default display.
         WindowList windows = getDefaultWindowListLocked();
         final int N = dialogs.size();
-        if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Removing " + N + " dialogs w/pos=" + pos);
+        if (DEBUG_INPUT_METHOD) Log.d(TAG, "Removing " + N + " dialogs w/pos=" + pos);
         for (int i=0; i<N; i++) {
             pos = tmpRemoveWindowLocked(pos, dialogs.get(i));
         }
         if (DEBUG_INPUT_METHOD) {
-            Slog.v(TAG, "Window list w/pos=" + pos);
+            Log.d(TAG, "Window list w/pos=" + pos);
             logWindowList(windows, "  ");
         }
 
@@ -1436,14 +1443,14 @@ public class WindowManagerService extends IWindowManager.Stub
                     pos++;
                 }
             }
-            if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Adding " + N + " dialogs at pos=" + pos);
+            if (DEBUG_INPUT_METHOD) Log.d(TAG, "Adding " + N + " dialogs at pos=" + pos);
             for (int i=0; i<N; i++) {
                 WindowState win = dialogs.get(i);
                 win.mTargetAppToken = targetAppToken;
                 pos = reAddWindowLocked(pos, win);
             }
             if (DEBUG_INPUT_METHOD) {
-                Slog.v(TAG, "Final window list:");
+                Log.d(TAG, "Final window list:");
                 logWindowList(windows, "  ");
             }
             return;
@@ -1453,7 +1460,7 @@ public class WindowManagerService extends IWindowManager.Stub
             win.mTargetAppToken = null;
             reAddWindowToListInOrderLocked(win);
             if (DEBUG_INPUT_METHOD) {
-                Slog.v(TAG, "No IM target, final list:");
+                Log.d(TAG, "No IM target, final list:");
                 logWindowList(windows, "  ");
             }
         }
@@ -1519,18 +1526,18 @@ public class WindowManagerService extends IWindowManager.Stub
 
             if (imWin != null) {
                 if (DEBUG_INPUT_METHOD) {
-                    Slog.v(TAG, "Moving IM from " + imPos);
+                    Log.d(TAG, "Moving IM from " + imPos);
                     logWindowList(windows, "  ");
                 }
                 imPos = tmpRemoveWindowLocked(imPos, imWin);
                 if (DEBUG_INPUT_METHOD) {
-                    Slog.v(TAG, "List after removing with new pos " + imPos + ":");
+                    Log.d(TAG, "List after removing with new pos " + imPos + ":");
                     logWindowList(windows, "  ");
                 }
                 imWin.mTargetAppToken = mInputMethodTarget.mAppToken;
                 reAddWindowLocked(imPos, imWin);
                 if (DEBUG_INPUT_METHOD) {
-                    Slog.v(TAG, "List after moving IM to " + imPos + ":");
+                    Log.d(TAG, "List after moving IM to " + imPos + ":");
                     logWindowList(windows, "  ");
                 }
                 if (DN > 0) moveInputMethodDialogsLocked(imPos+1);
@@ -1543,12 +1550,12 @@ public class WindowManagerService extends IWindowManager.Stub
             // because they aren't currently associated with a focus window.
 
             if (imWin != null) {
-                if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Moving IM from " + imPos);
+                if (DEBUG_INPUT_METHOD) Log.d(TAG, "Moving IM from " + imPos);
                 tmpRemoveWindowLocked(0, imWin);
                 imWin.mTargetAppToken = null;
                 reAddWindowToListInOrderLocked(imWin);
                 if (DEBUG_INPUT_METHOD) {
-                    Slog.v(TAG, "List with no IM target:");
+                    Log.d(TAG, "List with no IM target:");
                     logWindowList(windows, "  ");
                 }
                 if (DN > 0) moveInputMethodDialogsLocked(-1);
@@ -1566,7 +1573,7 @@ public class WindowManagerService extends IWindowManager.Stub
     }
 
     final boolean isWallpaperVisible(WindowState wallpaperTarget) {
-        if (DEBUG_WALLPAPER) Slog.v(TAG, "Wallpaper vis: target " + wallpaperTarget + ", obscured="
+        if (DEBUG_WALLPAPER) Log.d(TAG, "Wallpaper vis: target " + wallpaperTarget + ", obscured="
                 + (wallpaperTarget != null ? Boolean.toString(wallpaperTarget.mObscured) : "??")
                 + " anim=" + ((wallpaperTarget != null && wallpaperTarget.mAppToken != null)
                         ? wallpaperTarget.mAppToken.mAppAnimator.animation : null)
@@ -1617,16 +1624,16 @@ public class WindowManagerService extends IWindowManager.Stub
                 // If this window's app token is hidden and not animating,
                 // it is of no interest to us.
                 if (w.mAppToken.hidden && w.mAppToken.mAppAnimator.animation == null) {
-                    if (DEBUG_WALLPAPER) Slog.v(TAG,
+                    if (DEBUG_WALLPAPER) Log.d(TAG,
                             "Skipping hidden and not animating token: " + w);
                     continue;
                 }
             }
-            if (DEBUG_WALLPAPER) Slog.v(TAG, "Win #" + i + " " + w + ": isOnScreen="
+            if (DEBUG_WALLPAPER) Log.d(TAG, "Win #" + i + " " + w + ": isOnScreen="
                     + w.isOnScreen() + " mDrawState=" + w.mWinAnimator.mDrawState);
             if ((w.mAttrs.flags&FLAG_SHOW_WALLPAPER) != 0 && w.isOnScreen()
                     && (mWallpaperTarget == w || w.isDrawFinishedLw())) {
-                if (DEBUG_WALLPAPER) Slog.v(TAG,
+                if (DEBUG_WALLPAPER) Log.d(TAG,
                         "Found wallpaper target: #" + i + "=" + w);
                 foundW = w;
                 foundI = i;
@@ -1634,7 +1641,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     // The current wallpaper target is animating, so we'll
                     // look behind it for another possible target and figure
                     // out what is going on below.
-                    if (DEBUG_WALLPAPER) Slog.v(TAG, "Win " + w
+                    if (DEBUG_WALLPAPER) Log.d(TAG, "Win " + w
                             + ": token animating, looking behind.");
                     continue;
                 }
@@ -1645,7 +1652,7 @@ public class WindowManagerService extends IWindowManager.Stub
         }
 
         if (foundW == null && windowDetachedI >= 0) {
-            if (DEBUG_WALLPAPER_LIGHT) Slog.v(TAG,
+            if (DEBUG_WALLPAPER_LIGHT) Log.d(TAG,
                     "Found animating detached wallpaper activity: #" + i + "=" + w);
             foundW = w;
             foundI = windowDetachedI;
@@ -1654,7 +1661,7 @@ public class WindowManagerService extends IWindowManager.Stub
         if (mWallpaperTarget != foundW
                 && (mLowerWallpaperTarget == null || mLowerWallpaperTarget != foundW)) {
             if (DEBUG_WALLPAPER_LIGHT) {
-                Slog.v(TAG, "New wallpaper target: " + foundW
+                Log.d(TAG, "New wallpaper target: " + foundW
                         + " oldTarget: " + mWallpaperTarget);
             }
 
@@ -1671,17 +1678,17 @@ public class WindowManagerService extends IWindowManager.Stub
                 boolean oldAnim = oldW.isAnimatingLw();
                 boolean foundAnim = foundW.isAnimatingLw();
                 if (DEBUG_WALLPAPER_LIGHT) {
-                    Slog.v(TAG, "New animation: " + foundAnim
+                    Log.d(TAG, "New animation: " + foundAnim
                             + " old animation: " + oldAnim);
                 }
                 if (foundAnim && oldAnim) {
                     int oldI = windows.indexOf(oldW);
                     if (DEBUG_WALLPAPER_LIGHT) {
-                        Slog.v(TAG, "New i: " + foundI + " old i: " + oldI);
+                        Log.d(TAG, "New i: " + foundI + " old i: " + oldI);
                     }
                     if (oldI >= 0) {
                         if (DEBUG_WALLPAPER_LIGHT) {
-                            Slog.v(TAG, "Animating wallpapers: old#" + oldI
+                            Log.d(TAG, "Animating wallpapers: old#" + oldI
                                     + "=" + oldW + "; new#" + foundI
                                     + "=" + foundW);
                         }
@@ -1689,7 +1696,7 @@ public class WindowManagerService extends IWindowManager.Stub
                         // Set the new target correctly.
                         if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
                             if (DEBUG_WALLPAPER_LIGHT) {
-                                Slog.v(TAG, "Old wallpaper still the target.");
+                                Log.d(TAG, "Old wallpaper still the target.");
                             }
                             mWallpaperTarget = oldW;
                             foundW = oldW;
@@ -1701,7 +1708,7 @@ public class WindowManagerService extends IWindowManager.Stub
                         else if (foundI > oldI) {
                             // The new target is on top of the old one.
                             if (DEBUG_WALLPAPER_LIGHT) {
-                                Slog.v(TAG, "Found target above old target.");
+                                Log.d(TAG, "Found target above old target.");
                             }
                             mUpperWallpaperTarget = foundW;
                             mLowerWallpaperTarget = oldW;
@@ -1710,7 +1717,7 @@ public class WindowManagerService extends IWindowManager.Stub
                         } else {
                             // The new target is below the old one.
                             if (DEBUG_WALLPAPER_LIGHT) {
-                                Slog.v(TAG, "Found target below old target.");
+                                Log.d(TAG, "Found target below old target.");
                             }
                             mUpperWallpaperTarget = oldW;
                             mLowerWallpaperTarget = foundW;
@@ -1723,7 +1730,7 @@ public class WindowManagerService extends IWindowManager.Stub
             // Is it time to stop animating?
             if (!mLowerWallpaperTarget.isAnimatingLw() || !mUpperWallpaperTarget.isAnimatingLw()) {
                 if (DEBUG_WALLPAPER_LIGHT) {
-                    Slog.v(TAG, "No longer animating wallpaper targets!");
+                    Log.d(TAG, "No longer animating wallpaper targets!");
                 }
                 mLowerWallpaperTarget = null;
                 mUpperWallpaperTarget = null;
@@ -1737,7 +1744,7 @@ public class WindowManagerService extends IWindowManager.Stub
             // The window is visible to the compositor...  but is it visible
             // to the user?  That is what the wallpaper cares about.
             visible = isWallpaperVisible(foundW);
-            if (DEBUG_WALLPAPER) Slog.v(TAG, "Wallpaper visibility: " + visible);
+            if (DEBUG_WALLPAPER) Log.d(TAG, "Wallpaper visibility: " + visible);
 
             // If the wallpaper target is animating, we may need to copy
             // its layer adjustment.  Only do this if we are not transfering
@@ -1770,7 +1777,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 foundI--;
             }
         } else {
-            if (DEBUG_WALLPAPER) Slog.v(TAG, "No wallpaper target");
+            if (DEBUG_WALLPAPER) Log.d(TAG, "No wallpaper target");
         }
 
         if (foundW == null && topCurW != null) {
@@ -1803,7 +1810,7 @@ public class WindowManagerService extends IWindowManager.Stub
             curTokenIndex--;
             WindowToken token = mWallpaperTokens.get(curTokenIndex);
             if (token.hidden == visible) {
-                if (DEBUG_WALLPAPER_LIGHT) Slog.d(TAG,
+                if (DEBUG_WALLPAPER_LIGHT) Log.d(TAG,
                         "Wallpaper token " + token + " hidden=" + !visible);
                 changed |= ADJUST_WALLPAPER_VISIBILITY_CHANGED;
                 token.hidden = !visible;
@@ -1826,7 +1833,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 dispatchWallpaperVisibility(wallpaper, visible);
 
                 wallpaper.mWinAnimator.mAnimLayer = wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
-                if (DEBUG_LAYERS || DEBUG_WALLPAPER_LIGHT) Slog.v(TAG, "adjustWallpaper win "
+                if (DEBUG_LAYERS || DEBUG_WALLPAPER_LIGHT) Log.d(TAG, "adjustWallpaper win "
                         + wallpaper + " anim layer: " + wallpaper.mWinAnimator.mAnimLayer);
 
                 // First, if this window is at the current index, then all
@@ -1843,7 +1850,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 // not in the list.
                 int oldIndex = windows.indexOf(wallpaper);
                 if (oldIndex >= 0) {
-                    if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Wallpaper removing at "
+                    if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG, "Wallpaper removing at "
                             + oldIndex + ": " + wallpaper);
                     windows.remove(oldIndex);
                     mWindowsChanged = true;
@@ -1862,7 +1869,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     }
                 }
                 if (DEBUG_WALLPAPER_LIGHT || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) {
-                    Slog.v(TAG, "Moving wallpaper " + wallpaper
+                    Log.d(TAG, "Moving wallpaper " + wallpaper
                             + " from " + oldIndex + " to " + insertionIndex);
                 }
 
@@ -1894,7 +1901,7 @@ public class WindowManagerService extends IWindowManager.Stub
         */
 
         if (targetChanged && DEBUG_WALLPAPER_LIGHT) {
-            Slog.d(TAG, "New wallpaper: target=" + mWallpaperTarget
+            Log.d(TAG, "New wallpaper: target=" + mWallpaperTarget
                     + " lower=" + mLowerWallpaperTarget + " upper="
                     + mUpperWallpaperTarget);
         }
@@ -1903,7 +1910,7 @@ public class WindowManagerService extends IWindowManager.Stub
     }
 
     void setWallpaperAnimLayerAdjustmentLocked(int adj) {
-        if (DEBUG_LAYERS || DEBUG_WALLPAPER) Slog.v(TAG,
+        if (DEBUG_LAYERS || DEBUG_WALLPAPER) Log.d(TAG,
                 "Setting wallpaper layer adj to " + adj);
         mWallpaperAnimLayerAdjustment = adj;
         int curTokenIndex = mWallpaperTokens.size();
@@ -1915,7 +1922,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 curWallpaperIndex--;
                 WindowState wallpaper = token.windows.get(curWallpaperIndex);
                 wallpaper.mWinAnimator.mAnimLayer = wallpaper.mLayer + adj;
-                if (DEBUG_LAYERS || DEBUG_WALLPAPER) Slog.v(TAG, "setWallpaper win "
+                if (DEBUG_LAYERS || DEBUG_WALLPAPER) Log.d(TAG, "setWallpaper win "
                         + wallpaper + " anim layer: " + wallpaper.mWinAnimator.mAnimLayer);
             }
         }
@@ -1931,7 +1938,7 @@ public class WindowManagerService extends IWindowManager.Stub
         int offset = availw > 0 ? -(int)(availw*wpx+.5f) : 0;
         changed = wallpaperWin.mXOffset != offset;
         if (changed) {
-            if (DEBUG_WALLPAPER) Slog.v(TAG, "Update wallpaper "
+            if (DEBUG_WALLPAPER) Log.d(TAG, "Update wallpaper "
                     + wallpaperWin + " x: " + offset);
             wallpaperWin.mXOffset = offset;
         }
@@ -1946,7 +1953,7 @@ public class WindowManagerService extends IWindowManager.Stub
         int availh = wallpaperWin.mFrame.bottom-wallpaperWin.mFrame.top-dh;
         offset = availh > 0 ? -(int)(availh*wpy+.5f) : 0;
         if (wallpaperWin.mYOffset != offset) {
-            if (DEBUG_WALLPAPER) Slog.v(TAG, "Update wallpaper "
+            if (DEBUG_WALLPAPER) Log.d(TAG, "Update wallpaper "
                     + wallpaperWin + " y: " + offset);
             changed = true;
             wallpaperWin.mYOffset = offset;
@@ -1960,7 +1967,7 @@ public class WindowManagerService extends IWindowManager.Stub
         if (rawChanged && (wallpaperWin.mAttrs.privateFlags &
                     WindowManager.LayoutParams.PRIVATE_FLAG_WANTS_OFFSET_NOTIFICATIONS) != 0) {
             try {
-                if (DEBUG_WALLPAPER) Slog.v(TAG, "Report new wp offset "
+                if (DEBUG_WALLPAPER) Log.d(TAG, "Report new wp offset "
                         + wallpaperWin + " x=" + wallpaperWin.mWallpaperX
                         + " y=" + wallpaperWin.mWallpaperY);
                 if (sync) {
@@ -1975,15 +1982,15 @@ public class WindowManagerService extends IWindowManager.Stub
                         if ((mLastWallpaperTimeoutTime+WALLPAPER_TIMEOUT_RECOVERY)
                                 < start) {
                             try {
-                                if (DEBUG_WALLPAPER) Slog.v(TAG,
+                                if (DEBUG_WALLPAPER) Log.d(TAG,
                                         "Waiting for offset complete...");
                                 mWindowMap.wait(WALLPAPER_TIMEOUT);
                             } catch (InterruptedException e) {
                             }
-                            if (DEBUG_WALLPAPER) Slog.v(TAG, "Offset complete!");
+                            if (DEBUG_WALLPAPER) Log.d(TAG, "Offset complete!");
                             if ((start+WALLPAPER_TIMEOUT)
                                     < SystemClock.uptimeMillis()) {
-                                Slog.i(TAG, "Timeout waiting for wallpaper to offset: "
+                                Log.d(TAG, "Timeout waiting for wallpaper to offset: "
                                         + wallpaperWin);
                                 mLastWallpaperTimeoutTime = start;
                             }
@@ -2058,7 +2065,7 @@ public class WindowManagerService extends IWindowManager.Stub
         if (wallpaper.mWallpaperVisible != visible) {
             wallpaper.mWallpaperVisible = visible;
             try {
-                if (DEBUG_VISIBILITY || DEBUG_WALLPAPER_LIGHT) Slog.v(TAG,
+                if (DEBUG_VISIBILITY || DEBUG_WALLPAPER_LIGHT) Log.d(TAG,
                         "Updating vis of wallpaper " + wallpaper
                         + ": " + visible + " from:\n" + Debug.getCallers(4, "  "));
                 wallpaper.mClient.dispatchAppVisibility(visible);
@@ -2101,6 +2108,7 @@ public class WindowManagerService extends IWindowManager.Stub
     public int addWindow(Session session, IWindow client, int seq,
             WindowManager.LayoutParams attrs, int viewVisibility, int displayId,
             Rect outContentInsets, InputChannel outInputChannel) {
+        Log.d(TAG,"Ritter::WMS addWindow()");
         int[] appOp = new int[1];
         int res = mPolicy.checkAddPermission(attrs, appOp);
         if (res != WindowManagerGlobal.ADD_OKAY) {
@@ -2193,7 +2201,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
                 if (type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
                     // No need for this guy!
-                    if (localLOGV) Slog.v(
+                    if (localLOGV) Log.d(
                             TAG, "**** NO NEED TO START: " + attrs.getTitle());
                     return WindowManagerGlobal.ADD_STARTING_NOT_NEEDED;
                 }
@@ -2219,6 +2227,194 @@ public class WindowManagerService extends IWindowManager.Stub
 
             win = new WindowState(this, session, client, token,
                     attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent);
+
+            /**
+             * Author: Ritter_Multi
+             * Date: 12/01/2011
+             *
+             * Sets the WindowPanel rect for apptokens.
+             */
+            if(token.appWindowToken != null) {
+                if(attrs != null){
+                    Log.d(TAG,"Ritter::WMS addWindow() attrs.getTitle():"+attrs.getTitle()+",attrs.packageName:"+attrs.packageName);
+
+                    List<String> rootList = Arrays.asList(WindowManagerGlobal.getInstance().getViewRootNames());
+                    ArrayList<WindowManager.LayoutParams> paramsList = WindowManagerGlobal.getInstance().getWindowManagerLayoutParams();
+                    Log.d(TAG,"Ritter::WMS addWindow() paramsList.size:" + paramsList.size());
+                    Log.d(TAG,"Ritter::WMS addWindow() rootList.size:" +rootList.size());
+                    Log.d(TAG,"Ritter::WMS addWindow() rootList:" +rootList);
+                    Log.d(TAG,"Ritter::WMS addWindow() win.mChildWindows.size():" +win.mChildWindows.size());
+                    if (win.mAttachedWindow != null) {
+                        Log.d(TAG,"Ritter::WMS addWindow() win.mAttachedWindow.mChildWindows.size():" + win.mAttachedWindow.mChildWindows.size());
+                        Log.d(TAG,"Ritter::WMS addWindow() win.mAttachedWindow.mAttrs.packageName:" + win.mAttachedWindow.mAttrs.packageName);
+                    } else {
+                        Log.d(TAG,"Ritter::WMS addWindow() win.mAttachedWindow == null");
+                    }
+
+                    if(win.mAppToken!=null){
+                        if(win.mAppToken.startingWindow!=null){
+                            if(win.mAppToken.startingWindow.mAttrs!=null){
+                                Log.d(TAG,"Ritter::WMS addWindow() win.mAppToken.startingWindow.mAttrs.packageName != null"+win.mAppToken.startingWindow.mAttrs.packageName);
+                            }else{
+                                Log.d(TAG,"Ritter::WMS addWindow() win.mAppToken.startingWindow.mAttrs == null");
+                            }
+                        }else{
+                            Log.d(TAG,"Ritter::WMS addWindow() win.mAppToken.startingWindow == null");
+                        }
+                    }else{
+                        Log.d(TAG,"Ritter::WMS addWindow() win.mAppToken == null");
+                    }
+
+                    if(win.mAppToken!=null){
+                        if(win.mAppToken.allAppWindows!=null){
+                                Log.d(TAG,"Ritter::WMS addWindow() win.mAppToken.allAppWindows.size()"+win.mAppToken.allAppWindows.size());
+                        }else{
+                            Log.d(TAG,"Ritter::WMS addWindow() win.mAppToken.allAppWindows == null");
+                        }
+                    }else{
+                        Log.d(TAG,"Ritter::WMS addWindow() win.mAppToken == null");
+                    }
+
+                    if(win.mRootToken!=null){
+                        if(win.mRootToken.windows!=null){
+                                Log.d(TAG,"Ritter::WMS addWindow() win.mRootToken.windows.size()"+ win.mRootToken.windows.size());
+                        }else{
+                            Log.d(TAG,"Ritter::WMS addWindow() win.mRootToken.windows == null");
+                        }
+                    }else{
+                        Log.d(TAG,"Ritter::WMS addWindow() win.mRootToken == null");
+                    }
+
+                    AppWindowToken target = win.mAppToken;
+                    final int taskId = target.groupId;
+                    Task targetTask = mTaskIdToTask.get(taskId);
+                    if (targetTask == null) {
+                        Log.d(TAG, "findAppWindowInsertionPointLocked: no Task for " + target + " taskId="
+                                + taskId);
+                        return 0;
+                    }
+                    DisplayContent displayContent2 = targetTask.getDisplayContent();
+                    if (displayContent2 == null) {
+                        Slog.w(TAG, "findAppWindowInsertionPointLocked: no DisplayContent for " + target);
+                        return 0;
+                    }
+                    final WindowList windows = displayContent2.getWindowList();
+                    Log.d(TAG,"Ritter::WMS addWindow() task windows.size():"+windows.size());
+                    for (int i = 0; i < windows.size(); i++) {
+                        WindowState ws = windows.get(i);
+                        Log.d(TAG,"Ritter::WMS addWindow() WindowState ws:"+ws.mAttrs.packageName
+                                +",x:"+ws.mAttrs.x+",y:"+ws.mAttrs.y+",w:"+ws.mAttrs.width+",h:"+ws.mAttrs.height);
+                    }
+
+                    boolean isFirstAppWindowTokenInTask = true;
+                    WindowState firstWindowState = null;
+                    AppTokenList taskAppTokens = targetTask.mAppTokens;
+                    Log.d(TAG,"Ritter::WMS addWindow() task taskAppTokens.size():"+taskAppTokens.size());
+                    for (int i = 0; i < taskAppTokens.size(); i++) {
+                        AppWindowToken appWindowToken = taskAppTokens.get(i);
+                        Log.d(TAG,
+                                "Ritter::WMS addWindow() task appWindowToken.windows.size():"
+                                        + appWindowToken.windows.size());
+                        if (appWindowToken.windows.size() > 0) {
+                            firstWindowState = appWindowToken.windows.get(0);
+                            if (firstWindowState != null) {
+                                if (taskAppTokens.size() > 1) {
+                                    isFirstAppWindowTokenInTask = false;
+                                }
+                                Log.d(TAG,
+                                        "Ritter::WMS addWindow() appWindowToken firstWindowState != null ws:"
+                                                + firstWindowState.mAttrs.packageName
+                                                + ",x:"
+                                                + firstWindowState.mAttrs.x
+                                                + ",y:"
+                                                + firstWindowState.mAttrs.y
+                                                + ",w:"
+                                                + firstWindowState.mAttrs.width
+                                                + ",h:"
+                                                + firstWindowState.mAttrs.height);
+                            } else {
+                                Log.d(TAG,
+                                        "Ritter::WMS addWindow() appWindowToken startingWindow == null");
+                            }
+                        }
+                    }
+
+//                    ActivityRecord activityRecord = ActivityRecord.forToken(win.mToken.token);
+                    /*Log.d(TAG,"Ritter::WMS addWindow() activityRecord.taskAffinity:"+activityRecord.taskAffinity);
+                    Log.d(TAG,"Ritter::WMS addWindow() activityRecord.task.mActivities.size():"+ activityRecord.task.mActivities.size());
+                    */
+//                    if (activityRecord.task.mActivities.size()==1 ) {
+
+                    // Get window apps from service
+                    String APPs = "";
+                    WindowAppsManager mWindowAppsManager = (WindowAppsManager) mContext
+                            .getSystemService("window_apps");
+                    try {
+                        APPs = mWindowAppsManager.getWindowApps();
+                    } catch (Exception e){
+                        e.printStackTrace();
+                    }
+                    ArrayList<String> pkgList = new ArrayList<String>(Arrays.asList(APPs.split("#")));
+
+                        if (attrs.packageName != null
+                                && !attrs.packageName.isEmpty()
+                                && pkgList.contains(attrs.packageName)) {
+//                                (attrs.packageName
+//                                        .equals("com.example.activity")|| attrs.packageName
+//                                        .equals("com.example.hello"))) {
+                            win.mAttrs.isInWindowing = true;
+                            win.mAttrs.isFullscreen = false;
+                            if (isFirstAppWindowTokenInTask) {
+                                Log.d(TAG,
+                                        "Ritter::WMS addWindow() win.mFrame.set(new Rect(300,300,600,1000)); win.mAttrs.isInWindowing:"+win.mAttrs.isInWindowing);
+                                win.mFrame.set(new Rect(270, 480, 810, 1440));
+                               /* ViewRootImpl root = WindowManagerGlobal.getInstance().getRootView(rootList.get(rootList.size()-1)).getViewRootImpl();
+                                WindowManager.LayoutParams windowAttributes = root.getLayoutParams();
+                                Log.d(TAG,
+                                        "Ritter::WMS addWindow() win.mFrame.set(new Rect(300,300,600,1000)) B windowAttributes.x:("
+                                                +windowAttributes.x+","
+                                                +windowAttributes.y+","
+                                                +windowAttributes.width+","
+                                                +windowAttributes.height+")); windowAttributes.packageName:"+windowAttributes.packageName);*/
+                                win.mAttrs.x = 270;
+                                win.mAttrs.y = 480;
+                                win.mAttrs.width = 810 - 270;
+                                win.mAttrs.height = 1440 - 480;
+                                win.mAttrs.setWindowingParam();
+//                                windowAttributes.copyFrom(win.mAttrs);
+                                /*Log.d(TAG,
+                                        "Ritter::WMS addWindow() win.mFrame.set(new Rect(300,300,600,1000)) A windowAttributes.x:("
+                                                +windowAttributes.x+","
+                                                +windowAttributes.y+","
+                                                +windowAttributes.width+","
+                                                +windowAttributes.height+")); windowAttributes.packageName:"+windowAttributes.packageName);*/
+                            } else {
+                                Log.d(TAG,
+                                        "Ritter::WMS addWindow() win.mFrame.set(new Rect("
+                                                +firstWindowState.mAttrs.x+","
+                                                +firstWindowState.mAttrs.y+","
+                                                +(firstWindowState.mAttrs.x + firstWindowState.mAttrs.width)+","
+                                                +(firstWindowState.mAttrs.y + firstWindowState.mAttrs.height)+")); win.mAttrs.isInWindowing:"+win.mAttrs.isInWindowing);
+                                win.mFrame.set(new Rect(firstWindowState.mAttrs.x,
+                                        firstWindowState.mAttrs.y,
+                                        firstWindowState.mAttrs.x + firstWindowState.mAttrs.width,
+                                        firstWindowState.mAttrs.y + firstWindowState.mAttrs.height));
+                                win.mAttrs.copyFrom(firstWindowState.mAttrs);
+                                win.mAttrs.setWindowingParam();
+                            }
+                        } else {
+                            Log.d(TAG,
+                                    "Ritter::WMS addWindow() normal win.mFrame.set(new Rect(0,50,1200,1824));");
+                            win.mFrame
+                                    .set(new Rect(
+                                            0,
+                                            50,
+                                            displayContent.getDisplayInfo().logicalWidth,
+                                            displayContent.getDisplayInfo().logicalHeight - 96));
+                        }
+                }
+            }
+
             if (win.mDeathRecipient == null) {
                 // Client has apparently died, so there is no reason to
                 // continue.
@@ -2255,7 +2451,10 @@ public class WindowManagerService extends IWindowManager.Stub
                 mTokenMap.put(attrs.token, token);
             }
             win.attach();
+            Log.d(TAG,"Ritter::"+mWindowMap.size());
+            Log.d(TAG, "Ritter::WMS addWindow() before put mWindowMap.size():"+ mWindowMap.size()+",client.asBinder():"+client.asBinder().toString());
             mWindowMap.put(client.asBinder(), win);
+            Log.d(TAG, "Ritter::WMS addWindow() after put mWindowMap.size():"+ mWindowMap.size()+",client.asBinder():"+client.asBinder().toString());
             if (win.mAppOp != AppOpsManager.OP_NONE) {
                 if (mAppOps.startOpNoThrow(win.mAppOp, win.getOwningUid(), win.getOwningPackage())
                         != AppOpsManager.MODE_ALLOWED) {
@@ -2265,7 +2464,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
             if (type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
                 token.appWindowToken.startingWindow = win;
-                if (DEBUG_STARTING_WINDOW) Slog.v (TAG, "addWindow: " + token.appWindowToken
+                if (DEBUG_STARTING_WINDOW) Log.d (TAG, "addWindow: " + token.appWindowToken
                         + " startingWindow=" + win);
                 Message m = mH.obtainMessage(H.REMOVE_STARTING_TIMEOUT, token.appWindowToken);
                 mH.sendMessageDelayed(m, STARTING_WINDOW_TIMEOUT_DURATION);
@@ -2340,7 +2539,7 @@ public class WindowManagerService extends IWindowManager.Stub
             }
             mInputMonitor.updateInputWindowsLw(false /*force*/);
 
-            if (localLOGV) Slog.v(
+            if (localLOGV) Log.d(
                 TAG, "New client " + client.asBinder()
                 + ": window=" + win);
 
@@ -2354,7 +2553,16 @@ public class WindowManagerService extends IWindowManager.Stub
         }
 
         Binder.restoreCallingIdentity(origId);
-
+        Log.d(TAG,
+                "Ritter::WMS addWindow() end win.mAttrs.x:"
+                        + win.mAttrs.x + ",mAttrs.y:"
+                        + win.mAttrs.y + ",mAttrs.w:"
+                        + win.mAttrs.width + ",mAttrs.h:"
+                        + win.mAttrs.height
+                        + ",mAttrs.isInWindowing:"
+                        + win.mAttrs.isInWindowing
+                        + ",mAttrs.pkgName:"
+                        + win.mAttrs.packageName);
         return res;
     }
 
@@ -2370,11 +2578,11 @@ public class WindowManagerService extends IWindowManager.Stub
 
     public void removeWindowLocked(Session session, WindowState win) {
         if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
-            if (DEBUG_STARTING_WINDOW) Slog.d(TAG, "Starting window removed " + win);
+            if (DEBUG_STARTING_WINDOW) Log.d(TAG, "Starting window removed " + win);
             removeStartingWindowTimeout(win.mAppToken);
         }
 
-        if (localLOGV || DEBUG_FOCUS || DEBUG_FOCUS_LIGHT && win==mCurrentFocus) Slog.v(
+        if (localLOGV || DEBUG_FOCUS || DEBUG_FOCUS_LIGHT && win==mCurrentFocus) Log.d(
                 TAG, "Remove " + win + " client="
                 + Integer.toHexString(System.identityHashCode(win.mClient.asBinder()))
                 + ", surface=" + win.mWinAnimator.mSurfaceControl + " Callers="
@@ -2384,7 +2592,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
         win.disposeInputChannel();
 
-        if (DEBUG_APP_TRANSITIONS) Slog.v(
+        if (DEBUG_APP_TRANSITIONS) Log.d(
                 TAG, "Remove " + win + ": mSurface=" + win.mWinAnimator.mSurfaceControl
                 + " mExiting=" + win.mExiting
                 + " isAnimating=" + win.mWinAnimator.isAnimating()
@@ -2421,7 +2629,7 @@ public class WindowManagerService extends IWindowManager.Stub
             }
             if (win.mExiting || win.mWinAnimator.isAnimating()) {
                 // The exit animation is running... wait for it!
-                //Slog.i(TAG, "*** Running exit animation...");
+                //Log.d(TAG, "*** Running exit animation...");
                 win.mExiting = true;
                 win.mRemoveOnExit = true;
                 win.mDisplayContent.layoutNeeded = true;
@@ -2475,7 +2683,7 @@ public class WindowManagerService extends IWindowManager.Stub
         mPolicy.removeWindowLw(win);
         win.removeLocked();
 
-        if (DEBUG_ADD_REMOVE) Slog.v(TAG, "removeWindowInnerLocked: " + win);
+        if (DEBUG_ADD_REMOVE) Log.d(TAG, "removeWindowInnerLocked: " + win);
         mWindowMap.remove(win.mClient.asBinder());
         if (win.mAppOp != AppOpsManager.OP_NONE) {
             mAppOps.finishOp(win.mAppOp, win.getOwningUid(), win.getOwningPackage());
@@ -2486,7 +2694,7 @@ public class WindowManagerService extends IWindowManager.Stub
         mPendingRemove.remove(win);
         mResizingWindows.remove(win);
         mWindowsChanged = true;
-        if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Final remove of window: " + win);
+        if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG, "Final remove of window: " + win);
 
         if (mInputMethodWindow == win) {
             mInputMethodWindow = null;
@@ -2496,12 +2704,12 @@ public class WindowManagerService extends IWindowManager.Stub
 
         final WindowToken token = win.mToken;
         final AppWindowToken atoken = win.mAppToken;
-        if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Removing " + win + " from " + token);
+        if (DEBUG_ADD_REMOVE) Log.d(TAG, "Removing " + win + " from " + token);
         token.windows.remove(win);
         if (atoken != null) {
             atoken.allAppWindows.remove(win);
         }
-        if (localLOGV) Slog.v(
+        if (localLOGV) Log.d(
                 TAG, "**** Removing window " + win + ": count="
                 + token.windows.size());
         if (token.windows.size() == 0) {
@@ -2514,13 +2722,13 @@ public class WindowManagerService extends IWindowManager.Stub
 
         if (atoken != null) {
             if (atoken.startingWindow == win) {
-                if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Nulling startingWindow " + win);
+                if (DEBUG_STARTING_WINDOW) Log.d(TAG, "Nulling startingWindow " + win);
                 removeStartingWindowTimeout(atoken);
                 atoken.startingWindow = null;
             } else if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
                 // If this is the last window and we had requested a starting
                 // transition window, well there is no point now.
-                if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Nulling last startingWindow");
+                if (DEBUG_STARTING_WINDOW) Log.d(TAG, "Nulling last startingWindow");
                 atoken.startingData = null;
             } else if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
                 // If this is the last window except for a starting transition
@@ -2571,18 +2779,18 @@ public class WindowManagerService extends IWindowManager.Stub
     static void logSurface(WindowState w, String msg, RuntimeException where) {
         String str = "  SURFACE " + msg + ": " + w;
         if (where != null) {
-            Slog.i(TAG, str, where);
+            Log.d(TAG, str, where);
         } else {
-            Slog.i(TAG, str);
+            Log.d(TAG, str);
         }
     }
 
     static void logSurface(SurfaceControl s, String title, String msg, RuntimeException where) {
         String str = "  SURFACE " + s + ": " + msg + " / " + title;
         if (where != null) {
-            Slog.i(TAG, str, where);
+            Log.d(TAG, str, where);
         } else {
-            Slog.i(TAG, str);
+            Log.d(TAG, str);
         }
     }
 
@@ -2741,6 +2949,14 @@ public class WindowManagerService extends IWindowManager.Stub
             int requestedHeight, int viewVisibility, int flags,
             Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
             Rect outVisibleInsets, Configuration outConfig, Surface outSurface) {
+        Log.d(TAG,"Ritter::WMS relayoutWindow() requestedWidth:"+requestedWidth
+                + ",requestedHeight:"+requestedHeight);
+        if(attrs!=null)Log.d(TAG,"Ritter::WMS relayoutWindow() attrs x:"+attrs.x
+                +",y:"+attrs.y
+                +",width:"+attrs.width
+                +",height:"+attrs.height
+                +",pkgName:"+attrs.packageName
+                +",isInWindowing:"+attrs.isInWindowing);
         boolean toBeDisplayed = false;
         boolean inTouchMode;
         boolean configChanged;
@@ -2769,6 +2985,7 @@ public class WindowManagerService extends IWindowManager.Stub
             if (win.mRequestedWidth != requestedWidth
                     || win.mRequestedHeight != requestedHeight) {
                 win.mLayoutNeeded = true;
+                Log.d(TAG,"Ritter::WMS relayoutWindow() win.mLayoutNeeded = true;");
                 win.mRequestedWidth = requestedWidth;
                 win.mRequestedHeight = requestedHeight;
             }
@@ -2786,19 +3003,46 @@ public class WindowManagerService extends IWindowManager.Stub
             int attrChanges = 0;
             int flagChanges = 0;
             if (attrs != null) {
+                Log.d(TAG,"Ritter::WMS relayoutWindow() attrs != null copyFrom");
+                Log.d(TAG,"Ritter::WMS relayoutWindow() attrs != null win.mAttrs.type:"+win.mAttrs.type+",win.mAttrs.packageName:"+win.mAttrs.packageName);
+                Log.d(TAG,"Ritter::WMS relayoutWindow() attrs != null attrs.type:"+attrs.type+",attrs.packageName:"+attrs.packageName);
                 if (win.mAttrs.type != attrs.type) {
-                    throw new IllegalArgumentException(
-                            "Window type can not be changed after the window is added.");
+                    //Ritter_multi old
+//                    throw new IllegalArgumentException(
+//                            "Window type can not be changed after the window is added.");
+
+                    //Ritter_multi new
+                    /** I don't know why,
+                     * when close the task contains multi windows,
+                     * the type will change and throw exception crash.
+                     * So, only allow this logic when not in multi window situation.
+                     */
+                    // Get window apps from service
+                    String APPs = "";
+                    WindowAppsManager mWindowAppsManager = (WindowAppsManager) mContext
+                            .getSystemService("window_apps");
+                    try {
+                        APPs = mWindowAppsManager.getWindowApps();
+                    } catch (Exception e){
+                        e.printStackTrace();
+                    }
+                    ArrayList<String> pkgList = new ArrayList<String>(Arrays.asList(APPs.split("#")));
+
+                    if (!pkgList.contains(attrs.packageName)) {
+                        throw new IllegalArgumentException(
+                                "Window type can not be changed after the window is added.");
+                    }
                 }
                 flagChanges = win.mAttrs.flags ^= attrs.flags;
                 attrChanges = win.mAttrs.copyFrom(attrs);
                 if ((attrChanges & (WindowManager.LayoutParams.LAYOUT_CHANGED
                         | WindowManager.LayoutParams.SYSTEM_UI_VISIBILITY_CHANGED)) != 0) {
                     win.mLayoutNeeded = true;
+                    Log.d(TAG,"Ritter::WMS relayoutWindow() win.mLayoutNeeded = true2");
                 }
             }
 
-            if (DEBUG_LAYOUT) Slog.v(TAG, "Relayout " + win + ": viewVisibility=" + viewVisibility
+            if (DEBUG_LAYOUT) Log.d(TAG, "Relayout " + win + ": viewVisibility=" + viewVisibility
                     + " req=" + requestedWidth + "x" + requestedHeight + " " + win.mAttrs);
 
             win.mEnforceSizeCompat =
@@ -2839,7 +3083,7 @@ public class WindowManagerService extends IWindowManager.Stub
             if (DEBUG_SCREEN_ON) {
                 RuntimeException stack = new RuntimeException();
                 stack.fillInStackTrace();
-                Slog.i(TAG, "Relayout " + win + ": oldVis=" + oldVisibility
+                Log.d(TAG, "Relayout " + win + ": oldVis=" + oldVisibility
                         + " newVis=" + viewVisibility, stack);
             }
             if (viewVisibility == View.VISIBLE &&
@@ -2862,12 +3106,12 @@ public class WindowManagerService extends IWindowManager.Stub
                     }
                     if ((win.mAttrs.flags
                             & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
-                        if (DEBUG_VISIBILITY) Slog.v(TAG,
+                        if (DEBUG_VISIBILITY) Log.d(TAG,
                                 "Relayout window turning screen on: " + win);
                         win.mTurnOnScreen = true;
                     }
                     if (win.isConfigChanged()) {
-                        if (DEBUG_CONFIGURATION) Slog.i(TAG, "Window " + win
+                        if (DEBUG_CONFIGURATION) Log.d(TAG, "Window " + win
                                 + " visible with new config: " + mCurConfiguration);
                         outConfig.setTo(mCurConfiguration);
                     }
@@ -2885,7 +3129,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     SurfaceControl surfaceControl = winAnimator.createSurfaceLocked();
                     if (surfaceControl != null) {
                         outSurface.copyFrom(surfaceControl);
-                        if (SHOW_TRANSACTIONS) Slog.i(TAG,
+                        if (SHOW_TRANSACTIONS) Log.d(TAG,
                                 "  OUT SURFACE " + outSurface + ": copied");
                     } else {
                         // For some reason there isn't a surface.  Clear the
@@ -2925,7 +3169,7 @@ public class WindowManagerService extends IWindowManager.Stub
             } else {
                 winAnimator.mEnterAnimationPending = false;
                 if (winAnimator.mSurfaceControl != null) {
-                    if (DEBUG_VISIBILITY) Slog.i(TAG, "Relayout invis " + win
+                    if (DEBUG_VISIBILITY) Log.d(TAG, "Relayout invis " + win
                             + ": mExiting=" + win.mExiting);
                     // If we are not currently running the exit animation, we
                     // need to see about starting one.
@@ -2966,7 +3210,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
 
                 outSurface.release();
-                if (DEBUG_VISIBILITY) Slog.i(TAG, "Releasing surface in: " + win);
+                if (DEBUG_VISIBILITY) Log.d(TAG, "Releasing surface in: " + win);
             }
 
             if (focusMayChange) {
@@ -3010,7 +3254,7 @@ public class WindowManagerService extends IWindowManager.Stub
             outOverscanInsets.set(win.mOverscanInsets);
             outContentInsets.set(win.mContentInsets);
             outVisibleInsets.set(win.mVisibleInsets);
-            if (localLOGV) Slog.v(
+            if (localLOGV) Log.d(
                 TAG, "Relayout given client " + client.asBinder()
                 + ", requestedWidth=" + requestedWidth
                 + ", requestedHeight=" + requestedHeight
@@ -3018,7 +3262,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 + "\nRelayout returning frame=" + outFrame
                 + ", surface=" + outSurface);
 
-            if (localLOGV || DEBUG_FOCUS) Slog.v(
+            if (localLOGV || DEBUG_FOCUS) Log.d(
                 TAG, "Relayout of " + win + ": focusMayChange=" + focusMayChange);
 
             inTouchMode = mInTouchMode;
@@ -3030,7 +3274,7 @@ public class WindowManagerService extends IWindowManager.Stub
             mInputMonitor.updateInputWindowsLw(true /*force*/);
 
             if (DEBUG_LAYOUT) {
-                Slog.v(TAG, "Relayout complete " + win + ": outFrame=" + outFrame.toShortString());
+                Log.d(TAG, "Relayout complete " + win + ": outFrame=" + outFrame.toShortString());
             }
         }
 
@@ -3187,7 +3431,7 @@ public class WindowManagerService extends IWindowManager.Stub
             DisplayInfo displayInfo = getDefaultDisplayInfoLocked();
             final int width = displayInfo.appWidth;
             final int height = displayInfo.appHeight;
-            if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM) Slog.v(TAG, "applyAnimation: atoken="
+            if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM) Log.d(TAG, "applyAnimation: atoken="
                     + atoken);
             Animation a = mAppTransition.loadAnimation(lp, transit, enter, width, height);
             if (a != null) {
@@ -3197,7 +3441,7 @@ public class WindowManagerService extends IWindowManager.Stub
                         e = new RuntimeException();
                         e.fillInStackTrace();
                     }
-                    Slog.v(TAG, "Loaded animation " + a + " for " + atoken, e);
+                    Log.d(TAG, "Loaded animation " + a + " for " + atoken, e);
                 }
                 atoken.mAppAnimator.setAnimation(a, width, height);
             }
@@ -3434,7 +3678,7 @@ public class WindowManagerService extends IWindowManager.Stub
             atoken.appFullscreen = fullscreen;
             atoken.showWhenLocked = showWhenLocked;
             atoken.requestedOrientation = requestedOrientation;
-            if (DEBUG_TOKEN_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(TAG, "addAppToken: " + atoken
+            if (DEBUG_TOKEN_MOVEMENT || DEBUG_ADD_REMOVE) Log.d(TAG, "addAppToken: " + atoken
                     + " to stack=" + stackId + " task=" + taskId + " at " + addPos);
 
             Task task = mTaskIdToTask.get(taskId);
@@ -3509,7 +3753,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 continue;
             }
 
-            if (DEBUG_ORIENTATION) Slog.v(TAG, win + " forcing orientation to " + req);
+            if (DEBUG_ORIENTATION) Log.d(TAG, win + " forcing orientation to " + req);
             return (mLastWindowForcedOrientation=req);
         }
         return (mLastWindowForcedOrientation=ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
@@ -3528,13 +3772,13 @@ public class WindowManagerService extends IWindowManager.Stub
             for (int tokenNdx = firstToken; tokenNdx >= 0; --tokenNdx) {
                 final AppWindowToken atoken = tokens.get(tokenNdx);
 
-                if (DEBUG_APP_ORIENTATION) Slog.v(TAG, "Checking app orientation: " + atoken);
+                if (DEBUG_APP_ORIENTATION) Log.d(TAG, "Checking app orientation: " + atoken);
 
                 // if we're about to tear down this window and not seek for
                 // the behind activity, don't use it for orientation
                 if (!findingBehind
                         && (!atoken.hidden && atoken.hiddenRequested)) {
-                    if (DEBUG_ORIENTATION) Slog.v(TAG, "Skipping " + atoken
+                    if (DEBUG_ORIENTATION) Log.d(TAG, "Skipping " + atoken
                             + " -- going to hide");
                     continue;
                 }
@@ -3547,7 +3791,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     // user's orientation.
                     if (lastOrientation != ActivityInfo.SCREEN_ORIENTATION_BEHIND
                             && lastFullscreen) {
-                        if (DEBUG_ORIENTATION) Slog.v(TAG, "Done at " + atoken
+                        if (DEBUG_ORIENTATION) Log.d(TAG, "Done at " + atoken
                                 + " -- end of group, return " + lastOrientation);
                         return lastOrientation;
                     }
@@ -3555,7 +3799,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
                 // We ignore any hidden applications on the top.
                 if (atoken.hiddenRequested || atoken.willBeHidden) {
-                    if (DEBUG_ORIENTATION) Slog.v(TAG, "Skipping " + atoken
+                    if (DEBUG_ORIENTATION) Log.d(TAG, "Skipping " + atoken
                             + " -- hidden on top");
                     continue;
                 }
@@ -3572,7 +3816,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 lastFullscreen = atoken.appFullscreen;
                 if (lastFullscreen
                         && or != ActivityInfo.SCREEN_ORIENTATION_BEHIND) {
-                    if (DEBUG_ORIENTATION) Slog.v(TAG, "Done at " + atoken
+                    if (DEBUG_ORIENTATION) Log.d(TAG, "Done at " + atoken
                             + " -- full screen, return " + or);
                     return or;
                 }
@@ -3580,14 +3824,14 @@ public class WindowManagerService extends IWindowManager.Stub
                 // then use it.
                 if (or != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
                         && or != ActivityInfo.SCREEN_ORIENTATION_BEHIND) {
-                    if (DEBUG_ORIENTATION) Slog.v(TAG, "Done at " + atoken
+                    if (DEBUG_ORIENTATION) Log.d(TAG, "Done at " + atoken
                             + " -- explicitly set, return " + or);
                     return or;
                 }
                 findingBehind |= (or == ActivityInfo.SCREEN_ORIENTATION_BEHIND);
             }
         }
-        if (DEBUG_ORIENTATION) Slog.v(TAG, "No app is requesting an orientation");
+        if (DEBUG_ORIENTATION) Log.d(TAG, "No app is requesting an orientation");
         return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
     }
 
@@ -3751,7 +3995,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
             }
         }
-        if (DEBUG_LAYERS) Slog.v(TAG, "Setting FocusedStackFrame to layer=" +
+        if (DEBUG_LAYERS) Log.d(TAG, "Setting FocusedStackFrame to layer=" +
                 mFocusedStackLayer);
         mFocusedStackFrame.setLayer(mFocusedStackLayer);
     }
@@ -3765,7 +4009,7 @@ public class WindowManagerService extends IWindowManager.Stub
         } else {
             stack = null;
         }
-        if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG, ">>> OPEN TRANSACTION setFocusedStackFrame");
+        if (SHOW_LIGHT_TRANSACTIONS) Log.d(TAG, ">>> OPEN TRANSACTION setFocusedStackFrame");
         SurfaceControl.openTransaction();
         try {
             if (stack == null) {
@@ -3779,12 +4023,13 @@ public class WindowManagerService extends IWindowManager.Stub
             }
         } finally {
             SurfaceControl.closeTransaction();
-            if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG, ">>> CLOSE TRANSACTION setFocusedStackFrame");
+            if (SHOW_LIGHT_TRANSACTIONS) Log.d(TAG, ">>> CLOSE TRANSACTION setFocusedStackFrame");
         }
     }
 
     @Override
     public void setFocusedApp(IBinder token, boolean moveFocusNow) {
+        Log.d(TAG,"Ritter::WMS setFocusedApp()");
         if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                 "setFocusedApp()")) {
             throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
@@ -3793,7 +4038,7 @@ public class WindowManagerService extends IWindowManager.Stub
         synchronized(mWindowMap) {
             boolean changed = false;
             if (token == null) {
-                if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "Clearing focused app, was " + mFocusedApp);
+                if (DEBUG_FOCUS_LIGHT) Log.d(TAG, "Clearing focused app, was " + mFocusedApp);
                 changed = mFocusedApp != null;
                 mFocusedApp = null;
                 if (changed) {
@@ -3806,7 +4051,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     return;
                 }
                 changed = mFocusedApp != newFocus;
-                if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "Set focused app to: " + newFocus
+                if (DEBUG_FOCUS_LIGHT) Log.d(TAG, "Set focused app to: " + newFocus
                         + " old focus=" + mFocusedApp + " moveFocusNow=" + moveFocusNow);
                 mFocusedApp = newFocus;
                 if (changed) {
@@ -3824,14 +4069,15 @@ public class WindowManagerService extends IWindowManager.Stub
 
     @Override
     public void prepareAppTransition(int transit, boolean alwaysKeepCurrent) {
+        Log.d(TAG,"Ritter::WMS prepareAppTransition()");
         if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                 "prepareAppTransition()")) {
             throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
         }
 
         synchronized(mWindowMap) {
-            if (DEBUG_APP_TRANSITIONS) Slog.v(
-                    TAG, "Prepare app transition: transit=" + transit
+            if (true||DEBUG_APP_TRANSITIONS) Log.d(
+                    TAG, "Ritter::WMS Prepare app transition: transit=" + transit
                     + " " + mAppTransition
                     + " alwaysKeepCurrent=" + alwaysKeepCurrent
                     + " Callers=" + Debug.getCallers(3));
@@ -3925,7 +4171,7 @@ public class WindowManagerService extends IWindowManager.Stub
         }
 
         synchronized(mWindowMap) {
-            if (DEBUG_STARTING_WINDOW) Slog.v(
+            if (DEBUG_STARTING_WINDOW) Log.d(
                     TAG, "setAppStartingWindow: token=" + token + " pkg=" + pkg
                     + " transferFrom=" + transferFrom);
 
@@ -3957,7 +4203,7 @@ public class WindowManagerService extends IWindowManager.Stub
                             // shown immediately without any more transitions.
                             mSkipAppTransitionAnimation = true;
                         }
-                        if (DEBUG_STARTING_WINDOW) Slog.v(TAG,
+                        if (DEBUG_STARTING_WINDOW) Log.d(TAG,
                                 "Moving existing starting " + startingWindow + " from " + ttoken
                                 + " to " + wtoken);
                         final long origId = Binder.clearCallingIdentity();
@@ -3980,12 +4226,12 @@ public class WindowManagerService extends IWindowManager.Stub
                         startingWindow.mWinAnimator.mAppAnimator = wtoken.mAppAnimator;
 
                         if (DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE || DEBUG_STARTING_WINDOW) {
-                            Slog.v(TAG, "Removing starting window: " + startingWindow);
+                            Log.d(TAG, "Removing starting window: " + startingWindow);
                         }
                         removeStartingWindowTimeout(ttoken);
                         startingWindow.getWindowList().remove(startingWindow);
                         mWindowsChanged = true;
-                        if (DEBUG_ADD_REMOVE) Slog.v(TAG,
+                        if (DEBUG_ADD_REMOVE) Log.d(TAG,
                                 "Removing starting " + startingWindow + " from " + ttoken);
                         ttoken.windows.remove(startingWindow);
                         ttoken.allAppWindows.remove(startingWindow);
@@ -4033,7 +4279,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     } else if (ttoken.startingData != null) {
                         // The previous app was getting ready to show a
                         // starting window, but hasn't yet done so.  Steal it!
-                        if (DEBUG_STARTING_WINDOW) Slog.v(TAG,
+                        if (DEBUG_STARTING_WINDOW) Log.d(TAG,
                                 "Moving pending starting from " + ttoken
                                 + " to " + wtoken);
                         wtoken.startingData = ttoken.startingData;
@@ -4074,7 +4320,7 @@ public class WindowManagerService extends IWindowManager.Stub
             // show a starting window -- the current effect (a full-screen
             // opaque starting window that fades away to the real contents
             // when it is ready) does not work for this.
-            if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Checking theme of starting window: 0x"
+            if (DEBUG_STARTING_WINDOW) Log.d(TAG, "Checking theme of starting window: 0x"
                     + Integer.toHexString(theme));
             if (theme != 0) {
                 AttributeCache.Entry ent = AttributeCache.instance().get(pkg, theme,
@@ -4084,7 +4330,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     // pretend like we didn't see that.
                     return;
                 }
-                if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Translucent="
+                if (DEBUG_STARTING_WINDOW) Log.d(TAG, "Translucent="
                         + ent.array.getBoolean(
                                 com.android.internal.R.styleable.Window_windowIsTranslucent, false)
                         + " Floating="
@@ -4116,7 +4362,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
             }
 
-            if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Creating StartingData");
+            if (DEBUG_STARTING_WINDOW) Log.d(TAG, "Creating StartingData");
             mStartingIconInTransition = true;
             wtoken.startingData = new StartingData(pkg, theme, compatInfo, nonLocalizedLabel,
                     labelRes, icon, logo, windowFlags);
@@ -4124,13 +4370,14 @@ public class WindowManagerService extends IWindowManager.Stub
             // Note: we really want to do sendMessageAtFrontOfQueue() because we
             // want to process the message ASAP, before any other queued
             // messages.
-            if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Enqueueing ADD_STARTING");
+            if (DEBUG_STARTING_WINDOW) Log.d(TAG, "Enqueueing ADD_STARTING");
             mH.sendMessageAtFrontOfQueue(m);
         }
     }
 
     @Override
     public void setAppWillBeHidden(IBinder token) {
+        Log.d(TAG,"Ritter::WMS setAppWillBeHidden()");
         if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                 "setAppWillBeHidden()")) {
             throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
@@ -4158,6 +4405,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
     boolean setTokenVisibilityLocked(AppWindowToken wtoken, WindowManager.LayoutParams lp,
             boolean visible, int transit, boolean performLayout) {
+        Log.d(TAG,"Ritter::WMS setTokenVisibilityLocked()");
         boolean delayed = false;
 
         if (wtoken.clientHidden == visible) {
@@ -4168,8 +4416,8 @@ public class WindowManagerService extends IWindowManager.Stub
         wtoken.willBeHidden = false;
         if (wtoken.hidden == visible) {
             boolean changed = false;
-            if (DEBUG_APP_TRANSITIONS) Slog.v(
-                TAG, "Changing app " + wtoken + " hidden=" + wtoken.hidden
+            if (true||DEBUG_APP_TRANSITIONS) Log.d(
+                TAG, "Ritter::WMS Changing app " + wtoken + " hidden=" + wtoken.hidden
                 + " performLayout=" + performLayout);
 
             boolean runningAppAnimation = false;
@@ -4197,7 +4445,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     continue;
                 }
 
-                //Slog.i(TAG, "Window " + win + ": vis=" + win.isVisible());
+                //Log.d(TAG, "Window " + win + ": vis=" + win.isVisible());
                 //win.dump("  ");
                 if (visible) {
                     if (!win.isVisibleNow()) {
@@ -4243,7 +4491,7 @@ public class WindowManagerService extends IWindowManager.Stub
                  }
             }
 
-            if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "setTokenVisibilityLocked: " + wtoken
+            if (DEBUG_APP_TRANSITIONS) Log.d(TAG, "setTokenVisibilityLocked: " + wtoken
                       + ": hidden=" + wtoken.hidden + " hiddenRequested="
                       + wtoken.hiddenRequested);
 
@@ -4273,6 +4521,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
     @Override
     public void setAppVisibility(IBinder token, boolean visible) {
+        Log.d(TAG,"Ritter::WMS setAppVisibility()");
         if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                 "setAppVisibility()")) {
             throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
@@ -4287,13 +4536,13 @@ public class WindowManagerService extends IWindowManager.Stub
                 return;
             }
 
-            if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
+            if (true||DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
                 RuntimeException e = null;
                 if (!HIDE_STACK_CRAWLS) {
                     e = new RuntimeException();
                     e.fillInStackTrace();
                 }
-                Slog.v(TAG, "setAppVisibility(" + token + ", visible=" + visible
+                Log.d(TAG, "Ritter::WMS setAppVisibility(" + token + ", visible=" + visible
                         + "): " + mAppTransition
                         + " hidden=" + wtoken.hidden
                         + " hiddenRequested=" + wtoken.hiddenRequested, e);
@@ -4309,7 +4558,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 wtoken.hiddenRequested = !visible;
 
                 if (!wtoken.startingDisplayed) {
-                    if (DEBUG_APP_TRANSITIONS) Slog.v(
+                    if (DEBUG_APP_TRANSITIONS) Log.d(
                             TAG, "Setting dummy animation on: " + wtoken);
                     wtoken.mAppAnimator.setDummyAnimation();
                 }
@@ -4363,7 +4612,7 @@ public class WindowManagerService extends IWindowManager.Stub
     void unsetAppFreezingScreenLocked(AppWindowToken wtoken,
             boolean unfreezeSurfaceNow, boolean force) {
         if (wtoken.mAppAnimator.freezingScreen) {
-            if (DEBUG_ORIENTATION) Slog.v(TAG, "Clear freezing of " + wtoken
+            if (DEBUG_ORIENTATION) Log.d(TAG, "Clear freezing of " + wtoken
                     + " force=" + force);
             final int N = wtoken.allAppWindows.size();
             boolean unfrozeWindows = false;
@@ -4372,7 +4621,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 if (w.mAppFreezing) {
                     w.mAppFreezing = false;
                     if (w.mHasSurface && !w.mOrientationChanging) {
-                        if (DEBUG_ORIENTATION) Slog.v(TAG, "set mOrientationChanging of " + w);
+                        if (DEBUG_ORIENTATION) Log.d(TAG, "set mOrientationChanging of " + w);
                         w.mOrientationChanging = true;
                         mInnerFields.mOrientationChangeComplete = false;
                     }
@@ -4382,7 +4631,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
             }
             if (force || unfrozeWindows) {
-                if (DEBUG_ORIENTATION) Slog.v(TAG, "No longer freezing: " + wtoken);
+                if (DEBUG_ORIENTATION) Log.d(TAG, "No longer freezing: " + wtoken);
                 wtoken.mAppAnimator.freezingScreen = false;
                 wtoken.mAppAnimator.lastFreezeDuration = (int)(SystemClock.elapsedRealtime()
                         - mDisplayFreezeTime);
@@ -4406,7 +4655,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 e = new RuntimeException();
                 e.fillInStackTrace();
             }
-            Slog.i(TAG, "Set freezing of " + wtoken.appToken
+            Log.d(TAG, "Set freezing of " + wtoken.appToken
                     + ": hidden=" + wtoken.hidden + " freezing="
                     + wtoken.mAppAnimator.freezingScreen, e);
         }
@@ -4438,7 +4687,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
         synchronized(mWindowMap) {
             if (configChanges == 0 && okToDisplay()) {
-                if (DEBUG_ORIENTATION) Slog.v(TAG, "Skipping set freeze of " + token);
+                if (DEBUG_ORIENTATION) Log.d(TAG, "Skipping set freeze of " + token);
                 return;
             }
 
@@ -4466,7 +4715,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 return;
             }
             final long origId = Binder.clearCallingIdentity();
-            if (DEBUG_ORIENTATION) Slog.v(TAG, "Clear freezing of " + token
+            if (DEBUG_ORIENTATION) Log.d(TAG, "Clear freezing of " + token
                     + ": hidden=" + wtoken.hidden + " freezing=" + wtoken.mAppAnimator.freezingScreen);
             unsetAppFreezingScreenLocked(wtoken, true, force);
             Binder.restoreCallingIdentity(origId);
@@ -4488,7 +4737,7 @@ public class WindowManagerService extends IWindowManager.Stub
         synchronized(mWindowMap) {
             WindowToken basewtoken = mTokenMap.remove(token);
             if (basewtoken != null && (wtoken=basewtoken.appWindowToken) != null) {
-                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "Removing app token: " + wtoken);
+                if (DEBUG_APP_TRANSITIONS) Log.d(TAG, "Removing app token: " + wtoken);
                 delayed = setTokenVisibilityLocked(wtoken, null, false,
                         AppTransition.TRANSIT_UNSET, true);
                 wtoken.inPendingTransaction = false;
@@ -4501,7 +4750,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     wtoken.waitingToHide = true;
                     delayed = true;
                 }
-                if (DEBUG_APP_TRANSITIONS) Slog.v(
+                if (DEBUG_APP_TRANSITIONS) Log.d(
                         TAG, "Removing app " + wtoken + " delayed=" + delayed
                         + " animation=" + wtoken.mAppAnimator.animation
                         + " animating=" + wtoken.mAppAnimator.animating);
@@ -4509,7 +4758,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 DisplayContent displayContent = task.getDisplayContent();
                 if (delayed) {
                     // set the token aside because it has an active animation to be finished
-                    if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT) Slog.v(TAG,
+                    if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT) Log.d(TAG,
                             "removeAppToken make exiting: " + wtoken);
                     displayContent.mExitingAppTokens.add(wtoken);
                 } else {
@@ -4519,7 +4768,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     wtoken.mAppAnimator.clearAnimation();
                     wtoken.mAppAnimator.animating = false;
                 }
-                if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT) Slog.v(TAG,
+                if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT) Log.d(TAG,
                         "removeAppToken: " + wtoken);
 
                 if (task.removeAppToken(wtoken)) {
@@ -4531,7 +4780,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
                 unsetAppFreezingScreenLocked(wtoken, true, true);
                 if (mFocusedApp == wtoken) {
-                    if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "Removing focused app token:" + wtoken);
+                    if (DEBUG_FOCUS_LIGHT) Log.d(TAG, "Removing focused app token:" + wtoken);
                     mFocusedApp = null;
                     updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true /*updateInputWindows*/);
                     mInputMonitor.setFocusedAppLw(null);
@@ -4552,7 +4801,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
     void removeStartingWindowTimeout(AppWindowToken wtoken) {
         if (wtoken != null) {
-            if (DEBUG_STARTING_WINDOW) Slog.v(TAG, Debug.getCallers(1) +
+            if (DEBUG_STARTING_WINDOW) Log.d(TAG, Debug.getCallers(1) +
                     ": Remove starting window timeout " + wtoken + (wtoken != null ?
                     " startingWindow=" + wtoken.startingWindow : ""));
             mH.removeMessages(H.REMOVE_STARTING_TIMEOUT, wtoken);
@@ -4561,7 +4810,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
     void scheduleRemoveStartingWindow(AppWindowToken wtoken) {
         if (wtoken != null && wtoken.startingWindow != null) {
-            if (DEBUG_STARTING_WINDOW) Slog.v(TAG, Debug.getCallers(1) +
+            if (DEBUG_STARTING_WINDOW) Log.d(TAG, Debug.getCallers(1) +
                     ": Schedule remove starting " + wtoken + (wtoken != null ?
                     " startingWindow=" + wtoken.startingWindow : ""));
             removeStartingWindowTimeout(wtoken);
@@ -4576,13 +4825,13 @@ public class WindowManagerService extends IWindowManager.Stub
         }
         for (int i=0; i<NW; i++) {
             WindowState win = token.windows.get(i);
-            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Tmp removing app window " + win);
+            if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG, "Tmp removing app window " + win);
             win.getWindowList().remove(win);
             int j = win.mChildWindows.size();
             while (j > 0) {
                 j--;
                 WindowState cwin = win.mChildWindows.get(j);
-                if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG,
+                if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG,
                         "Tmp removing child window " + cwin);
                 cwin.getWindowList().remove(cwin);
             }
@@ -4594,14 +4843,14 @@ public class WindowManagerService extends IWindowManager.Stub
         final int numDisplays = mDisplayContents.size();
         for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
             final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
-            Slog.v(TAG, "  Display " + displayContent.getDisplayId());
+            Log.d(TAG, "  Display " + displayContent.getDisplayId());
             final ArrayList<Task> tasks = displayContent.getTasks();
             int i = displayContent.numTokens();
             for (int taskNdx = tasks.size() - 1; taskNdx >= 0; --taskNdx) {
                 AppTokenList tokens = tasks.get(taskNdx).mAppTokens;
                 for (int tokenNdx = tokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
                     final AppWindowToken wtoken = tokens.get(tokenNdx);
-                    Slog.v(TAG, "  #" + --i + ": " + wtoken.token);
+                    Log.d(TAG, "  #" + --i + ": " + wtoken.token);
                 }
             }
         }
@@ -4613,7 +4862,7 @@ public class WindowManagerService extends IWindowManager.Stub
         for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
             final WindowList windows = mDisplayContents.valueAt(displayNdx).getWindowList();
             for (int winNdx = windows.size() - 1; winNdx >= 0; --winNdx) {
-                Slog.v(TAG, "  #" + i++ + ": " + windows.get(winNdx));
+                Log.d(TAG, "  #" + i++ + ": " + windows.get(winNdx));
             }
         }
     }
@@ -4650,9 +4899,9 @@ public class WindowManagerService extends IWindowManager.Stub
                 if (found) {
                     // Find the first app token below the new position that has
                     // a window displayed.
-                    if (DEBUG_REORDER) Slog.v(TAG, "Looking for lower windows in " + wtoken.token);
+                    if (DEBUG_REORDER) Log.d(TAG, "Looking for lower windows in " + wtoken.token);
                     if (wtoken.sendingToBottom) {
-                        if (DEBUG_REORDER) Slog.v(TAG, "Skipping token -- currently sending to bottom");
+                        if (DEBUG_REORDER) Log.d(TAG, "Skipping token -- currently sending to bottom");
                         continue;
                     }
                     for (int i = wtoken.windows.size() - 1; i >= 0; --i) {
@@ -4662,7 +4911,7 @@ public class WindowManagerService extends IWindowManager.Stub
                             if (cwin.mSubLayer >= 0) {
                                 for (int pos = NW - 1; pos >= 0; pos--) {
                                     if (windows.get(pos) == cwin) {
-                                        if (DEBUG_REORDER) Slog.v(TAG,
+                                        if (DEBUG_REORDER) Log.d(TAG,
                                                 "Found child win @" + (pos + 1));
                                         return pos + 1;
                                     }
@@ -4671,7 +4920,7 @@ public class WindowManagerService extends IWindowManager.Stub
                         }
                         for (int pos = NW - 1; pos >= 0; pos--) {
                             if (windows.get(pos) == win) {
-                                if (DEBUG_REORDER) Slog.v(TAG, "Found win @" + (pos + 1));
+                                if (DEBUG_REORDER) Log.d(TAG, "Found win @" + (pos + 1));
                                 return pos + 1;
                             }
                         }
@@ -4682,7 +4931,7 @@ public class WindowManagerService extends IWindowManager.Stub
         // Never put an app window underneath wallpaper.
         for (int pos = NW - 1; pos >= 0; pos--) {
             if (windows.get(pos).mIsWallpaper) {
-                if (DEBUG_REORDER) Slog.v(TAG, "Found wallpaper @" + pos);
+                if (DEBUG_REORDER) Log.d(TAG, "Found wallpaper @" + pos);
                 return pos + 1;
             }
         }
@@ -4696,21 +4945,21 @@ public class WindowManagerService extends IWindowManager.Stub
         for (int j=0; j<NCW; j++) {
             WindowState cwin = win.mChildWindows.get(j);
             if (!added && cwin.mSubLayer >= 0) {
-                if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Re-adding child window at "
+                if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG, "Re-adding child window at "
                         + index + ": " + cwin);
                 win.mRebuilding = false;
                 windows.add(index, win);
                 index++;
                 added = true;
             }
-            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Re-adding window at "
+            if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG, "Re-adding window at "
                     + index + ": " + cwin);
             cwin.mRebuilding = false;
             windows.add(index, cwin);
             index++;
         }
         if (!added) {
-            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Re-adding window at "
+            if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG, "Re-adding window at "
                     + index + ": " + win);
             win.mRebuilding = false;
             windows.add(index, win);
@@ -4777,6 +5026,7 @@ public class WindowManagerService extends IWindowManager.Stub
     }
 
     public void moveTaskToTop(int taskId) {
+        Log.d(TAG,"Ritter::WMS moveTaskToTop() taskId:"+taskId);
         final long origId = Binder.clearCallingIdentity();
         try {
             synchronized(mWindowMap) {
@@ -4801,6 +5051,7 @@ public class WindowManagerService extends IWindowManager.Stub
     }
 
     public void moveTaskToBottom(int taskId) {
+        Log.d(TAG,"Ritter::WMS moveTaskToBottom() taskId:"+taskId);
         final long origId = Binder.clearCallingIdentity();
         try {
             synchronized(mWindowMap) {
@@ -4866,7 +5117,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 requestTraversalLocked();
                 return nextStackId;
             }
-            if (DEBUG_STACK) Slog.i(TAG, "removeStack: could not find stackId=" + stackId);
+            if (DEBUG_STACK) Log.d(TAG, "removeStack: could not find stackId=" + stackId);
         }
         return HOME_STACK_ID;
     }
@@ -4875,7 +5126,7 @@ public class WindowManagerService extends IWindowManager.Stub
         synchronized (mWindowMap) {
             Task task = mTaskIdToTask.get(taskId);
             if (task == null) {
-                if (DEBUG_STACK) Slog.i(TAG, "removeTask: could not find taskId=" + taskId);
+                if (DEBUG_STACK) Log.d(TAG, "removeTask: could not find taskId=" + taskId);
                 return;
             }
             final TaskStack stack = task.mStack;
@@ -5219,7 +5470,7 @@ public class WindowManagerService extends IWindowManager.Stub
             if (DEBUG_BOOT) {
                 RuntimeException here = new RuntimeException("here");
                 here.fillInStackTrace();
-                Slog.i(TAG, "enableScreenAfterBoot: mDisplayEnabled=" + mDisplayEnabled
+                Log.d(TAG, "enableScreenAfterBoot: mDisplayEnabled=" + mDisplayEnabled
                         + " mForceDisplayEnabled=" + mForceDisplayEnabled
                         + " mShowingBootMessages=" + mShowingBootMessages
                         + " mSystemBooted=" + mSystemBooted, here);
@@ -5243,7 +5494,7 @@ public class WindowManagerService extends IWindowManager.Stub
         if (DEBUG_BOOT) {
             RuntimeException here = new RuntimeException("here");
             here.fillInStackTrace();
-            Slog.i(TAG, "enableScreenIfNeededLocked: mDisplayEnabled=" + mDisplayEnabled
+            Log.d(TAG, "enableScreenIfNeededLocked: mDisplayEnabled=" + mDisplayEnabled
                     + " mForceDisplayEnabled=" + mForceDisplayEnabled
                     + " mShowingBootMessages=" + mShowingBootMessages
                     + " mSystemBooted=" + mSystemBooted, here);
@@ -5273,7 +5524,7 @@ public class WindowManagerService extends IWindowManager.Stub
             if (DEBUG_BOOT) {
                 RuntimeException here = new RuntimeException("here");
                 here.fillInStackTrace();
-                Slog.i(TAG, "performEnableScreen: mDisplayEnabled=" + mDisplayEnabled
+                Log.d(TAG, "performEnableScreen: mDisplayEnabled=" + mDisplayEnabled
                         + " mForceDisplayEnabled=" + mForceDisplayEnabled
                         + " mShowingBootMessages=" + mShowingBootMessages
                         + " mSystemBooted=" + mSystemBooted
@@ -5332,7 +5583,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
 
                 if (DEBUG_SCREEN_ON || DEBUG_BOOT) {
-                    Slog.i(TAG, "******** booted=" + mSystemBooted + " msg=" + mShowingBootMessages
+                    Log.d(TAG, "******** booted=" + mSystemBooted + " msg=" + mShowingBootMessages
                             + " haveBoot=" + haveBootMsg + " haveApp=" + haveApp
                             + " haveWall=" + haveWallpaper + " wallEnabled=" + wallpaperEnabled
                             + " haveKeyguard=" + haveKeyguard);
@@ -5354,18 +5605,18 @@ public class WindowManagerService extends IWindowManager.Stub
             }
 
             mDisplayEnabled = true;
-            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG, "******************** ENABLING SCREEN!");
+            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Log.d(TAG, "******************** ENABLING SCREEN!");
             if (false) {
                 StringWriter sw = new StringWriter();
                 PrintWriter pw = new FastPrintWriter(sw, false, 1024);
                 this.dump(null, pw, null);
                 pw.flush();
-                Slog.i(TAG, sw.toString());
+                Log.d(TAG, sw.toString());
             }
             try {
                 IBinder surfaceFlinger = ServiceManager.getService("SurfaceFlinger");
                 if (surfaceFlinger != null) {
-                    //Slog.i(TAG, "******* TELLING SURFACE FLINGER WE ARE BOOTED!");
+                    //Log.d(TAG, "******* TELLING SURFACE FLINGER WE ARE BOOTED!");
                     Parcel data = Parcel.obtain();
                     data.writeInterfaceToken("android.ui.ISurfaceComposer");
                     surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED
@@ -5392,7 +5643,7 @@ public class WindowManagerService extends IWindowManager.Stub
             if (DEBUG_BOOT) {
                 RuntimeException here = new RuntimeException("here");
                 here.fillInStackTrace();
-                Slog.i(TAG, "showBootMessage: msg=" + msg + " always=" + always
+                Log.d(TAG, "showBootMessage: msg=" + msg + " always=" + always
                         + " mAllowBootMessages=" + mAllowBootMessages
                         + " mShowingBootMessages=" + mShowingBootMessages
                         + " mSystemBooted=" + mSystemBooted, here);
@@ -5421,7 +5672,7 @@ public class WindowManagerService extends IWindowManager.Stub
         if (DEBUG_BOOT) {
             RuntimeException here = new RuntimeException("here");
             here.fillInStackTrace();
-            Slog.i(TAG, "hideBootMessagesLocked: mDisplayEnabled=" + mDisplayEnabled
+            Log.d(TAG, "hideBootMessagesLocked: mDisplayEnabled=" + mDisplayEnabled
                     + " mForceDisplayEnabled=" + mForceDisplayEnabled
                     + " mShowingBootMessages=" + mShowingBootMessages
                     + " mSystemBooted=" + mSystemBooted, here);
@@ -5473,7 +5724,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
             }
 
-            if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
+            if (SHOW_LIGHT_TRANSACTIONS) Log.d(TAG,
                     ">>> OPEN TRANSACTION showStrictModeViolation");
             SurfaceControl.openTransaction();
             try {
@@ -5485,7 +5736,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 mStrictModeFlash.setVisibility(on);
             } finally {
                 SurfaceControl.closeTransaction();
-                if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
+                if (SHOW_LIGHT_TRANSACTIONS) Log.d(TAG,
                         "<<< CLOSE TRANSACTION showStrictModeViolation");
             }
         }
@@ -5631,13 +5882,13 @@ public class WindowManagerService extends IWindowManager.Stub
 
                 if (appToken != null && appWin == null) {
                     // Can't find a window to snapshot.
-                    if (DEBUG_SCREENSHOT) Slog.i(TAG,
+                    if (DEBUG_SCREENSHOT) Log.d(TAG,
                             "Screenshot: Couldn't find a surface matching " + appToken);
                     return null;
                 }
                 if (!screenshotReady) {
                     // Delay and hope that window gets drawn.
-                    if (DEBUG_SCREENSHOT) Slog.i(TAG, "Screenshot: No image ready for " + appToken
+                    if (DEBUG_SCREENSHOT) Log.d(TAG, "Screenshot: No image ready for " + appToken
                             + ", " + appWin + " drawState=" + appWin.mWinAnimator.mDrawState);
                     continue;
                 }
@@ -5646,7 +5897,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 frame.intersect(0, 0, dw, dh);
 
                 if (frame.isEmpty() || maxLayer == 0) {
-                    if (DEBUG_SCREENSHOT) Slog.i(TAG, "Screenshot of " + appToken
+                    if (DEBUG_SCREENSHOT) Log.d(TAG, "Screenshot of " + appToken
                             + ": returning null frame=" + frame.toShortString() + " maxLayer="
                             + maxLayer);
                     return null;
@@ -5690,11 +5941,11 @@ public class WindowManagerService extends IWindowManager.Stub
                     rot = (rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
                 }
                 if (DEBUG_SCREENSHOT) {
-                    Slog.i(TAG, "Screenshot: " + dw + "x" + dh + " from " + minLayer + " to "
+                    Log.d(TAG, "Screenshot: " + dw + "x" + dh + " from " + minLayer + " to "
                             + maxLayer + " appToken=" + appToken);
                     for (int i = 0; i < windows.size(); i++) {
                         WindowState win = windows.get(i);
-                        Slog.i(TAG, win + ": " + win.mLayer
+                        Log.d(TAG, win + ": " + win.mLayer
                                 + " animLayer=" + win.mWinAnimator.mAnimLayer
                                 + " surfaceLayer=" + win.mWinAnimator.mSurfaceLayer);
                     }
@@ -5702,7 +5953,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 rawss = SurfaceControl.screenshot(dw, dh, minLayer, maxLayer);
             }
         } while (!screenshotReady && retryCount <= MAX_SCREENSHOT_RETRIES);
-        if (retryCount > MAX_SCREENSHOT_RETRIES)  Slog.i(TAG, "Screenshot max retries " +
+        if (retryCount > MAX_SCREENSHOT_RETRIES)  Log.d(TAG, "Screenshot max retries " +
                 retryCount + " of " + appToken + " appWin=" + (appWin == null ?
                         "null" : (appWin + " drawState=" + appWin.mWinAnimator.mDrawState)));
 
@@ -5736,7 +5987,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
             }
             if (allBlack) {
-                Slog.i(TAG, "Screenshot " + appWin + " was monochrome(" +
+                Log.d(TAG, "Screenshot " + appWin + " was monochrome(" +
                         Integer.toHexString(firstColor) + ")! mSurfaceLayer=" +
                         (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : "null") +
                         " minLayer=" + minLayer + " maxLayer=" + maxLayer);
@@ -5764,7 +6015,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     + "rotation constant.");
         }
 
-        if (DEBUG_ORIENTATION) Slog.v(TAG, "freezeRotation: mRotation=" + mRotation);
+        if (DEBUG_ORIENTATION) Log.d(TAG, "freezeRotation: mRotation=" + mRotation);
 
         long origId = Binder.clearCallingIdentity();
         try {
@@ -5788,7 +6039,7 @@ public class WindowManagerService extends IWindowManager.Stub
             throw new SecurityException("Requires SET_ORIENTATION permission");
         }
 
-        if (DEBUG_ORIENTATION) Slog.v(TAG, "thawRotation: mRotation=" + mRotation);
+        if (DEBUG_ORIENTATION) Log.d(TAG, "thawRotation: mRotation=" + mRotation);
 
         long origId = Binder.clearCallingIdentity();
         try {
@@ -5842,7 +6093,7 @@ public class WindowManagerService extends IWindowManager.Stub
     }
 
     public void updateRotationUnchecked(boolean alwaysSendConfiguration, boolean forceRelayout) {
-        if(DEBUG_ORIENTATION) Slog.v(TAG, "updateRotationUnchecked("
+        if(DEBUG_ORIENTATION) Log.d(TAG, "updateRotationUnchecked("
                    + "alwaysSendConfiguration=" + alwaysSendConfiguration + ")");
 
         long origId = Binder.clearCallingIdentity();
@@ -5873,7 +6124,7 @@ public class WindowManagerService extends IWindowManager.Stub
         if (mDeferredRotationPauseCount > 0) {
             // Rotation updates have been paused temporarily.  Defer the update until
             // updates have been resumed.
-            if (DEBUG_ORIENTATION) Slog.v(TAG, "Deferring rotation, rotation is paused.");
+            if (DEBUG_ORIENTATION) Log.d(TAG, "Deferring rotation, rotation is paused.");
             return false;
         }
 
@@ -5883,13 +6134,13 @@ public class WindowManagerService extends IWindowManager.Stub
             // Rotation updates cannot be performed while the previous rotation change
             // animation is still in progress.  Skip this update.  We will try updating
             // again after the animation is finished and the display is unfrozen.
-            if (DEBUG_ORIENTATION) Slog.v(TAG, "Deferring rotation, animation in progress.");
+            if (DEBUG_ORIENTATION) Log.d(TAG, "Deferring rotation, animation in progress.");
             return false;
         }
 
         if (!mDisplayEnabled) {
             // No point choosing a rotation if the display is not enabled.
-            if (DEBUG_ORIENTATION) Slog.v(TAG, "Deferring rotation, display is not enabled.");
+            if (DEBUG_ORIENTATION) Log.d(TAG, "Deferring rotation, display is not enabled.");
             return false;
         }
 
@@ -5903,7 +6154,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 mForcedAppOrientation, rotation);
 
         if (DEBUG_ORIENTATION) {
-            Slog.v(TAG, "Application requested orientation "
+            Log.d(TAG, "Application requested orientation "
                     + mForcedAppOrientation + ", got rotation " + rotation
                     + " which has " + (altOrientation ? "incompatible" : "compatible")
                     + " metrics");
@@ -5915,7 +6166,7 @@ public class WindowManagerService extends IWindowManager.Stub
         }
 
         if (DEBUG_ORIENTATION) {
-            Slog.v(TAG,
+            Log.d(TAG,
                 "Rotation changed to " + rotation + (altOrientation ? " (alt)" : "")
                 + " from " + mRotation + (mAltOrientation ? " (alt)" : "")
                 + ", forceApp=" + mForcedAppOrientation);
@@ -5953,7 +6204,7 @@ public class WindowManagerService extends IWindowManager.Stub
         final DisplayInfo displayInfo = displayContent.getDisplayInfo();
         if (!inTransaction) {
             if (SHOW_TRANSACTIONS) {
-                Slog.i(TAG, ">>> OPEN TRANSACTION setRotationUnchecked");
+                Log.d(TAG, ">>> OPEN TRANSACTION setRotationUnchecked");
             }
             SurfaceControl.openTransaction();
         }
@@ -5975,7 +6226,7 @@ public class WindowManagerService extends IWindowManager.Stub
             if (!inTransaction) {
                 SurfaceControl.closeTransaction();
                 if (SHOW_LIGHT_TRANSACTIONS) {
-                    Slog.i(TAG, "<<< CLOSE TRANSACTION setRotationUnchecked");
+                    Log.d(TAG, "<<< CLOSE TRANSACTION setRotationUnchecked");
                 }
             }
         }
@@ -5984,7 +6235,7 @@ public class WindowManagerService extends IWindowManager.Stub
         for (int i = windows.size() - 1; i >= 0; i--) {
             WindowState w = windows.get(i);
             if (w.mHasSurface) {
-                if (DEBUG_ORIENTATION) Slog.v(TAG, "Set mOrientationChanging of " + w);
+                if (DEBUG_ORIENTATION) Log.d(TAG, "Set mOrientationChanging of " + w);
                 w.mOrientationChanging = true;
                 mInnerFields.mOrientationChangeComplete = false;
             }
@@ -6668,7 +6919,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     displayContent.getDisplayId(), displayInfo);
         }
         if (false) {
-            Slog.i(TAG, "Set app display size: " + appWidth + " x " + appHeight);
+            Log.d(TAG, "Set app display size: " + appWidth + " x " + appHeight);
         }
 
         final DisplayMetrics dm = mDisplayMetrics;
@@ -6800,7 +7051,7 @@ public class WindowManagerService extends IWindowManager.Stub
     IBinder prepareDragSurface(IWindow window, SurfaceSession session,
             int flags, int width, int height, Surface outSurface) {
         if (DEBUG_DRAG) {
-            Slog.d(TAG, "prepare drag surface: w=" + width + " h=" + height
+            Log.d(TAG, "prepare drag surface: w=" + width + " h=" + height
                     + " flags=" + Integer.toHexString(flags) + " win=" + window
                     + " asbinder=" + window.asBinder());
         }
@@ -6819,7 +7070,7 @@ public class WindowManagerService extends IWindowManager.Stub
                         SurfaceControl surface = new SurfaceControl(session, "drag surface",
                                 width, height, PixelFormat.TRANSLUCENT, SurfaceControl.HIDDEN);
                         surface.setLayerStack(display.getLayerStack());
-                        if (SHOW_TRANSACTIONS) Slog.i(TAG, "  DRAG "
+                        if (SHOW_TRANSACTIONS) Log.d(TAG, "  DRAG "
                                 + surface + ": CREATE");
                         outSurface.copyFrom(surface);
                         final IBinder winBinder = window.asBinder();
@@ -7078,7 +7329,7 @@ public class WindowManagerService extends IWindowManager.Stub
         @Override
         public void handleMessage(Message msg) {
             if (DEBUG_WINDOW_TRACE) {
-                Slog.v(TAG, "handleMessage: entry what=" + msg.what);
+                Log.d(TAG, "handleMessage: entry what=" + msg.what);
             }
             switch (msg.what) {
                 case REPORT_FOCUS_CHANGE: {
@@ -7093,11 +7344,11 @@ public class WindowManagerService extends IWindowManager.Stub
                             return;
                         }
                         mLastFocus = newFocus;
-                        if (DEBUG_FOCUS_LIGHT) Slog.i(TAG, "Focus moving from " + lastFocus +
+                        if (DEBUG_FOCUS_LIGHT) Log.d(TAG, "Focus moving from " + lastFocus +
                                 " to " + newFocus);
                         if (newFocus != null && lastFocus != null
                                 && !newFocus.isDisplayedLw()) {
-                            //Slog.i(TAG, "Delaying loss of focus...");
+                            //Log.d(TAG, "Delaying loss of focus...");
                             mLosingFocus.add(lastFocus);
                             lastFocus = null;
                         }
@@ -7106,13 +7357,13 @@ public class WindowManagerService extends IWindowManager.Stub
                     //System.out.println("Changing focus from " + lastFocus
                     //                   + " to " + newFocus);
                     if (newFocus != null) {
-                        if (DEBUG_FOCUS_LIGHT) Slog.i(TAG, "Gaining focus: " + newFocus);
+                        if (DEBUG_FOCUS_LIGHT) Log.d(TAG, "Gaining focus: " + newFocus);
                         newFocus.reportFocusChangedSerialized(true, mInTouchMode);
                         notifyFocusChanged();
                     }
 
                     if (lastFocus != null) {
-                        if (DEBUG_FOCUS_LIGHT) Slog.i(TAG, "Losing focus: " + lastFocus);
+                        if (DEBUG_FOCUS_LIGHT) Log.d(TAG, "Losing focus: " + lastFocus);
                         lastFocus.reportFocusChangedSerialized(false, mInTouchMode);
                     }
                 } break;
@@ -7127,7 +7378,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
                     final int N = losers.size();
                     for (int i=0; i<N; i++) {
-                        if (DEBUG_FOCUS_LIGHT) Slog.i(TAG, "Losing delayed focus: " +
+                        if (DEBUG_FOCUS_LIGHT) Log.d(TAG, "Losing delayed focus: " +
                                 losers.get(i));
                         losers.get(i).reportFocusChangedSerialized(false, mInTouchMode);
                     }
@@ -7149,7 +7400,7 @@ public class WindowManagerService extends IWindowManager.Stub
                         return;
                     }
 
-                    if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Add starting "
+                    if (DEBUG_STARTING_WINDOW) Log.d(TAG, "Add starting "
                             + wtoken + ": pkg=" + sd.pkg);
 
                     View view = null;
@@ -7169,7 +7420,7 @@ public class WindowManagerService extends IWindowManager.Stub
                                 // If the window was successfully added, then
                                 // we need to remove it.
                                 if (wtoken.startingWindow != null) {
-                                    if (DEBUG_STARTING_WINDOW) Slog.v(TAG,
+                                    if (DEBUG_STARTING_WINDOW) Log.d(TAG,
                                             "Aborted starting " + wtoken
                                             + ": removed=" + wtoken.removed
                                             + " startingData=" + wtoken.startingData);
@@ -7181,7 +7432,7 @@ public class WindowManagerService extends IWindowManager.Stub
                             } else {
                                 wtoken.startingView = view;
                             }
-                            if (DEBUG_STARTING_WINDOW && !abort) Slog.v(TAG,
+                            if (DEBUG_STARTING_WINDOW && !abort) Log.d(TAG,
                                     "Added starting " + wtoken
                                     + ": startingWindow="
                                     + wtoken.startingWindow + " startingView="
@@ -7208,7 +7459,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     IBinder token = null;
                     View view = null;
                     synchronized (mWindowMap) {
-                        if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Remove starting "
+                        if (DEBUG_STARTING_WINDOW) Log.d(TAG, "Remove starting "
                                 + wtoken + ": startingWindow="
                                 + wtoken.startingWindow + " startingView="
                                 + wtoken.startingView);
@@ -7241,7 +7492,7 @@ public class WindowManagerService extends IWindowManager.Stub
                             }
                             AppWindowToken wtoken = mFinishedStarting.remove(N-1);
 
-                            if (DEBUG_STARTING_WINDOW) Slog.v(TAG,
+                            if (DEBUG_STARTING_WINDOW) Log.d(TAG,
                                     "Finished starting " + wtoken
                                     + ": startingWindow=" + wtoken.startingWindow
                                     + " startingView=" + wtoken.startingView);
@@ -7270,7 +7521,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     final AppWindowToken wtoken = (AppWindowToken)msg.obj;
 
                     try {
-                        if (DEBUG_VISIBILITY) Slog.v(
+                        if (DEBUG_VISIBILITY) Log.d(
                                 TAG, "Reporting drawn in " + wtoken);
                         wtoken.appToken.windowsDrawn();
                     } catch (RemoteException ex) {
@@ -7284,7 +7535,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     boolean nowGone = msg.arg2 != 0;
 
                     try {
-                        if (DEBUG_VISIBILITY) Slog.v(
+                        if (DEBUG_VISIBILITY) Log.d(
                                 TAG, "Reporting visible in " + wtoken
                                 + " visible=" + nowVisible
                                 + " gone=" + nowGone);
@@ -7321,7 +7572,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 case APP_TRANSITION_TIMEOUT: {
                     synchronized (mWindowMap) {
                         if (mAppTransition.isTransitionSet()) {
-                            if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "*** APP TRANSITION TIMEOUT");
+                            if (DEBUG_APP_TRANSITIONS) Log.d(TAG, "*** APP TRANSITION TIMEOUT");
                             mAppTransition.setTimeout();
                             performLayoutAndPlaceSurfacesLocked();
                         }
@@ -7520,7 +7771,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     break;
             }
             if (DEBUG_WINDOW_TRACE) {
-                Slog.v(TAG, "handleMessage: exit");
+                Log.d(TAG, "handleMessage: exit");
             }
         }
     }
@@ -7548,9 +7799,9 @@ public class WindowManagerService extends IWindowManager.Stub
                 // TODO(multidisplay): IMEs are only supported on the default display.
                 WindowState imFocus = getDefaultWindowListLocked().get(idx-1);
                 if (DEBUG_INPUT_METHOD) {
-                    Slog.i(TAG, "Desired input method target: " + imFocus);
-                    Slog.i(TAG, "Current focus: " + mCurrentFocus);
-                    Slog.i(TAG, "Last focus: " + mLastFocus);
+                    Log.d(TAG, "Desired input method target: " + imFocus);
+                    Log.d(TAG, "Current focus: " + mCurrentFocus);
+                    Log.d(TAG, "Last focus: " + mLastFocus);
                 }
                 if (imFocus != null) {
                     // This may be a starting window, in which case we still want
@@ -7569,11 +7820,11 @@ public class WindowManagerService extends IWindowManager.Stub
                         }
                     }
                     if (DEBUG_INPUT_METHOD) {
-                        Slog.i(TAG, "IM target client: " + imFocus.mSession.mClient);
+                        Log.d(TAG, "IM target client: " + imFocus.mSession.mClient);
                         if (imFocus.mSession.mClient != null) {
-                            Slog.i(TAG, "IM target client binder: "
+                            Log.d(TAG, "IM target client binder: "
                                     + imFocus.mSession.mClient.asBinder());
-                            Slog.i(TAG, "Requesting client binder: " + client.asBinder());
+                            Log.d(TAG, "Requesting client binder: " + client.asBinder());
                         }
                     }
                     if (imFocus.mSession.mClient != null &&
@@ -7671,7 +7922,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     synchronized(displayContent.mDisplaySizeLock) {
                         if (displayContent.mBaseDisplayWidth != width
                                 || displayContent.mBaseDisplayHeight != height) {
-                            Slog.i(TAG, "FORCED DISPLAY SIZE: " + width + "x" + height);
+                            Log.d(TAG, "FORCED DISPLAY SIZE: " + width + "x" + height);
                             displayContent.mBaseDisplayWidth = width;
                             displayContent.mBaseDisplayHeight = height;
                         }
@@ -7691,7 +7942,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 density = Integer.parseInt(densityStr);
                 synchronized(displayContent.mDisplaySizeLock) {
                     if (displayContent.mBaseDisplayDensity != density) {
-                        Slog.i(TAG, "FORCED DISPLAY DENSITY: " + density);
+                        Log.d(TAG, "FORCED DISPLAY DENSITY: " + density);
                         displayContent.mBaseDisplayDensity = density;
                     }
                 }
@@ -7702,7 +7953,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
     // displayContent must not be null
     private void setForcedDisplaySizeLocked(DisplayContent displayContent, int width, int height) {
-        Slog.i(TAG, "Using new display size: " + width + "x" + height);
+        Log.d(TAG, "Using new display size: " + width + "x" + height);
 
         synchronized(displayContent.mDisplaySizeLock) {
             displayContent.mBaseDisplayWidth = width;
@@ -7782,7 +8033,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
     // displayContent must not be null
     private void setForcedDisplayDensityLocked(DisplayContent displayContent, int density) {
-        Slog.i(TAG, "Using new display density: " + density);
+        Log.d(TAG, "Using new display density: " + density);
 
         synchronized(displayContent.mDisplaySizeLock) {
             displayContent.mBaseDisplayDensity = density;
@@ -7891,7 +8142,7 @@ public class WindowManagerService extends IWindowManager.Stub
     final WindowState windowForClientLocked(Session session, IBinder client,
             boolean throwOnError) {
         WindowState win = mWindowMap.get(client);
-        if (localLOGV) Slog.v(
+        if (localLOGV) Log.d(
             TAG, "Looking up client " + client + ": " + win);
         if (win == null) {
             RuntimeException ex = new IllegalArgumentException(
@@ -7941,7 +8192,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 win.mRebuilding = true;
                 mRebuildTmp[numRemoved] = win;
                 mWindowsChanged = true;
-                if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Rebuild removing window: " + win);
+                if (DEBUG_WINDOW_MOVEMENT) Log.d(TAG, "Rebuild removing window: " + win);
                 NW--;
                 numRemoved++;
                 continue;
@@ -8009,7 +8260,7 @@ public class WindowManagerService extends IWindowManager.Stub
         int curLayer = 0;
         int i;
 
-        if (DEBUG_LAYERS) Slog.v(TAG, "Assigning layers based on windows=" + windows,
+        if (DEBUG_LAYERS) Log.d(TAG, "Assigning layers based on windows=" + windows,
                 new RuntimeException("here").fillInStackTrace());
 
         boolean anyLayerChanged = false;
@@ -8055,7 +8306,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 // Force an animation pass just to update the mDimLayer layer.
                 scheduleAnimationLocked();
             }
-            if (DEBUG_LAYERS) Slog.v(TAG, "Assign layer " + w + ": "
+            if (DEBUG_LAYERS) Log.d(TAG, "Assign layer " + w + ": "
                     + "mBase=" + w.mBaseLayer
                     + " mLayer=" + w.mLayer
                     + (wtoken == null ?
@@ -8116,7 +8367,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 // Wait a little bit for things to settle down, and off we go.
                 for (int i=0; i<mForceRemoves.size(); i++) {
                     WindowState ws = mForceRemoves.get(i);
-                    Slog.i(TAG, "Force removing: " + ws);
+                    Log.d(TAG, "Force removing: " + ws);
                     removeWindowInnerLocked(ws.mSession, ws);
                 }
                 mForceRemoves = null;
@@ -8163,6 +8414,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
     private final void performLayoutLockedInner(final DisplayContent displayContent,
                                     boolean initial, boolean updateInputWindows) {
+        Log.d(TAG,"Ritter::WMS performLayoutLockedInner()");
         if (!displayContent.layoutNeeded) {
             return;
         }
@@ -8182,9 +8434,9 @@ public class WindowManagerService extends IWindowManager.Stub
         final int N = windows.size();
         int i;
 
-        if (DEBUG_LAYOUT) {
-            Slog.v(TAG, "-------------------------------------");
-            Slog.v(TAG, "performLayout: needed="
+        if (true) {
+            Log.d(TAG, "Ritter::WMS-------------------------------------");
+            Log.d(TAG, "Ritter::WMS performLayout: needed="
                     + displayContent.layoutNeeded + " dw=" + dw + " dh=" + dh);
         }
 
@@ -8219,18 +8471,18 @@ public class WindowManagerService extends IWindowManager.Stub
                     || win.isGoneForLayoutLw();
 
             if (DEBUG_LAYOUT && !win.mLayoutAttached) {
-                Slog.v(TAG, "1ST PASS " + win
+                Log.d(TAG, "1ST PASS " + win
                         + ": gone=" + gone + " mHaveFrame=" + win.mHaveFrame
                         + " mLayoutAttached=" + win.mLayoutAttached
                         + " screen changed=" + win.isConfigChanged());
                 final AppWindowToken atoken = win.mAppToken;
-                if (gone) Slog.v(TAG, "  GONE: mViewVisibility="
+                if (gone) Log.d(TAG, "  GONE: mViewVisibility="
                         + win.mViewVisibility + " mRelayoutCalled="
                         + win.mRelayoutCalled + " hidden="
                         + win.mRootToken.hidden + " hiddenRequested="
                         + (atoken != null && atoken.hiddenRequested)
                         + " mAttachedHidden=" + win.mAttachedHidden);
-                else Slog.v(TAG, "  VIS: mViewVisibility="
+                else Log.d(TAG, "  VIS: mViewVisibility="
                         + win.mViewVisibility + " mRelayoutCalled="
                         + win.mRelayoutCalled + " hidden="
                         + win.mRootToken.hidden + " hiddenRequested="
@@ -8248,7 +8500,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     || win.mAttrs.type == TYPE_UNIVERSE_BACKGROUND) {
                 if (!win.mLayoutAttached) {
                     if (initial) {
-                        //Slog.i(TAG, "Window " + this + " clearing mContentChanged - initial");
+                        //Log.d(TAG, "Window " + this + " clearing mContentChanged - initial");
                         win.mContentChanged = false;
                     }
                     if (win.mAttrs.type == TYPE_DREAM) {
@@ -8259,9 +8511,29 @@ public class WindowManagerService extends IWindowManager.Stub
                     }
                     win.mLayoutNeeded = false;
                     win.prelayout();
+                    Log.d(TAG,
+                            "Ritter::WMS performLayoutLockedInner() Before mPolicy.layoutWindowLw win.mAttrs.x:"
+                                    + win.mAttrs.x + ",mAttrs.y:"
+                                    + win.mAttrs.y + ",mAttrs.w:"
+                                    + win.mAttrs.width + ",mAttrs.h:"
+                                    + win.mAttrs.height
+                                    + ",mAttrs.isInWindowing:"
+                                    + win.mAttrs.isInWindowing
+                                    + ",mAttrs.pkgName:"
+                                    + win.mAttrs.packageName);
                     mPolicy.layoutWindowLw(win, win.mAttrs, null);
+                    Log.d(TAG,
+                            "Ritter::WMS performLayoutLockedInner() After mPolicy.layoutWindowLw win.mAttrs.x:"
+                                    + win.mAttrs.x + ",mAttrs.y:"
+                                    + win.mAttrs.y + ",mAttrs.w:"
+                                    + win.mAttrs.width + ",mAttrs.h:"
+                                    + win.mAttrs.height
+                                    + ",mAttrs.isInWindowing:"
+                                    + win.mAttrs.isInWindowing
+                                    + ",mAttrs.pkgName:"
+                                    + win.mAttrs.packageName);
                     win.mLayoutSeq = seq;
-                    if (DEBUG_LAYOUT) Slog.v(TAG, "  LAYOUT: mFrame="
+                    if (DEBUG_LAYOUT) Log.d(TAG, "  LAYOUT: mFrame="
                             + win.mFrame + " mContainingFrame="
                             + win.mContainingFrame + " mDisplayFrame="
                             + win.mDisplayFrame);
@@ -8291,7 +8563,7 @@ public class WindowManagerService extends IWindowManager.Stub
             final WindowState win = windows.get(i);
 
             if (win.mLayoutAttached) {
-                if (DEBUG_LAYOUT) Slog.v(TAG, "2ND PASS " + win
+                if (DEBUG_LAYOUT) Log.d(TAG, "2ND PASS " + win
                         + " mHaveFrame=" + win.mHaveFrame
                         + " mViewVisibility=" + win.mViewVisibility
                         + " mRelayoutCalled=" + win.mRelayoutCalled);
@@ -8306,14 +8578,14 @@ public class WindowManagerService extends IWindowManager.Stub
                 if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled)
                         || !win.mHaveFrame || win.mLayoutNeeded) {
                     if (initial) {
-                        //Slog.i(TAG, "Window " + this + " clearing mContentChanged - initial");
+                        //Log.d(TAG, "Window " + this + " clearing mContentChanged - initial");
                         win.mContentChanged = false;
                     }
                     win.mLayoutNeeded = false;
                     win.prelayout();
                     mPolicy.layoutWindowLw(win, win.mAttrs, win.mAttachedWindow);
                     win.mLayoutSeq = seq;
-                    if (DEBUG_LAYOUT) Slog.v(TAG, "  LAYOUT: mFrame="
+                    if (DEBUG_LAYOUT) Log.d(TAG, "  LAYOUT: mFrame="
                             + win.mFrame + " mContainingFrame="
                             + win.mContainingFrame + " mDisplayFrame="
                             + win.mDisplayFrame);
@@ -8340,7 +8612,7 @@ public class WindowManagerService extends IWindowManager.Stub
         // it frozen/off until this window draws at its new
         // orientation.
         if (!okToDisplay()) {
-            if (DEBUG_ORIENTATION) Slog.v(TAG,
+            if (DEBUG_ORIENTATION) Log.d(TAG,
                     "Changing surface while display frozen: " + w);
             w.mOrientationChanging = true;
             w.mLastFreezeDuration = 0;
@@ -8366,7 +8638,7 @@ public class WindowManagerService extends IWindowManager.Stub
         int i;
         int NN = mOpeningApps.size();
         boolean goodToGo = true;
-        if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+        if (DEBUG_APP_TRANSITIONS) Log.d(TAG,
                 "Checking " + NN + " opening apps (frozen="
                 + mDisplayFrozen + " timeout="
                 + mAppTransition.isTimeout() + ")...");
@@ -8376,7 +8648,7 @@ public class WindowManagerService extends IWindowManager.Stub
             // we'll unfreeze the display when everyone is ready.
             for (i=0; i<NN && goodToGo; i++) {
                 AppWindowToken wtoken = mOpeningApps.get(i);
-                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                if (DEBUG_APP_TRANSITIONS) Log.d(TAG,
                         "Check opening app=" + wtoken + ": allDrawn="
                         + wtoken.allDrawn + " startingDisplayed="
                         + wtoken.startingDisplayed + " startingMoved="
@@ -8388,7 +8660,7 @@ public class WindowManagerService extends IWindowManager.Stub
             }
         }
         if (goodToGo) {
-            if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "**** GOOD TO GO");
+            if (DEBUG_APP_TRANSITIONS) Log.d(TAG, "**** GOOD TO GO");
             int transit = mAppTransition.getAppTransition();
             if (mSkipAppTransitionAnimation) {
                 transit = AppTransition.TRANSIT_UNSET;
@@ -8415,7 +8687,7 @@ public class WindowManagerService extends IWindowManager.Stub
             int bestAnimLayer = -1;
             boolean fullscreenAnim = false;
 
-            if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+            if (DEBUG_APP_TRANSITIONS) Log.d(TAG,
                     "New wallpaper target=" + mWallpaperTarget
                     + ", oldWallpaper=" + oldWallpaper
                     + ", lower target=" + mLowerWallpaperTarget
@@ -8477,7 +8749,7 @@ public class WindowManagerService extends IWindowManager.Stub
             }
 
             if (closingAppHasWallpaper && openingAppHasWallpaper) {
-                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "Wallpaper animation!");
+                if (DEBUG_APP_TRANSITIONS) Log.d(TAG, "Wallpaper animation!");
                 switch (transit) {
                     case AppTransition.TRANSIT_ACTIVITY_OPEN:
                     case AppTransition.TRANSIT_TASK_OPEN:
@@ -8490,18 +8762,18 @@ public class WindowManagerService extends IWindowManager.Stub
                         transit = AppTransition.TRANSIT_WALLPAPER_INTRA_CLOSE;
                         break;
                 }
-                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "New transit: " + transit);
+                if (DEBUG_APP_TRANSITIONS) Log.d(TAG, "New transit: " + transit);
             } else if ((oldWallpaper != null) && !mOpeningApps.contains(oldWallpaper.mAppToken)) {
                 // We are transitioning from an activity with
                 // a wallpaper to one without.
                 transit = AppTransition.TRANSIT_WALLPAPER_CLOSE;
-                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                if (DEBUG_APP_TRANSITIONS) Log.d(TAG,
                         "New transit away from wallpaper: " + transit);
             } else if (mWallpaperTarget != null && mWallpaperTarget.isVisibleLw()) {
                 // We are transitioning from an activity without
                 // a wallpaper to now showing the wallpaper
                 transit = AppTransition.TRANSIT_WALLPAPER_OPEN;
-                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                if (DEBUG_APP_TRANSITIONS) Log.d(TAG,
                         "New transit into wallpaper: " + transit);
             }
 
@@ -8510,7 +8782,7 @@ public class WindowManagerService extends IWindowManager.Stub
             // example, when this transition is being done behind
             // the lock screen.
             if (!mPolicy.allowAppAnimationsLw()) {
-                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                if (DEBUG_APP_TRANSITIONS) Log.d(TAG,
                         "Animations disallowed by keyguard or dream.");
                 animLp = null;
             }
@@ -8522,7 +8794,7 @@ public class WindowManagerService extends IWindowManager.Stub
             for (i=0; i<NN; i++) {
                 AppWindowToken wtoken = mOpeningApps.get(i);
                 final AppWindowAnimator appAnimator = wtoken.mAppAnimator;
-                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "Now opening app" + wtoken);
+                if (DEBUG_APP_TRANSITIONS) Log.d(TAG, "Now opening app" + wtoken);
                 appAnimator.clearThumbnail();
                 wtoken.inPendingTransaction = false;
                 appAnimator.animation = null;
@@ -8554,7 +8826,7 @@ public class WindowManagerService extends IWindowManager.Stub
             NN = mClosingApps.size();
             for (i=0; i<NN; i++) {
                 AppWindowToken wtoken = mClosingApps.get(i);
-                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "Now closing app " + wtoken);
+                if (DEBUG_APP_TRANSITIONS) Log.d(TAG, "Now closing app " + wtoken);
                 wtoken.mAppAnimator.clearThumbnail();
                 wtoken.inPendingTransaction = false;
                 wtoken.mAppAnimator.animation = null;
@@ -8588,7 +8860,7 @@ public class WindowManagerService extends IWindowManager.Stub
                             PixelFormat.TRANSLUCENT, SurfaceControl.HIDDEN);
                     surfaceControl.setLayerStack(display.getLayerStack());
                     appAnimator.thumbnail = surfaceControl;
-                    if (SHOW_TRANSACTIONS) Slog.i(TAG, "  THUMBNAIL " + surfaceControl + ": CREATE");
+                    if (SHOW_TRANSACTIONS) Log.d(TAG, "  THUMBNAIL " + surfaceControl + ": CREATE");
                     Surface drawSurface = new Surface();
                     drawSurface.copyFrom(surfaceControl);
                     Canvas c = drawSurface.lockCanvas(dirty);
@@ -8660,7 +8932,7 @@ public class WindowManagerService extends IWindowManager.Stub
         rebuildAppWindowListLocked();
 
         changes |= PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
-        if (DEBUG_WALLPAPER_LIGHT) Slog.v(TAG,
+        if (DEBUG_WALLPAPER_LIGHT) Log.d(TAG,
                 "Wallpaper layer changed: assigning layers + relayout");
         moveInputMethodWindowsIfNeededLocked(true);
         mInnerFields.mWallpaperMayChange = true;
@@ -8683,10 +8955,10 @@ public class WindowManagerService extends IWindowManager.Stub
                     !w.mLastVisibleInsets.equals(w.mVisibleInsets);
             boolean configChanged = w.isConfigChanged();
             if (DEBUG_CONFIGURATION && configChanged) {
-                Slog.v(TAG, "Win " + w + " config changed: "
+                Log.d(TAG, "Win " + w + " config changed: "
                         + mCurConfiguration);
             }
-            if (localLOGV) Slog.v(TAG, "Resizing " + w
+            if (localLOGV) Log.d(TAG, "Resizing " + w
                     + ": configChanged=" + configChanged
                     + " last=" + w.mLastFrame + " frame=" + w.mFrame);
             w.mLastFrame.set(w.mFrame);
@@ -8695,7 +8967,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     || winAnimator.mSurfaceResized
                     || configChanged) {
                 if (DEBUG_RESIZE || DEBUG_ORIENTATION) {
-                    Slog.v(TAG, "Resize reasons for w=" + w + ": "
+                    Log.d(TAG, "Resize reasons for w=" + w + ": "
                             + " contentInsetsChanged=" + w.mContentInsetsChanged
                             + " " + w.mContentInsets.toShortString()
                             + " visibleInsetsChanged=" + w.mVisibleInsetsChanged
@@ -8714,7 +8986,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 // to go through the process of getting informed
                 // by the application when it has finished drawing.
                 if (w.mOrientationChanging) {
-                    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM || DEBUG_ORIENTATION) Slog.v(TAG,
+                    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM || DEBUG_ORIENTATION) Log.d(TAG,
                             "Orientation start waiting for draw mDrawState=DRAW_PENDING in "
                             + w + ", surface " + winAnimator.mSurfaceControl);
                     winAnimator.mDrawState = WindowStateAnimator.DRAW_PENDING;
@@ -8724,14 +8996,14 @@ public class WindowManagerService extends IWindowManager.Stub
                     }
                 }
                 if (!mResizingWindows.contains(w)) {
-                    if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,
+                    if (DEBUG_RESIZE || DEBUG_ORIENTATION) Log.d(TAG,
                             "Resizing window " + w + " to " + winAnimator.mSurfaceW
                             + "x" + winAnimator.mSurfaceH);
                     mResizingWindows.add(w);
                 }
             } else if (w.mOrientationChanging) {
                 if (w.isDrawnLw()) {
-                    if (DEBUG_ORIENTATION) Slog.v(TAG,
+                    if (DEBUG_ORIENTATION) Log.d(TAG,
                             "Orientation not waiting for draw in "
                             + w + ", surface " + winAnimator.mSurfaceControl);
                     w.mOrientationChanging = false;
@@ -8810,7 +9082,7 @@ public class WindowManagerService extends IWindowManager.Stub
             final TaskStack stack = w.getStack();
             stack.setDimmingTag();
             if (!stack.isDimming(winAnimator)) {
-                if (localLOGV) Slog.v(TAG, "Win " + w + " start dimming.");
+                if (localLOGV) Log.d(TAG, "Win " + w + " start dimming.");
                 stack.startDimmingIfNeeded(winAnimator);
             }
         }
@@ -8829,7 +9101,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 if (!wtoken.allDrawn) {
                     int numInteresting = wtoken.numInterestingWindows;
                     if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
-                        if (DEBUG_VISIBILITY) Slog.v(TAG,
+                        if (DEBUG_VISIBILITY) Log.d(TAG,
                                 "allDrawn: " + wtoken
                                 + " interesting=" + numInteresting
                                 + " drawn=" + wtoken.numDrawnWindows);
@@ -8844,9 +9116,10 @@ public class WindowManagerService extends IWindowManager.Stub
     // "Something has changed!  Let's make it correct now."
     private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory) {
         if (DEBUG_WINDOW_TRACE) {
-            Slog.v(TAG, "performLayoutAndPlaceSurfacesLockedInner: entry. Called by "
+            Log.d(TAG, "performLayoutAndPlaceSurfacesLockedInner: entry. Called by "
                     + Debug.getCallers(3));
         }
+        Log.d(TAG,"Ritter::WMS performLayoutAndPlaceSurfacesLockedInner()");
 
         final long currentTime = SystemClock.uptimeMillis();
 
@@ -8885,14 +9158,16 @@ public class WindowManagerService extends IWindowManager.Stub
         final int defaultDw = defaultInfo.logicalWidth;
         final int defaultDh = defaultInfo.logicalHeight;
 
-        if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
+        if (SHOW_LIGHT_TRANSACTIONS) Log.d(TAG,
                 ">>> OPEN TRANSACTION performLayoutAndPlaceSurfaces");
         SurfaceControl.openTransaction();
         try {
-
+            Log.d(TAG,"Ritter::WMS performLayoutAndPlaceSurfacesLockedInner() before mWatermark != null");
             if (mWatermark != null) {
-                mWatermark.positionSurface(defaultDw, defaultDh);
+                Log.d(TAG,"Ritter::WMS performLayoutAndPlaceSurfacesLockedInner() mWatermark != null");
+//                mWatermark.positionSurface(defaultDw, defaultDh);
             }
+            Log.d(TAG,"Ritter::WMS performLayoutAndPlaceSurfacesLockedInner() after mWatermark != null");
             if (mStrictModeFlash != null) {
                 mStrictModeFlash.positionSurface(defaultDw, defaultDh);
             }
@@ -8938,7 +9213,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
                     if (isDefaultDisplay && (displayContent.pendingLayoutChanges
                             & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
-                        if (DEBUG_LAYOUT) Slog.v(TAG, "Computing new config from layout");
+                        if (DEBUG_LAYOUT) Log.d(TAG, "Computing new config from layout");
                         if (updateOrientationFromAppTokensLocked(true)) {
                             displayContent.layoutNeeded = true;
                             mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
@@ -9030,7 +9305,7 @@ public class WindowManagerService extends IWindowManager.Stub
                         }
                     }
 
-                    //Slog.i(TAG, "Window " + this + " clearing mContentChanged - done placing");
+                    //Log.d(TAG, "Window " + this + " clearing mContentChanged - done placing");
                     w.mContentChanged = false;
 
                     // Moved from updateWindowsAndWallpaperLocked().
@@ -9053,7 +9328,7 @@ public class WindowManagerService extends IWindowManager.Stub
                                 }
                             }
                             if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
-                                if (DEBUG_WALLPAPER_LIGHT) Slog.v(TAG,
+                                if (DEBUG_WALLPAPER_LIGHT) Log.d(TAG,
                                         "First draw done in potential wallpaper target " + w);
                                 mInnerFields.mWallpaperMayChange = true;
                                 displayContent.pendingLayoutChanges |=
@@ -9071,7 +9346,7 @@ public class WindowManagerService extends IWindowManager.Stub
                         final AppWindowToken atoken = w.mAppToken;
                         if (DEBUG_STARTING_WINDOW && atoken != null
                                 && w == atoken.startingWindow) {
-                            Slog.d(TAG, "updateWindows: starting " + w + " isOnScreen="
+                            Log.d(TAG, "updateWindows: starting " + w + " isOnScreen="
                                 + w.isOnScreen() + " allDrawn=" + atoken.allDrawn
                                 + " freezingScreen=" + atoken.mAppAnimator.freezingScreen);
                         }
@@ -9085,10 +9360,10 @@ public class WindowManagerService extends IWindowManager.Stub
                             if ((w.isOnScreen() || winAnimator.mAttrType == TYPE_BASE_APPLICATION)
                                     && !w.mExiting && !w.mDestroying) {
                                 if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
-                                    Slog.v(TAG, "Eval win " + w + ": isDrawn=" + w.isDrawnLw()
+                                    Log.d(TAG, "Eval win " + w + ": isDrawn=" + w.isDrawnLw()
                                             + ", isAnimating=" + winAnimator.isAnimating());
                                     if (!w.isDrawnLw()) {
-                                        Slog.v(TAG, "Not displayed: s=" + winAnimator.mSurfaceControl
+                                        Log.d(TAG, "Not displayed: s=" + winAnimator.mSurfaceControl
                                                 + " pv=" + w.mPolicyVisibility
                                                 + " mDrawState=" + winAnimator.mDrawState
                                                 + " ah=" + w.mAttachedHidden
@@ -9101,7 +9376,7 @@ public class WindowManagerService extends IWindowManager.Stub
                                         atoken.numInterestingWindows++;
                                         if (w.isDrawnLw()) {
                                             atoken.numDrawnWindows++;
-                                            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) Slog.v(TAG,
+                                            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) Log.d(TAG,
                                                     "tokenMayBeDrawn: " + atoken
                                                     + " freezingScreen=" + atoken.mAppAnimator.freezingScreen
                                                     + " mAppFreezing=" + w.mAppFreezing);
@@ -9158,7 +9433,7 @@ public class WindowManagerService extends IWindowManager.Stub
             Log.wtf(TAG, "Unhandled exception in Window Manager", e);
         } finally {
             SurfaceControl.closeTransaction();
-            if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
+            if (SHOW_LIGHT_TRANSACTIONS) Log.d(TAG,
                     "<<< CLOSE TRANSACTION performLayoutAndPlaceSurfaces");
         }
 
@@ -9200,7 +9475,7 @@ public class WindowManagerService extends IWindowManager.Stub
         mInnerFields.mWallpaperForceHidingChanged = false;
 
         if (mInnerFields.mWallpaperMayChange) {
-            if (DEBUG_WALLPAPER_LIGHT) Slog.v(TAG, "Wallpaper may change!  Adjusting");
+            if (DEBUG_WALLPAPER_LIGHT) Log.d(TAG, "Wallpaper may change!  Adjusting");
             defaultDisplay.pendingLayoutChanges |=
                     WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
             if (DEBUG_LAYOUT_REPEATS) debugLayoutRepeats("WallpaperMayChange",
@@ -9229,28 +9504,34 @@ public class WindowManagerService extends IWindowManager.Stub
             }
             final WindowStateAnimator winAnimator = win.mWinAnimator;
             try {
-                if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,
+                if (DEBUG_RESIZE || DEBUG_ORIENTATION) Log.d(TAG,
                         "Reporting new frame to " + win + ": " + win.mCompatFrame);
                 int diff = 0;
                 boolean configChanged = win.isConfigChanged();
                 if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION)
                         && configChanged) {
-                    Slog.i(TAG, "Sending new config to window " + win + ": "
+                    Log.d(TAG, "Sending new config to window " + win + ": "
                             + winAnimator.mSurfaceW + "x" + winAnimator.mSurfaceH
                             + " / " + mCurConfiguration + " / 0x"
                             + Integer.toHexString(diff));
                 }
                 win.setConfiguration(mCurConfiguration);
                 if (DEBUG_ORIENTATION &&
-                        winAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING) Slog.i(
+                        winAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING) Log.d(
                         TAG, "Resizing " + win + " WITH DRAW PENDING");
                 final IWindow client = win.mClient;
                 final Rect frame = win.mFrame;
                 final Rect overscanInsets = win.mLastOverscanInsets;
                 final Rect contentInsets = win.mLastContentInsets;
                 final Rect visibleInsets = win.mLastVisibleInsets;
-                final boolean reportDraw
-                        = winAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING;
+
+                //Ritter_multi
+                //I don't know why, but if I set reportDraw=true, the Window will resize in real time.
+//                final boolean reportDraw
+//                        = winAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING;
+                final boolean reportDraw = true;
+                //end
+
                 final Configuration newConfig = configChanged ? win.mConfiguration : null;
                 if (win.mClient instanceof IWindow.Stub) {
                     // To prevent deadlock simulate one-way call if win.mClient is a local object.
@@ -9281,7 +9562,7 @@ public class WindowManagerService extends IWindowManager.Stub
             mResizingWindows.remove(i);
         }
 
-        if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,
+        if (DEBUG_ORIENTATION && mDisplayFrozen) Log.d(TAG,
                 "With display frozen, orientationChangeComplete="
                 + mInnerFields.mOrientationChangeComplete);
         if (mInnerFields.mOrientationChangeComplete) {
@@ -9336,7 +9617,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     // soon as their animations are complete
                     token.mAppAnimator.clearAnimation();
                     token.mAppAnimator.animating = false;
-                    if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT) Slog.v(TAG,
+                    if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT) Log.d(TAG,
                             "performLayout: App token exiting now removed" + token);
                     final Task task = mTaskIdToTask.get(token.groupId);
                     if (task != null && task.removeAppToken(token)) {
@@ -9392,13 +9673,13 @@ public class WindowManagerService extends IWindowManager.Stub
         }
 
         if (mTurnOnScreen) {
-            if (DEBUG_VISIBILITY) Slog.v(TAG, "Turning screen on after layout!");
+            if (DEBUG_VISIBILITY) Log.d(TAG, "Turning screen on after layout!");
             mPowerManager.wakeUp(SystemClock.uptimeMillis());
             mTurnOnScreen = false;
         }
 
         if (mInnerFields.mUpdateRotation) {
-            if (DEBUG_ORIENTATION) Slog.d(TAG, "Performing post-rotate rotation");
+            if (DEBUG_ORIENTATION) Log.d(TAG, "Performing post-rotate rotation");
             if (updateRotationUncheckedLocked(false)) {
                 mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
             } else {
@@ -9456,7 +9737,7 @@ public class WindowManagerService extends IWindowManager.Stub
             for (int j=mWaitingForDrawn.size()-1; j>=0; j--) {
                 Pair<WindowState, IRemoteCallback> pair = mWaitingForDrawn.get(j);
                 WindowState win = pair.first;
-                //Slog.i(TAG, "Waiting for drawn " + win + ": removed="
+                //Log.d(TAG, "Waiting for drawn " + win + ": removed="
                 //        + win.mRemoved + " visible=" + win.isVisibleLw()
                 //        + " shown=" + win.mSurfaceShown);
                 if (win.mRemoved) {
@@ -9495,7 +9776,7 @@ public class WindowManagerService extends IWindowManager.Stub
                     checkDrawnWindowsLocked();
                     return true;
                 }
-                Slog.i(TAG, "waitForWindowDrawn: win null");
+                Log.d(TAG, "waitForWindowDrawn: win null");
             }
         }
         return false;
@@ -9623,7 +9904,7 @@ public class WindowManagerService extends IWindowManager.Stub
             // window list to make sure we haven't left any dangling surfaces
             // around.
 
-            Slog.i(TAG, "Out of memory for surface!  Looking for leaks...");
+            Log.d(TAG, "Out of memory for surface!  Looking for leaks...");
             final int numDisplays = mDisplayContents.size();
             for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
                 final WindowList windows = mDisplayContents.valueAt(displayNdx).getWindowList();
@@ -9718,6 +9999,7 @@ public class WindowManagerService extends IWindowManager.Stub
     }
 
     private boolean updateFocusedWindowLocked(int mode, boolean updateInputWindows) {
+        Log.d(TAG,"Ritter:WMS updateFocusedWindowLocked()");
         WindowState newFocus = computeFocusedWindowLocked();
         if (mCurrentFocus != newFocus) {
             Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, "wmUpdateFocus");
@@ -9735,7 +10017,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 newFocus = computeFocusedWindowLocked();
             }
 
-            if (DEBUG_FOCUS_LIGHT || localLOGV) Slog.v(TAG, "Changing focus from " +
+            if (DEBUG_FOCUS_LIGHT || localLOGV) Log.d(TAG, "Changing focus from " +
                     mCurrentFocus + " to " + newFocus + " Callers=" + Debug.getCallers(4));
             final WindowState oldFocus = mCurrentFocus;
             mCurrentFocus = newFocus;
@@ -9800,7 +10082,7 @@ public class WindowManagerService extends IWindowManager.Stub
         for (int i = windows.size() - 1; i >= 0; i--) {
             final WindowState win = windows.get(i);
 
-            if (localLOGV || DEBUG_FOCUS) Slog.v(
+            if (localLOGV || DEBUG_FOCUS) Log.d(
                 TAG, "Looking for focus: " + i
                 + " = " + win
                 + ", flags=" + win.mAttrs.flags
@@ -9810,7 +10092,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
             // If this window's application has been removed, just skip it.
             if (wtoken != null && (wtoken.removed || wtoken.sendingToBottom)) {
-                if (DEBUG_FOCUS) Slog.v(TAG, "Skipping " + wtoken + " because "
+                if (DEBUG_FOCUS) Log.d(TAG, "Skipping " + wtoken + " because "
                         + (wtoken.removed ? "removed" : "sendingToBottom"));
                 continue;
             }
@@ -9834,7 +10116,7 @@ public class WindowManagerService extends IWindowManager.Stub
                         }
                         if (mFocusedApp == token) {
                             // Whoops, we are below the focused app...  no focus for you!
-                            if (localLOGV || DEBUG_FOCUS_LIGHT) Slog.v(TAG,
+                            if (localLOGV || DEBUG_FOCUS_LIGHT) Log.d(TAG,
                                     "findFocusedWindow: Reached focused app=" + mFocusedApp);
                             return null;
                         }
@@ -9846,12 +10128,12 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
             }
 
-            if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "findFocusedWindow: Found new focus @ " + i +
+            if (DEBUG_FOCUS_LIGHT) Log.d(TAG, "findFocusedWindow: Found new focus @ " + i +
                         " = " + win);
             return win;
         }
 
-        if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "findFocusedWindow: No focusable windows.");
+        if (DEBUG_FOCUS_LIGHT) Log.d(TAG, "findFocusedWindow: No focusable windows.");
         return null;
     }
 
@@ -9913,7 +10195,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
         if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen
                 || mClientFreezingScreen) {
-            if (DEBUG_ORIENTATION) Slog.d(TAG,
+            if (DEBUG_ORIENTATION) Log.d(TAG,
                 "stopFreezingDisplayLocked: Returning mWaitingForConfig=" + mWaitingForConfig
                 + ", mAppsFreezingScreen=" + mAppsFreezingScreen
                 + ", mWindowsFreezingScreen=" + mWindowsFreezingScreen
@@ -9930,7 +10212,7 @@ public class WindowManagerService extends IWindowManager.Stub
             sb.append(" due to ");
             sb.append(mLastFinishedFreezeSource);
         }
-        Slog.i(TAG, sb.toString());
+        Log.d(TAG, sb.toString());
         mH.removeMessages(H.APP_FREEZE_TIMEOUT);
         mH.removeMessages(H.CLIENT_FREEZE_TIMEOUT);
         if (PROFILE_ORIENTATION) {
@@ -9945,7 +10227,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 mAnimator.getScreenRotationAnimationLocked(displayId);
         if (CUSTOM_SCREEN_ROTATION && screenRotationAnimation != null
                 && screenRotationAnimation.hasScreenshot()) {
-            if (DEBUG_ORIENTATION) Slog.i(TAG, "**** Dismissing screen rotation animation");
+            if (DEBUG_ORIENTATION) Log.d(TAG, "**** Dismissing screen rotation animation");
             // TODO(multidisplay): rotation on main screen only.
             DisplayInfo displayInfo = displayContent.getDisplayInfo();
             // Get rotation animation again, with new top window
@@ -9993,7 +10275,7 @@ public class WindowManagerService extends IWindowManager.Stub
         mScreenFrozenLock.release();
 
         if (updateRotation) {
-            if (DEBUG_ORIENTATION) Slog.d(TAG, "Performing post-rotate rotation");
+            if (DEBUG_ORIENTATION) Log.d(TAG, "Performing post-rotate rotation");
             configChanged |= updateRotationUncheckedLocked(false);
         }
 
@@ -10022,39 +10304,43 @@ public class WindowManagerService extends IWindowManager.Stub
     }
 
     void createWatermarkInTransaction() {
+        Log.d(TAG,"Ritter::WMS createWatermarkInTransaction()");
         if (mWatermark != null) {
             return;
         }
-
-        File file = new File("/system/etc/setup.conf");
-        FileInputStream in = null;
-        DataInputStream ind = null;
-        try {
-            in = new FileInputStream(file);
-            ind = new DataInputStream(in);
-            String line = ind.readLine();
+        Log.d(TAG,"Ritter::WMS createWatermarkInTransaction() mWatermark == null");
+//        File file = new File("/system/etc/setup.conf");
+//        FileInputStream in = null;
+//        DataInputStream ind = null;
+//        try {
+//            in = new FileInputStream(file);
+//            ind = new DataInputStream(in);
+//            String line = ind.readLine();
+            String line = "What%the%fuck";
             if (line != null) {
                 String[] toks = line.split("%");
                 if (toks != null && toks.length > 0) {
+                    Log.d(TAG,"Ritter::WMS createWatermarkInTransaction() toks != null && toks.length > 0");
                     mWatermark = new Watermark(getDefaultDisplayContentLocked().getDisplay(),
                             mRealDisplayMetrics, mFxSession, toks);
-                }
-            }
-        } catch (FileNotFoundException e) {
-        } catch (IOException e) {
-        } finally {
-            if (ind != null) {
-                try {
-                    ind.close();
-                } catch (IOException e) {
-                }
-            } else if (in != null) {
-                try {
-                    in.close();
-                } catch (IOException e) {
-                }
-            }
-        }
+                    Log.d(TAG,"Ritter::WMS createWatermarkInTransaction() after new Watermark()");
+                }
+            }
+//        } catch (FileNotFoundException e) {
+//        } catch (IOException e) {
+//        } finally {
+//            if (ind != null) {
+//                try {
+//                    ind.close();
+//                } catch (IOException e) {
+//                }
+//            } else if (in != null) {
+//                try {
+//                    in.close();
+//                } catch (IOException e) {
+//                }
+//            }
+//        }
     }
 
     @Override
@@ -10701,7 +10987,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
     void debugLayoutRepeats(final String msg, int pendingLayoutChanges) {
         if (mLayoutRepeatCount >= LAYOUT_REPEAT_THRESHOLD) {
-            Slog.v(TAG, "Layouts looping: " + msg + ", mPendingLayoutChanges = 0x" +
+            Log.d(TAG, "Layouts looping: " + msg + ", mPendingLayoutChanges = 0x" +
                     Integer.toHexString(pendingLayoutChanges));
         }
     }
@@ -10840,4 +11126,49 @@ public class WindowManagerService extends IWindowManager.Stub
     public Object getWindowManagerLock() {
         return mWindowMap;
     }
+
+    //Ritter_Multi
+    public void moveHomeToTop(){
+        Log.d(TAG,"Ritter::WMS moveHomeToTop()");
+        try{
+            mActivityManager.moveHomeToTop();
+        }catch(RemoteException e){
+        }
+    }
+
+    //Ritter_Multi
+    public void callAMSMoveTaskToTop(int taskID){
+        Log.d(TAG,"Ritter::WMS callAMSMoveTaskToTop() taskID:"+taskID);
+        try{
+//            mActivityManager.moveTaskToTop_AM(taskID);
+//            mActivityManager.moveTaskToFront(taskID,0,null);
+//            mActivityManager.moveTaskToFront(taskID,ActivityManager.MOVE_TASK_WITH_HOME,null);
+            mActivityManager.moveTaskToFront(taskID,ActivityManager.MOVE_TASK_BACK_TASKS_INVISIBLE,null);
+        }catch(RemoteException e){
+        }
+    }
+
+    public boolean getMyWindowStateAttrs(Session session, IWindow client, Rect outRect) {
+        Log.d(TAG,"Ritter::WMS getMyWindowStateAttrs()");
+        boolean res = false;
+        synchronized(mWindowMap) {
+            Log.d(TAG, "Ritter::WMS getMyWindowStateAttrs() mWindowMap.size():"+ mWindowMap.size()+",client.asBinder():"+client.asBinder().toString());
+            WindowState win = windowForClientLocked(session, client, false);
+            if (win != null) {
+                Log.d(TAG,
+                        "Ritter::WMS getMyWindowStateAttrs() win.mAttrs.x:("
+                                +win.mAttrs.x+","
+                                +win.mAttrs.y+","
+                                +win.mAttrs.width+","
+                                +win.mAttrs.height+")); packageName:"+win.mAttrs.packageName
+                                +",isInWindowing:"+win.mAttrs.isInWindowing);
+                outRect.set(win.mAttrs.x, win.mAttrs.y,
+                        win.mAttrs.x + win.mAttrs.width,
+                        win.mAttrs.y + win.mAttrs.height);
+                res = true;
+            }
+        }
+        return res;
+    }
+
 }
diff --git a/frameworks/base/services/java/com/android/server/wm/WindowState.java b/frameworks/base/services/java/com/android/server/wm/WindowState.java
index 2d08792..27b59b2 100644
--- a/frameworks/base/services/java/com/android/server/wm/WindowState.java
+++ b/frameworks/base/services/java/com/android/server/wm/WindowState.java
@@ -30,6 +30,8 @@ import static android.view.WindowManager.LayoutParams.TYPE_WALLPAPER;
 
 import android.app.AppOpsManager;
 import android.os.RemoteCallbackList;
+import android.util.Log;
+import android.util.Slog;
 import android.util.TimeUtils;
 import android.view.IWindowFocusObserver;
 import android.view.IWindowId;
@@ -306,6 +308,13 @@ final class WindowState implements WindowManagerPolicy.WindowState {
     WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,
            WindowState attachedWindow, int appOp, int seq, WindowManager.LayoutParams a,
            int viewVisibility, final DisplayContent displayContent) {
+        Log.d(TAG,"Ritter::WS WindowState() attrs x:"+a.x+"" +
+                ",y:"+a.y+
+                ",w:"+a.width+
+                ",h:"+a.height+
+                ",pkgName:"+a.packageName+
+                ",isInWindowing:"+a.isInWindowing
+                );
         mService = service;
         mSession = s;
         mClient = c;
@@ -460,15 +469,19 @@ final class WindowState implements WindowManagerPolicy.WindowState {
 
     @Override
     public void computeFrameLw(Rect pf, Rect df, Rect of, Rect cf, Rect vf, Rect dcf) {
+        Log.d(TAG,"Ritter::WS computeFrameLw()");
         mHaveFrame = true;
 
         TaskStack stack = mAppToken != null ? getStack() : null;
         if (stack != null && stack.hasSibling()) {
+            Log.d(TAG, "Ritter::WS computeFrameLw() A1 stack != null && stack.hasSibling()");
             mContainingFrame.set(getStackBounds(stack));
             if (mUnderStatusBar) {
+                Slog.v(TAG, "Ritter::WS B1 computeFrameLw() mUnderStatusBar");
                 mContainingFrame.top = pf.top;
             }
         } else {
+            Log.d(TAG, "Ritter::WS A2 computeFrameLw() mUnderStatusBar");
             mContainingFrame.set(pf);
         }
 
@@ -478,37 +491,110 @@ final class WindowState implements WindowManagerPolicy.WindowState {
         final int ph = mContainingFrame.height();
 
         int w,h;
+        //Ritter_multi old
+        /*
         if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
+            Log.d(TAG,"Ritter::WS computeFrameLw() (mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0 AAA");
             if (mAttrs.width < 0) {
                 w = pw;
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 1 w:"+w);
             } else if (mEnforceSizeCompat) {
                 w = (int)(mAttrs.width * mGlobalScale + .5f);
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 2 w:"+w);
             } else {
                 w = mAttrs.width;
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 3 w:"+w);
             }
             if (mAttrs.height < 0) {
                 h = ph;
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 4 h:"+h);
             } else if (mEnforceSizeCompat) {
                 h = (int)(mAttrs.height * mGlobalScale + .5f);
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 5 h:"+h);
             } else {
                 h = mAttrs.height;
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 6 h:"+h);
             }
         } else {
+            Log.d(TAG,"Ritter::WS computeFrameLw() (mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0 else BBB");
             if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
                 w = pw;
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 1 w:"+w);
             } else if (mEnforceSizeCompat) {
                 w = (int)(mRequestedWidth * mGlobalScale + .5f);
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 2 w:"+w);
             } else {
                 w = mRequestedWidth;
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 3 w:"+w);
             }
             if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
                 h = ph;
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 4h:"+h);
             } else if (mEnforceSizeCompat) {
                 h = (int)(mRequestedHeight * mGlobalScale + .5f);
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 5 h:"+h);
             } else {
                 h = mRequestedHeight;
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 6 h:"+h);
+            }
+        }*/
+
+        //Ritter_multi new
+        if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0) {
+            Log.d(TAG,"Ritter::WS computeFrameLw() (mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0 AAA");
+            if (mAttrs.width < 0) {
+                w = pw;
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 1 w:"+w);
+            } else if (mEnforceSizeCompat) {
+                w = (int)(mAttrs.width * mGlobalScale + .5f);
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 2 w:"+w);
+            } else {
+                w = mAttrs.width;
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 3 w:"+w);
+            }
+            if (mAttrs.height < 0) {
+                h = ph;
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 4 h:"+h);
+            } else if (mEnforceSizeCompat) {
+                h = (int)(mAttrs.height * mGlobalScale + .5f);
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 5 h:"+h);
+            } else {
+                h = mAttrs.height;
+                Log.d(TAG,"Ritter::WS computeFrameLw() AAA 6 h:"+h);
             }
+        } else {
+            Log.d(TAG,"Ritter::WS computeFrameLw() (mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0 else BBB");
+            if (mAttrs.width == WindowManager.LayoutParams.MATCH_PARENT) {
+                w = pw;
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 1 w:"+w);
+            } else if (mEnforceSizeCompat) {
+                w = (int)(mRequestedWidth * mGlobalScale + .5f);
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 2 w:"+w);
+            } else {
+                w = mRequestedWidth;
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 3 w:"+w);
+            }
+
+            if (mAttrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
+                h = ph;
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 4h:"+h);
+            } else if (mEnforceSizeCompat) {
+                h = (int)(mRequestedHeight * mGlobalScale + .5f);
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 5 h:"+h);
+            } else {
+                h = mRequestedHeight;
+                Log.d(TAG,"Ritter::WS computeFrameLw() BBB 6 h:"+h);
+            }
+
+            if (false && (mAttrs.packageName!=null && mAttrs.packageName.contains("com.example."))){
+                w = mRequestedWidth;
+                h = mRequestedHeight;
+                Log.d(TAG, "Ritter::WS computeFrameLw() BBB 7 w:" + w + ",h:"
+                        + h + ",mAttrs.packageName:" + mAttrs.packageName);
+            }
+
         }
+        //end
 
         if (!mParentFrame.equals(pf)) {
             //Slog.i(TAG, "Window " + this + " content frame from " + mParentFrame
@@ -541,15 +627,53 @@ final class WindowState implements WindowManagerPolicy.WindowState {
             x = mAttrs.x;
             y = mAttrs.y;
         }
-
+        Log.d(TAG,"Ritter::WS computeFrameLw() A before Gravity.apply x:"+x+",y:"+y+",mAttrs.gravity:"+mAttrs.gravity+",mAttrs.pkgName:"+mAttrs.packageName);
+        Log.d(TAG,"Ritter::WS computeFrameLw() A before Gravity.apply mAttrs.x:"+mAttrs.x+",mAttrs.y:"+mAttrs.y+",mAttrs.w:"+mAttrs.width+",mAttrs.h:"+mAttrs.height);
+        Log.d(TAG,"Ritter::WS computeFrameLw() A before Gravity.apply mFrame:"+mFrame.toShortString());
+        Log.d(TAG,"Ritter::WS computeFrameLw() A before Gravity.apply mAttrs.horizontalMargin:"+mAttrs.horizontalMargin
+                +",mAttrs.verticalMargin:"+mAttrs.verticalMargin);
+        Log.d(TAG,"Ritter::WS computeFrameLw() A before Gravity.apply pw:"+pw+",ph:"+ph);
+        Log.d(TAG,"Ritter::WS computeFrameLw() A before Gravity.apply w:"+w+",h:"+h);
         Gravity.apply(mAttrs.gravity, w, h, mContainingFrame,
                 (int) (x + mAttrs.horizontalMargin * pw),
                 (int) (y + mAttrs.verticalMargin * ph), mFrame);
-
+        Log.d(TAG,"Ritter::WS computeFrameLw() B after Gravity.apply mAttrs.x:"+mAttrs.x+",mAttrs.y:"+mAttrs.y+",mAttrs.w:"+mAttrs.width+",mAttrs.h:"+mAttrs.height);
+        Log.d(TAG,"Ritter::WS computeFrameLw() B after Gravity.apply mFrame:"+mFrame.toShortString());
         //System.out.println("Out: " + mFrame);
 
         // Now make sure the window fits in the overall display.
         Gravity.applyDisplay(mAttrs.gravity, df, mFrame);
+        Log.d(TAG,"Ritter::WS computeFrameLw() C after Gravity.applyDisplay mAttrs.x:"+mAttrs.x+",mAttrs.y:"+mAttrs.y+",mAttrs.w:"+mAttrs.width+",mAttrs.h:"+mAttrs.height);
+        Log.d(TAG,"Ritter::WS computeFrameLw() C after Gravity.applyDisplay mFrame:"+mFrame.toShortString());
+        Log.d(TAG,"Ritter::WS computeFrameLw() C after Gravity.applyDisplay mAttrs.isInWindowing :"+mAttrs.isInWindowing);
+
+        //Ritter_multi new
+        if(false&&mAttrs.packageName!= null && mAttrs.packageName.contains("com.example.")){
+            if (mAttrs.isInWindowing) {
+                mAttrs.x = mFrame.left;
+                mAttrs.y = mFrame.top;
+                mAttrs.width = mFrame.right - mFrame.left;
+                mAttrs.height = mFrame.bottom - mFrame.top;
+                Log.d(TAG,
+                        "Ritter::WS computeFrameLw() mAttrs.isInWindowing pkgName:"
+                                + mAttrs.packageName+",mAttrs.isInWindowing:"+mAttrs.isInWindowing);
+            } else {
+//                mAttrs.x = mFrame.left;
+//                mAttrs.width = mFrame.right - mFrame.left;
+//                mAttrs.y = mFrame.top;
+//                mAttrs.height = mFrame.bottom - mFrame.top;
+//                mFrame.left = mAttrs.x;
+//                mFrame.right = mAttrs.x + mAttrs.width;
+//                mFrame.top = mAttrs.y;
+//                mFrame.bottom = mAttrs.y + mAttrs.height;
+//                Log.d(TAG,
+//                        "Ritter::WS computeFrameLw() mAttrs.isInWindowing pkgName:"
+//                                + mAttrs.packageName);
+            }
+        }
+        Log.d(TAG,"Ritter::WS computeFrameLw() D after mAttrs.x:"+mAttrs.x+",mAttrs.y:"+mAttrs.y+",mAttrs.w:"+mAttrs.width+",mAttrs.h:"+mAttrs.height);
+        Log.d(TAG,"Ritter::WS computeFrameLw() D after mAttrs.isInWindowing mFrame:"+mFrame.toShortString());
+        //end
 
         // Make sure the content and visible frames are inside of the
         // final window frame.
@@ -598,8 +722,8 @@ final class WindowState implements WindowManagerPolicy.WindowState {
                     displayInfo.logicalWidth, displayInfo.logicalHeight, false);
         }
 
-        if (DEBUG_LAYOUT || WindowManagerService.localLOGV) Slog.v(TAG,
-                "Resolving (mRequestedWidth="
+        if (true || WindowManagerService.localLOGV) Log.d(TAG,
+                "Ritter::WS Resolving (mRequestedWidth="
                 + mRequestedWidth + ", mRequestedheight="
                 + mRequestedHeight + ") to" + " (pw=" + pw + ", ph=" + ph
                 + "): frame=" + mFrame.toShortString()
diff --git a/packages/apps/CSLauncher/Android.mk b/packages/apps/CSLauncher/Android.mk
new file mode 100755
index 0000000..0bf332f
--- /dev/null
+++ b/packages/apps/CSLauncher/Android.mk
@@ -0,0 +1,30 @@
+#
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_SRC_FILES := $(call all-subdir-java-files)
+
+LOCAL_PACKAGE_NAME := CSLauncher
+
+LOCAL_PROGUARD_FLAG_FILES := proguard.flags
+
+LOCAL_CERTIFICATE := platform
+
+include $(BUILD_PACKAGE)
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/AndroidManifest.xml b/packages/apps/CSLauncher/AndroidManifest.xml
new file mode 100755
index 0000000..fd517fa
--- /dev/null
+++ b/packages/apps/CSLauncher/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+        coreApp="true"
+      package="com.onskreen.cornerstone.launcher">
+
+    <uses-permission android:name="android.permission.CALL_PHONE"/>
+    <uses-permission android:name="android.permission.GET_TASKS"/>
+    <uses-permission android:name="android.permission.READ_CONTACTS"/>
+    <uses-permission android:name="android.permission.SET_WALLPAPER" />
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.EXPAND_STATUS_BAR"/>
+
+    <application android:icon="@drawable/icon" android:label="@string/app_name">
+        <activity android:name=".CSLauncher"
+                  android:label="@string/app_name"
+                  android:theme="@style/Theme">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+    </application>
+</manifest>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/CleanSpec.mk b/packages/apps/CSLauncher/CleanSpec.mk
new file mode 100755
index 0000000..fae7663
--- /dev/null
+++ b/packages/apps/CSLauncher/CleanSpec.mk
@@ -0,0 +1,49 @@
+# Copyright (C) 2007 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# If you don't need to do a full clean build but would like to touch
+# a file or delete some intermediate files, add a clean step to the end
+# of the list.  These steps will only be run once, if they haven't been
+# run before.
+#
+# E.g.:
+#     $(call add-clean-step, touch -c external/sqlite/sqlite3.h)
+#     $(call add-clean-step, rm -rf $(PRODUCT_OUT)/obj/STATIC_LIBRARIES/libz_intermediates)
+#
+# Always use "touch -c" and "rm -f" or "rm -rf" to gracefully deal with
+# files that are missing or have been moved.
+#
+# Use $(PRODUCT_OUT) to get to the "out/target/product/blah/" directory.
+# Use $(OUT_DIR) to refer to the "out" directory.
+#
+# If you need to re-do something that's already mentioned, just copy
+# the command and add it to the bottom of the list.  E.g., if a change
+# that you made last week required touching a file and a change you
+# made today requires touching the same file, just copy the old
+# touch step and add it to the end of the list.
+#
+# ************************************************
+# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST
+# ************************************************
+
+# For example:
+#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/APPS/AndroidTests_intermediates)
+#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/core_intermediates)
+#$(call add-clean-step, find $(OUT_DIR) -type f -name "IGTalkSession*" -print0 | xargs -0 rm -f)
+#$(call add-clean-step, rm -rf $(PRODUCT_OUT)/data/*)
+
+# ************************************************
+# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST
+# ************************************************
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/proguard.flags b/packages/apps/CSLauncher/proguard.flags
new file mode 100755
index 0000000..0429cec
--- /dev/null
+++ b/packages/apps/CSLauncher/proguard.flags
@@ -0,0 +1,36 @@
+-optimizationpasses 5
+-dontusemixedcaseclassnames
+-dontskipnonpubliclibraryclasses
+-dontpreverify
+-verbose
+-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*
+
+-keep public class * extends android.app.Activity
+-keep public class * extends android.app.Application
+-keep public class * extends android.app.Service
+-keep public class * extends android.content.BroadcastReceiver
+-keep public class * extends android.content.ContentProvider
+-keep public class * extends android.app.backup.BackupAgentHelper
+-keep public class * extends android.preference.Preference
+-keep public class com.android.vending.licensing.ILicensingService
+
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
+
+-keepclasseswithmembernames class * {
+    public <init>(android.content.Context, android.util.AttributeSet);
+}
+
+-keepclasseswithmembernames class * {
+    public <init>(android.content.Context, android.util.AttributeSet, int);
+}
+
+-keepclassmembers enum * {
+    public static **[] values();
+    public static ** valueOf(java.lang.String);
+}
+
+-keep class * implements android.os.Parcelable {
+  public static final android.os.Parcelable$Creator *;
+}
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/anim/fade_in.xml b/packages/apps/CSLauncher/res/anim/fade_in.xml
new file mode 100755
index 0000000..9cb11e6
--- /dev/null
+++ b/packages/apps/CSLauncher/res/anim/fade_in.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<alpha xmlns:android="http://schemas.android.com/apk/res/android"
+    android:interpolator="@android:anim/accelerate_interpolator"
+    android:fromAlpha="0.0" android:toAlpha="1.0" android:duration="50" />
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/anim/fade_out.xml b/packages/apps/CSLauncher/res/anim/fade_out.xml
new file mode 100755
index 0000000..c1c4587
--- /dev/null
+++ b/packages/apps/CSLauncher/res/anim/fade_out.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<alpha xmlns:android="http://schemas.android.com/apk/res/android"
+    android:interpolator="@android:anim/accelerate_interpolator"
+    android:fromAlpha="1.0" android:toAlpha="0.0" android:duration="50" />
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/anim/grid_entry.xml b/packages/apps/CSLauncher/res/anim/grid_entry.xml
new file mode 100755
index 0000000..9de30fb
--- /dev/null
+++ b/packages/apps/CSLauncher/res/anim/grid_entry.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* //device/apps/common/res/anim/fade_in.xml
+**
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+    android:interpolator="@android:anim/decelerate_interpolator">
+    <scale android:fromXScale="0.8" android:toXScale="1.0"
+           android:fromYScale="0.9" android:toYScale="1.0"
+           android:pivotX="100%" android:pivotY="100%" android:duration="200" />
+    <alpha android:fromAlpha="0.5" android:toAlpha="1.0" android:duration="200" />
+</set>
diff --git a/packages/apps/CSLauncher/res/anim/grid_exit.xml b/packages/apps/CSLauncher/res/anim/grid_exit.xml
new file mode 100755
index 0000000..b7c30ed
--- /dev/null
+++ b/packages/apps/CSLauncher/res/anim/grid_exit.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<alpha xmlns:android="http://schemas.android.com/apk/res/android"
+    android:interpolator="@android:anim/accelerate_interpolator"
+    android:fromAlpha="1.0" android:toAlpha="0.0" android:duration="200" />
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/anim/hide_applications.xml b/packages/apps/CSLauncher/res/anim/hide_applications.xml
new file mode 100755
index 0000000..8088c1b
--- /dev/null
+++ b/packages/apps/CSLauncher/res/anim/hide_applications.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<gridLayoutAnimation xmlns:android="http://schemas.android.com/apk/res/android"
+        android:rowDelay="25%"
+        android:directionPriority="column"
+        android:animation="@anim/fade_out" />
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/anim/show_applications.xml b/packages/apps/CSLauncher/res/anim/show_applications.xml
new file mode 100755
index 0000000..222ae1e
--- /dev/null
+++ b/packages/apps/CSLauncher/res/anim/show_applications.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<gridLayoutAnimation xmlns:android="http://schemas.android.com/apk/res/android"
+        android:rowDelay="25%"
+        android:directionPriority="column"
+        android:direction="right_to_left|bottom_to_top"
+        android:animation="@anim/fade_in" />
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/color/bright_text_dark_focused.xml b/packages/apps/CSLauncher/res/color/bright_text_dark_focused.xml
new file mode 100755
index 0000000..7172e5e
--- /dev/null
+++ b/packages/apps/CSLauncher/res/color/bright_text_dark_focused.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2008 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_selected="true" android:color="#000" />
+    <item android:state_focused="true" android:color="#000" />
+    <item android:state_pressed="true" android:color="#000" />
+    <item android:color="#FFF" />
+</selector>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/drawable-hdpi/all_applications_label_background.9.png b/packages/apps/CSLauncher/res/drawable-hdpi/all_applications_label_background.9.png
new file mode 100755
index 0000000000000000000000000000000000000000..75adf056d6200a81ee369ae346213178ef72d77a
GIT binary patch
literal 178
zcmeAS@N?(olHy`uVBq!ia0vp^Y(VVJ0U}jSm^A_^$r9IylHmNblJdl&R0hYC{G?O`
z&)mfH)S%SFl*+=BsWw1GA)YRdAr-gYOg+fOpupk0{lowIO3~6&Emm%JA07o1v~zl9
zWN1pT9dUAGc&;VmzvRKqnK!CmhH`1vD7|qyaHwTRA5ZtPIPTMhZM&WSigqs9yoAeu
YL1T$_ipbwqaiIAOp00i_>zopr0Jcm$Z2$lO

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-hdpi/application_background.9.png b/packages/apps/CSLauncher/res/drawable-hdpi/application_background.9.png
new file mode 100755
index 0000000000000000000000000000000000000000..70ae4d9514e3173430f225475dbaff9ead7c2716
GIT binary patch
literal 596
zcmeAS@N?(olHy`uVBq!ia0vp^6+oQI!3HGTbkwH<DajJoh?3y^w370~qErUQl>DSr
z1<%~X^wgl##FWaylc_cg42<7AT^vIyZoRp?KT9M~qWz)mMU_eQu1uawSMKdIF)K?F
z-qYlur}llqp%O)fd!08}k`k9U&1w)d{>R34bItAumlN}5K5y+;y#2P)qBw1qZ|1Bt
zlO<l7KTr8ep8394yFe^w$?w<kb==c38mujL7pYF4KJ)p^*wZH8V^hu<sejxfW#9LY
z>0En%vE`{XY5UUFt-XI|`;?m}V$%4MeidpJY%lIN?l+2G6J45Hc4Galxp$cS=N<fg
z_grgq`h4TpcRyNvReT*;9v!x~_O(ntbGo(u^G`=+M%P|{%zx~$b;ZWowVUj|?w3lJ
zOF6u*l3&iDfsuOy0|YUPB``t|o6Z3y7;0dRfFcZ)*Xr5w>Vt0>eUYf}_}_R$Hwva!
zVuLCJOg|G3Oh2mx%qF0HNS3YH#}psg7kA~K&b9T+GWXqQI>&Clb58oSwSiZ4Q}xpB
zF1nv$wkGiE*1Gh~4e{xAsb*_~r{<Q{sRuU}&;B>@bmBATH0#Ze9M^O`UvVu{{j*)M
z!14L@d{6!u{#~N?)K#x~=JJ`QuPwH3<qv*ul%HH_m3ZR}OBlc0a&Jl7IU?J2_EyD8
c{S`}KP@J7!5~02ylx7$_UHx3vIVCg!0O&yVg#Z8m

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-hdpi/application_background_static.png b/packages/apps/CSLauncher/res/drawable-hdpi/application_background_static.png
new file mode 100755
index 0000000000000000000000000000000000000000..450eaa4542c95e55512530be810d778e15696b98
GIT binary patch
literal 508
zcmeAS@N?(olHy`uVBq!ia0vp^r9hm-!3HGruFshdq$EpRBT9nv(@M${i&7aJQ}UBi
z6+Ckj(^G>|6H_V+Po~;1Ffh*Zba4!+xb^1xSuK}BnPY|RdracQM6}n$w)ghV&3VE#
zrMr+{EKOatTuItgtV|=n)neXaW78*0&+KdWebqVh>3ilgnb6ql$x>@q+1HnEx|?Gi
zT|RH&`ss61@77qx|96f(+qdcF8^h}I%?tCjqEEzaYCdp}Z;{#k3y*WustZ;>ipoj+
zK0E(S#qWo4zj;}s(!SrU`TauX_2Rs(_B*w<FTeJYz0@lDGmq}R@BdEcHe1d7xqsOo
zsl%PCRy{j*H|a|gS7-n$5Q(l@zy(BFA?giUE1G}^ReaR~C(#f`AZmrkYOMh43Jq8Y
z(goHCk`)aB>m{gt)&GF_xrr*PHl5$KZoc%D^>3_ZmrY+Z`&3o4{r=}Sn|6!DJ}x)w
zsG4*)wL333#d~dhxxiOl>oa+qp00VUx~k**!eg1LyHD|bvibYMKIZ?n$+>CLH|N~u
t%{_lJwM_8L<@kJ`p9d=4*5os?F)03YO6_i)aT^$&44$rjF6*2UngDq6--`eM

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-hdpi/focused_application_background_static.png b/packages/apps/CSLauncher/res/drawable-hdpi/focused_application_background_static.png
new file mode 100755
index 0000000000000000000000000000000000000000..bec2cd902db46f5ffd019ae10693bf432beac722
GIT binary patch
literal 2219
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

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-hdpi/hide_all_applications.png b/packages/apps/CSLauncher/res/drawable-hdpi/hide_all_applications.png
new file mode 100755
index 0000000000000000000000000000000000000000..13e188f9cd746410ce0dde9aaa6707e0314bc64d
GIT binary patch
literal 5366
zcmV<S6bb8zP)<h;3K|Lk000e1NJLTq004CW002k`1^@s6$l$uq0000PbVXQnQ*UN;
zcVTj606}DLVr3vnZDD6+Qe|Oed2z{QJOBU`m`OxIRCwC#T?up)$C>`Sr)NeQ%^`Fm
z2?-$ya~OdQh{F)Djj^4?`<5gmSwrx9>-fd7<E(=*JeKv^$vSwmNxW?A#3Ac@gD)Ix
zeBc9f*{qFi4s)0ro#+7F(%e1M-CNbisJf>|Ga8LXBQ2%(zn<=CRae*7-+xtA4<!f!
zTq&cg&{w+P3aD4g2q?@@Ux1>he!sur&cA@k#DK|Y1T)?uF&gnc1B}rCM#caJ1C7K0
zj6wQL8z`VDTB;j~at&-rusPw;mKS&j&kGei&jZH^z=>NVywDa5a1B9@6ZZo_4uV+F
zejvcf`#b~#LGg2d3!=}wbdG!;-g0=0>TTS$A+COLR6QuRwfE5DarbQ`)5#3`Q^n8-
zL<0hm7C&Rqq%8#oS`vnqfutn>X&J~qP+=?xuox&<h^m~AK2Jd3WMQb$xA^wut*RVG
zaskPgNOqw9Iji&$?kpknkl_CoLLJz*9r_18?s|vXQHs{^<26lj)%)hY`dkFm3Uq;0
z=n}IqY$6x}W+m=)9uQMS35pDrnac4J6Gf)+B0Dkj0>R)Vbo{S~oqzr9>g!L$+K%aE
zMR79~m!5;aAAL+6XxX->b`oOhdKpZEmVlNt2GY$8WTYFwnvPUBVmQysY(oIIb$P+<
z4M0ba4_ew?G7H6j9g9A#MIE*Ff#2>vzy^c=_Qwskd@ytm`v|tFi7H!nUMMlp^sgzJ
zS_PE4Q*s<;$jwTJqTF=INbCQWCYNT0KKuMZsBY|mQ`H@Cw!RZs#9E9mF9=A53-90k
ztM?8E0_=m&{d(EHD~{5DR7n5dzw-VWWLBwl2F8Fr6036DW--FVVh7|QFwI6f=K9Ej
z9kZ!r*`go^3eGol!l9Fw;Lz7Ck}c&0tk(CgTK~q&tk1jp)lDl~6UJ0*E?{U(UkZdY
zLPU9S`_b`;koyrkA5#Fu>h;>Ivf;+r1yG!CL4Z>I))A{9{|vD>3x4$Nsj&KvDkv)+
zLwMA%f-;znEx-SjCE@=&IABL5sCr#IqkJ6o!uI1g8;#~8qBo0*5qZSZDzae7+#)C`
zuqFV;$Wl^ZN5Ia3dv2cv1$kD*6CR6n{;p*|+wur*-(Vr7sG+l~DVKb>26fmkez#+l
z!N9zOcC+xYEJqsLd|e4l9PbcAoMe?5lk(xw`)+`x*Om3Dc8dCC$xV+vvt;=rDeI36
zKU0N1!GQkLf4qA?Mbj^$uS_7bX7TKCNX;5l=O#;VNVe+lX26e^&qSUyEgh%ePV<=3
z*Kb<!xcLgG{gi7f#!>ffd~+r0#7&_Xa8fSJn^BNdc19{o=9R&}-m@627L%etml@K=
zJTLcQTn!wm<U<PBR6zvvC%=4s2~xSwDmVKL#Lg+@SyCLCB7ajVa^XM!`J2cbSQJ!l
z&;7<D|1N_{r2?QS0qV?(Vru1sPZu(b@fAho&Z#Vbarw4kQMb_~J2L|wxo-(LY-ut&
z^tzmd4{ynwb$@0evO%LEPNimE{{y4NI%X@n#T<O2m6P&dVrf>`iS1n;xOk~obU6jt
z7?U|#abM03;p1s$2Cgd20ZY13RZnwkFPyJy51l6{xn4om8-k$v&XQ(?Yo`{0Eu+tT
zjxWlD4L`jB*8T2%F<XUh<96EYSmc<yepSyGzuEi$Ir$)}tmzAu-HjZh>+pg694pM2
zk{=c-?D@PFzBt+>kHAPG$a!6HpXb9rqpb-!SNE=*i$IWK&aLmAfDiYd4Smn?>hq=l
z*VZS9z;0agO_)@c7i!a#iafYu*-UuuZwHk_MHJ2Kam?MYiDz98Ilp?sGhA$?hZE4{
z_dQu`U`&tUd&8dPqB-M3H>*hVWv2+J0;ZCrmpYwSgTg7pYZ72?FAH1VJ}TBzbFotd
zRQgU5UKZv2zGHn42p$-4x_$6p&wrw77nbF>PJ^o_=4)?lHD$COvCm#NeK47{k!n+E
zi!J+6baz&)_NrzSg{ewhF15SV%nY$i0YcD#BJ_caq@k%>9F3`K>=O5RPWis?|9ApS
z)xOZD4bIoMi=#W*victvibI8(G6^WdK}Xg4hcYIwV3G|iJxna6|NbYBm(#Ri1-`K{
zj&!8jvcs4lkn9vlb_yZzcopLW6$_QmEE^OV7sgVKRKMY13i5T8w)p&ku=W+?+F;qz
zX`%65LXgu(J<8ZhK5@)`uuRYEA5FPm5mbvk=Rwpd1~H_$x=_rS>89-jK?NMIWfs9Y
zEx5eAl}27bWlK4N?drOThe!x_ob=?ow@ia{voX^B&PS|0=BQeGHyQRQ*BK3<ines-
zk~=bK1M?%?X*e_}9hVs~gitzIPt~e`BvdZ1`K;8V*jw$x!4aB3ARIA)?_*>rPp#8N
zyEP4NUUXF`pQ{Z)(f?b~d7JIC*S>3;d4Jw$%P8U7HIz)A_dOhS;0~F3Ri1dXzo1{m
zPEPHyYFVkb-&c=T)e7P4B-Ab+3U$;fQ}6G#8z+Y)>~+ewDBAe7eb$=qjuudrtc$^D
zOkaUJ4BvPKiY5CE_<0Ct7Rkhj-YlWA6{f1#s`hZjtzu6Jc1FrmYh`S%9j27$#}c;W
zq8s0azIj#%dTpZtRKtYI8*C^pormvrT!919Ooo1YOH#djxQDCk%N}jWwrcmqxhw)<
zoAsR{wG9=bk3Q(g4fD!1r}k$vsXHkq{g{2$>gz`;s0vHzi8F6qg!<5kJF>XY5k2E7
zXzd@b>)}RZDJO(x1FB+MT@SZ^AfmPPnyCdb0vak4fTH)>XFssfTKQx1NMtI$7Q>h<
z3lwG)j&(%MwPK=0WFe<-OSK-Zq{4+L9<C4-h-huaDmZ71HI7UXwShKg9<<N;#q^QJ
zRD3N1O*2z*N8$`pc4oS6Y^s*XEL5g_@*0m<>)~o+-Y^fB7h*~TL~pAA<>RyB?W0PZ
zut2O`6Yo&ouz@O2^aR|ocAGh-PU;J1`uA`-Rk~0edt!%7o5WCgxUqH?6&={(g3Q76
z6HZwC-adQHUi+;3%TgIsiU5^CHl!4HWG0GFV*%A>F@?pQ;f&<NoGDILu{iZ;M$Xt6
zds<8$Zlr=oY4GgBXzeY^w<n^{7UP5ka-vqo!&*9t_LMG~v|tQ&k}yls(wLYgflZu{
z4OwH-RjdrlCUN1JCguFwZk!_4bIsHuD9E!%_i!VW@7z)uQ+qQV>51wyD^f9AkUD<D
zHuL8LN?0(-WNNxC$0n*i3gr1d(K{BepSfq{9N4-4Jk&IFszz!gdn+%o2-!<<ag;cx
zX<^j_xN&}kcpbbpXXBb%;k6yd;B@unm>ZANf7hc>W$D7JVrnlQ$4ziqM$yK3h_!e2
z9^UkRDvhU#pc;(n7R(;JV$CQ{B#VtL8AyeG=jN$#U6{Ov&1#0bemG~)_4HS;svm-a
zr>8z;yXM|S&ZAE?LX_F5No6YQ_XH)T@*$NOYq`|sglfc8Z9Ey;2XgiTVpy6HrcW*)
zCW=YrVoNt-YU~s3Gtx{jV+yJ#BepOSFXc#h;e#)+?I%|I8uoS*HdaUpraIf}-HJDg
z2e7f)jHPV<=rrv9tU5ezOAf=S!WAhtO-FY7p`R^*iqdSco)@+qhIe+K8gS#Wv-R-L
zZ-R-XIZ@B``q;$vnjmy?p358Dr(fQV_WU?{kiq2p12vi6FSIutL!k0Jc6MBDHYV@4
zzNuRTR6ATo4wCmxM^SRP638wO3x9t3fLPD@+V;2r#l_<dz~+}fkEy-gJ>JCN8E}8@
zsebEr1n7Qjs<CF5Nk|j@I;>0$fg1?0mkf-lu)EhAlbyn#avV8_h}TSK=}Q3$I%A-C
z#sgjvUfs|!sKzVxU<a?ia<QdnkZAJ0U{B3+o(pfijfpP<8bHFzOjYI?r-b?yOMvy)
zBX6z{+en^|u71M?$h8yAgzy;(+T5$p7Z4wS!4_PP-jo}%w4nQn8_%HUoVV_yKLook
zG%Lv(B^-nSOd3xXsG%N4&QgQHlri7s2|!1;2eP8Xb;>9W$xcCUP+J3PnCF^+Nd~dR
zx3$QbiwDkNZ^Jgvh3#)5rwFq$C`&*V{F#epONT@Kimi8dHXbx(Wd9J)<EgIegv`o<
z7?>*Pj;w^hB*4{wF!+Q_$5d=~q|(vl5huzGs6#k^qwnIrCj#wX*UG@LvQy-f)vr(9
zXJv4s0?Q<cr6Fmp{_HD9VI>a~P1iN`z|3i5V^qH+J9$~{LQEMVK}gIbuV~jfd46DP
zk~w$F4rDuDMNW}d28@+K#Nv@f0hZOURY(Q(iyOl`FQ4sZeeRQtIivFA`8N30^=0Cu
z>&T!=9<C~98)9Z`DpB!>2hCKzf2MwR<YJ7zP@tV{`Qj;m%jYL#paKLteFT^!po&UP
z3H3`dl@}k-?&dw#+=@y+8w3pOHB<8XVFw=?K8xhxMrRnGAg1yWW9zP7ADpUgi~eBv
zIzL6W^BJ^t66_?^EeR;AQM)nOR65B_#ZM)7`Sgc7#dsBkDqkFJ37-HKN#X!hVup|q
zn=16vwokrn=s!aya4xp>tH)hmKlcX&XpamQ2F{HH8{%GBobtZH(!fBRq+~Ny0X699
zsOj=LJNKKdS&JK5oN%GO3(AWfkyWSGDFR_Yv)i%i20js>N<(+r;%7P7^=WNncCx+4
ze6{aw4mum!A~-`NJN@x^yu-m%o&*&)x~uNfElOr+*MSDfvy3FXdO_4cNhdNK65;&{
zy6xL_pjLc0la9V-1D$7{b{*fm5dqptu+!5II|t<H4i~5jQ#lo=HJ_XdxH}JEpz52Q
zaQsZWdU^>V@eFFKGao`i7Oqeb-nOnDAAGpKRwvEpsrJ^sz1~~%)=t6^Qq--J0MjWS
zBU#G9AYT8HY@4bIsN2u&e4699AZF_a|9cU<;#w76B@UY@u0d_3;9)!b-os4W;3n%S
z^=R9-ZRa^r{gQ+Z_SU}UJpQML0-dMpi7+J+J3WN$48{_&q@tswfXX_Xj?{a)E^fyx
z>~{KK`<}Wm2V_cFHsobn;=b_B3nobQlxIVJPR5|?A?5R9m*B{$Rx**$?5qFiVb7UY
z{)V9SCzG8jjgq7nPAYSh@ZcuS3*r}D;Tc+XCe4vmxbT5LGA2tg!x-S(i%OvC>TFdV
zPB#lXKCXe9#_pJ}izkWCon8nFW)>y99$YSWc;N9DjsgzLu=B+BH12SneeG4Abwx@f
zcr_U!(iw^i%t+WJ^DUyZ>}}&w2TVQe?&4WmcI&t~lkzIRw}~+tO^lI&A1p0_ieek2
zYUy>c@Z?J;ptIL6dgs2@lg~QOZ2f@HL~I1l)<<Y6Zm_C05_ZX)%&oPn$`k8%HGWy+
zY&!g;($Kd)Zi41EZ%pHt$re1e`rMmmp~oc+hI5{_PY|H*6V8xgJDm}1r(a>HefAn2
zAn}V-hZ9sXE#_}KzIC6c?c7WFMEu6<*LOETU9%^mM?4(TjhOl0+s?qHcIkBvyubJB
zuA|TXiD0HX24_fQC<1iIRAjQ3GAh6ZG&V;Bw(-E`t=`VMw-sP_eAWu5>s(<T=Ws|1
z0`l26&qHgcPfjSf&vhKxyio{xJvx9YV7fKA+qjYmBL!4WV|PM{>$-iLo_Ae7`>Lqg
z5IgoA?Sj2Wx`7S$CG?Xm2Tygv^KaK6l`AC}IDgOaw!?q<74LVtbO3b`>>P9=A)YcE
zuiO!cB!pjXgMrx6wI4sZwRFK<-MM9R?!w2bn|;vX;$iOO3@FSoCas~}&H(H_*b3(x
zoZ`v=Tmr7k`!0XE`OkbH#83~x$}qbrg9*t3bT~mJV^*IGCOLJ3s{8brot}=G`qHZJ
zuVxIEJg0|)eaGBTGS&>!N=@Lf44snku{<0((*uW3cY{9=R1&|eyXDx6tw*<fNaSuw
zK;6X1%Ai7(kqD|%I5~dxLxg!at!MU}b+(*dH~Ge&-fqt?TY}r$)E<OOT|5-!Fi<|0
zfgF3{-tmVYoD(%}I9cr!=kMZCB+<TmyHB*A`QU$g8@{L^9z+iTCYeY`NLFYhBp>us
zseO~H%yRsiAtxp>WJ!|~7EEqgRZ+$KfB3#Vw|Ig0+cY$d*F{3QnTC>F3bL$Nq?Ks{
zDLrlun%V+T)8d1c4nMI7iv!l{tZ%R0zoqTuyT>$sfQPW7T0ps2z(n4!6!VU<-=z@<
zd&3eylY;=t=#IIq=3pa|CyFbVzB6(D@>Lc`?$x5IM7+6hNqTVx2Goik16w+JB20J<
ztW=c+Ju)7j@*_kzCCNiCVr8c@h>mj-h<soEmJ9gWI_nO;cJbhr{X`f>s@!M{9o91J
zze@w;GDnG(O2#Qe-dYI88Wr1HIC;Ui(iuzVI>we)rCT#6kk?VaJd&6(LB0`<cqs_p
z53t@&S4ZQauErCGnvQNiu9K@KGemA8Q^d;O4@l*XR;G%jXvs#QY4^V<Y|wM26i=B1
zmT5loX#*0xSm=%1@zb-*t8S|rQ&4fOIU{pCZ7^j<?+~74Jw5f#_KPRls=qwcd}>#%
z&UFJip_fOK!yR@TnsT7xQgX|0goY2-lfbHGN)T)@%VHuzAVXXI@irtlRfqGhl*N&s
zK6c{l0$fXW@ze>@G!p@w?TwfHo*oYZvZu50WQUHb=QP(OM_Nc=$%K4L0h$u(7cmtK
zjP&DtHSet@ohL;dD=L{3v&>i{2`-_^$v0(F8Vx`KN!o2KJ6R2&<mie5XxzVLGL-5!
z6>O@Wjim^n6!6SCV$uPYjsR>VK(*{70VRbca<@rI_l;Pa8o?_DqT>{`OnRUujVQn}
z{Qw&YQ0)>2R!8)}Oxd4^PSxL5Q96y%s7TV*88yO009G3+@tXQLLY)RQ5+v*<m+D}q
zI;hc@Wsp1Fpp!c$)i9-DE4g5o)2Lp(E%^YzNC0#sfEo>4a=D*&OM(7Ri)h)(Yg8*K
z!bk#hq=BlZmU(#_)UlzFKoxX=6*OBIDQb4KfT{-$2{7n@87-uNk;=$O<^Kd20Ng%E
U*N)AcyZ`_I07*qoM6N<$f(~>);s5{u

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-hdpi/icon.png b/packages/apps/CSLauncher/res/drawable-hdpi/icon.png
new file mode 100755
index 0000000000000000000000000000000000000000..8074c4c571b8cd19e27f4ee5545df367420686d7
GIT binary patch
literal 4147
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

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-hdpi/pressed_application_background_static.png b/packages/apps/CSLauncher/res/drawable-hdpi/pressed_application_background_static.png
new file mode 100755
index 0000000000000000000000000000000000000000..99315716d953760017de533de0fdf8b982741bd6
GIT binary patch
literal 2528
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

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-hdpi/show_all_applications.png b/packages/apps/CSLauncher/res/drawable-hdpi/show_all_applications.png
new file mode 100755
index 0000000000000000000000000000000000000000..2a768b777de269b827f32a575b2b65033c07ab7d
GIT binary patch
literal 5889
zcmV+c7yjspP)<h;3K|Lk000e1NJLTq004CW002k`1^@s6$l$uq0000PbVXQnQ*UN;
zcVTj606}DLVr3vnZDD6+Qe|Oed2z{QJOBU|qe(<TRCwC#T?v>J)t&!WRd-L%(Q{ug
z!;CW{45xqyC}<EAmFPyrBjy85jK{a@#$!L$pc@v=Cc04|YSi7RF_P7IVZLaLiQ)mG
zf*^++4wuZpFf$BuG1Jp`ch%eXs@|)9Rb4&Z!%XJVhksvHb@i*)?^nP7^<LEo2qE~k
zjI1JlI|Sc?`fV8o#b!Pr2tuzK$e#7@+V{vm{8dpTwFn~K5hYTKAmLgPC9p{nNH$z!
zv6I>^frD(@$-a%&V)Q(ToU84Vb|rFL6xDV~Kh<l|>ydpXpw+p!TNPxRSr}S1Dhf0!
zc#j-c6a+Fp5Q!)t%ea<hP4Ip=6oGIAZ-*lg!gZL`Si)2y_}KnG-_xt{8VGY|>yJiw
zKna*+phZzs0U$y^RJSEj1xW)>1C`Vcx@}W|6jhOEO+*7!q#%L;P*DT01pjXyt{32X
z8tzIp?p6i}hED3J;u6BL7Y}d^9^+5(_D5L0j*dKVHv*zxL;BYVFk~AkL(?A-%y&+2
znVLKMUdj;A0VS-|*vY_=RF;w2PQkO=Z7QHo{O9*htK+}_^WI{7-5=rW-H73y2$Z2J
zOSK;Ybi=?@m7Pd~h_DosRAnk=X`>vGpAXB*%l9swdNA33oK;ye@|dcrTY&>q)B)AN
z6sa0zpxRW`s;XIA?@jviZ|t5Sh~m%iHLte10bS{K$V_uUdYT=wGaRbMV1=mMj;<j1
z0y1=YL(t(4>h#59U4pk(;z3{e@Y<apW7Yb=%3EiCJR)pruR%4aTfu^z+BRXOW>2XK
zra&iKo_&4SnHa>!@%1h@e>SQh9mW*9plp;2(wxcvq(D%HV<$auq@f$?PIO}%$=HnM
zVcEFi>CIcPExq&6yD!-B%>q@@oFa{#0tcvQ1XR+TAq`ZvFG3=1^vtW<Q?V+z58pKR
zVNf0Hcz#YQOsvX-l0p}xI3!NJCEs`Qy>Vl*REc0G=_m$v=Ycl(x}j5T2mf~-26y{C
zt3G-*6qbMb^!*FFz7Zjf<_Kv367U!U9azn3qS;Xg^=vhOMe5~>%+guPQ!j2Fivit?
z!CZ+CIEX#U#42_EtTAxKyh^An&BDO++(xoulLR=kG!w4BxDu9JHWrHW(y;ACnkeXY
zeC<8AJowi+vELnmpz>_A(eT7UZKmBW>7FhVJ)BX!S<!Ncr&g5;Prdm0V##LTiFc<l
zR?V4S3X3nPhVqiEet<E)lwnnV`{GG({lamOmz}B}!{C<T&}qYuR=j;D>EF<Wv>!mV
zb50Kf&cWhNy6s>gj4c|jFfo^Dc))IZ@Qr`L&d}>>Sb~{SoSzQYFPaDwu)6K7cixvW
zbzD9yTRH<Sn67)c4%~s?Ou6pK$4Ng&tW9Of0S1@`8e^k&Toj|n`IuAW5(A`6KeJT0
zW#wxRVBj8L$0nXx2y@OZRlyvLG&Sk>H5XUI8Kbk{_iye|6ArjDcTKqZ@mvh-O+%5e
zeP$}Nn|fx5V<xkoHtGd4?^vYC10p=2H?Mg04pEdIAmEYD&Yw{Rb7zbhP<F;EGbR?p
zvYTc>da9iT^h?M6)0!t~T4SWCU#fOhU~RgCM2<`JGhOA<a7WKP30e|>0Q$rKc=<{U
z=o1Xk@6H<w6UP?NjLy*bSAiX~`)-|sW8oAA?7vnldgP}=4cI<sl+L?hwIQXasoSU{
zqys6ie62`=TXhu3_R0GFwxY7}_e(b03VhT-&b{P2W1(_P&X5fmY8y_$FMqoU{QeM8
z$8tF2Uv&I~l^-OdiU%U2)Mrq?bK_%FwNkrj(~|cRO-N|0)BskY6r+iEq{!njnE!{p
z%9%i!d;U3Rz_f{@4A&sZ^<zz4;PwW!yeth!^&BkyAEHTmay&054aSz|8QKYlW!PWa
z3a7e!`gw@uauLn%B4qe%RDlbojvpQKySMLaf;BIErrOwu961^Cv`=gPZ1u@Rzz&Nv
zVXS%;^kjqvCIyiu)yeitk1P?EF8|~0qGVf*k7NJ^qhd@hOvQlmKid}w!;9EK>FD&U
z1HxiQq|n^08b>Oz+qkYO%Y!?X&Q|-=jc<rwJ@YX%x4QMuWyN?tjY&=IAvkOND0q0;
zcMU$kjLD<niuu*>=KD3|hZRXFS&!k3rD`^Eke#P~v8np(icQp$5t7IN1%5gV<VdJ=
z>GGHUj<<h{p~+y(NW%`uf;m-`DN*@!`*9UeE)ftFq!>YwwdpgN0(PLb1vY+OtG4s@
zNBdPkwa+wBsIc>+$D%g~!q?dKRRacZUrgVwyKEAiQIbtnoOnaw-23KJ`zj1;P@~gj
zlEHpPogo3(qzN9N#gfgj6YpKhz+^zpoly?Xlvu^lc+zcTrp_`31TukwqTrI$U*jpY
zox?}l)qO=~pGUu^a9|qtQB)foI@)R(?%aIM44uKEE%ixf(KN^K2bEL15(QEejp{ZO
z@VGFDFJs&JCtMfk*&8}&MFkl!t};J{2}H;wHLnUab|M`-#lSdZV4*tsEh}0(;Ych?
zWnTTpf{EyL$@gVhw(MVZMIKyqZWVJ##%EM5x_YqL+Aq0ZW=C1<$>uYuGjw4}s%tmi
z{sE#{a>hED*0awpi=VbrS0^Y2HW`@3vCa%GJD0S>@AKfBnX2%%8u5-({Iue=ize&S
zh=Sy}j||IT0^4U$MV_79auQGH$rL;wzZOJk1FkC&9Rb8SBLt9w{B#&IDmyxGCSlC6
zQndykIhD(+UzKre*@~<f?Iw2<=<MViF{DHp$!378BquW!<}<c}a8}Mach9B34o{{U
z0HwziIdYaOr|1j3`ENQqInPxEiK@P-6G!(L@W-e|+32zItduSG6~wn=R<$UWot)ZL
z^iT&9CMFinJu?~>+S6{LV=E2@Tl);EzTgXQ|8e!rB<@{-LzOS^U`(N-VE{*4+@&#w
z+zjI?3gR-rsCtn#E8}{z(eIIVbij4C8a-UKX7-e0XEeZs9{Wkcu`#2vs3UB@(vd$o
z4F+koW<P+cv$Jx^y=ymMfPbORW}v7lV*|(>7j4C!f(If`oyY8Hv=o#5i?NN=qt$Jz
zX`cWE$jWZUdbkQQs#}Z9L60(TRwX+#$60#8tYOR4SJwO(vs1ZMkZil@G7tlp3=l2z
zLO~_VFR@gX=O$EZQE%7CLRm?MrIe{OQ)Gy3Ej(P7Ns5~dO7L%Tb#ZiH?P>F=T^(>>
z`;<{y{FDDFwA&reAS7I69t<*g_;{41#1;}YNLYk4CNT%8r=qU*lNEy<lucP6!@fCN
zgre%#0H%qVh_j#8fF@olQ;Ah@TB-v)-T*=MJ9K;_1D$0$ZBQ5A`3#v=c@B?Hfxz{b
z4*?j<WVRGj*0v*9GSX5Y)0L7i7b+VP13iGt?<1p{Mabj`@g6RhLr##1PuN#tiYiKT
zVDG^b*se;GhYeFNx%p97iqo|QkH>AqUJ0gE(uiC6uCQ9sm>S_gbtM6)##CdDHW9Fj
z8Cb-rUd0Hek_1q_O~#jEXNiD{adbJ$FCHB@_CXyNv!Wpf>ZP~*<^oBQ{(uL$0;w7W
zK;Uk|=qw57wu-S+R*-?I`8jDx4N_*h0~&ab)udWu!R6F0-p<R`u0yU@cf6f~2|YVR
z79~G7J*o3Y7rLT}nY5xZT-8&y%0r5&v#$DCN_tlQN<6m96(mb!8cmj?o-c6rMi2H8
zzxtgyO`wG{_;aVzp44qS_ndOrd+20hmLgN^iT53L5iUHpO1;kI3nswU-StU1MCRg5
zvBSdi$0gO@%nWB#9gFsCQ+8=+F!kK;|7wyX*<Zn`bBdzKbk+q~swSkzq@dfb7^YH{
zOhTDt2DY*+2X4RN9N6%A9dvd34Kp=bd<j~u+e^)s=jWuuHJ43+qWlc?I+Mp0!_V)z
z1m1f8E9mI*B|Shz`7XHOifK?>;7Y2$sZKj*WJT9dv#G-5OYe1HVy!_)o}$h~(5?ww
zB&53-d<syvsYb7tu~kvm*@{WCr3!~WL{6vh*C4<W>1#VZPDR@JC{aiojLcFzP*ruY
z@4Z#Bt8nZ!m9v*Dw>g~4Nm4;mxr!+tszDp|Ea^5?zuG>~9IN(#QiQ6?WD1$7IaJpU
zoo;`O`s6i4boBzL3^fB73d^b!)83gpQ_0GQDb=HrK0g?YaCd?n;Q$qe1XGDU=x#YI
z?tc5hC&!$9-KSZjCp`&*ZJhcfnR)34;=NwB%|a5OpwmzXZ+CSERJEC?czhvv?1jzH
z(&mZH+ae`4Z;Q0!r0Gdxi(ti17O3e+w<iGiuX-1nTf2KbNK>kdVdb3{8&*EVD_(zy
z!!+pU039&9D)s=VNR2!(63*j0*VP}|@YK!T&J(W%Lt*uf42B{Q2!>Vh8zch0KnVO;
z$T_Oe^MjZzgfZGWA(T+w{rIp7sBDogl)33U%~@hOTn*$sn3aFqctCCE^>_B17NDf;
zJ=m<blSn*d9TfvL67USh6r3#%pgL12sAM)jCFE@r>OOh;`RvO1yE95>-h%{tp`Mj7
zuqEpKa@w5Enrl%y0V)|gb)>#SpV5i+aFr-KW3oh=202o%g)s-~TKhCmter%qsU>>j
zL_7`6CYBDqO*IKK_+n@6hMMlCUCXj2T>H;LO72`f$dA1*tV=_4mkLlqdm4@ylkw(-
zX2_hsHQHSEU6OC^OJVIKDks~znP=q>x9w{iDzh~Fq`pFfW|`(Nb&&&|-i}?rd&1ka
zV~s3_-MwA<*wXG*SNJ7TXJ%C^n^yY80%}Yu^fo5#AxoH)`aM#wt%*WPs18N^@=yVl
z2bXjzOq@C_#OV8I9iYd;f%*@(cn_|-R|&ay_wLTeHt#^QX{ky);cceHk`pDmFf9f@
z6wUwk71c!jtZ(WBuTOK7lu-8$3!)4vs60!<6hs0jG5p<B7{DRf)7a+O^V~z>j)TwP
z(G4Vf@%=|y6EhWAtshdThie2k{_ILWFclIrwdU)n-Il%0J7AF30QUt{B3=rt%36Qz
zU)N(<jv~Gz$y|Kf?nd<$Hi=kjT(+rLs@+5k>ks{#h^gE5G_jL|f#aKYaN{_jPbnu-
zzY4XXR=~Qccqq65HNHP}xS@N`vnwL*W3LgXzNd>5o4R{{vl_3)l{m{blLAy{Sl<c5
z+KDI4*g-nl(5b23K-VTY(BY?~Km*NKF`3_DVOzZ%TX|qL)+&*p@6ft8u)ST0<WN&j
z7udM<SnL9@c!H8&rNF26EN$&+qzQZK+oo*|(acq6?R%VqDG#&?7L&Y56^^x`1g!PZ
z&%>dXU57mTez#oqo_Hr-<NFS^s&_b|3%|?~6MrhG*VAUGKh!U6$4a_ALHKNE13f3)
z>^r*t3p!RZH+E<!ftrZ5o;a)};096H>-Fw`ac%I#mWS{U?yze3FCQJ&ou63Y)UIM&
zwwW};`a}I96t|BbZLL?=T&Zz&XWh$KJB3W3qM-_^*@22sV69l&%>k>jHrTjnm$zo^
zG9}RdnH5|29&C*+pf-te8mkoeE+Yl?!;o6{tqq&bO*<NCt~cD;edw+C=uICs0SiMF
z)MUM5OD75g>h|n?_K8r-&d2bG7^X_zSbs?Mgv|~}c4kVi)h%Cgvz%%>x!KM>4HRp~
zEN^~TtEMs48JhNkFDPNJ-vZPj&D5S)%WSQc6J@Zqfurw!<~{JrG9}ohCoEd=9sj5G
zU&lBg7oA&v+JLgx^r-EecgAV|P`({rKH1R>hwHWXWywMJmz_1QzfZ>@L_w7YBUbJ6
zljND_ECcuUHGF>9#!UhcdZbcGqjd`XjGQB7jK6-7GjIG7L6RI~naoY!tA^<l3Jljc
zSl0m`Y&iy9o?z1b%Fj-P%jZ==Nl`|>x1;8+Px|16HxH>ZPvJ<&*S=@n-M;2857QgD
zi`G60u<ij5i`N4XP)VV{GWJUpTn7cw46KtLC&1cLOXf_-sJdjOC`vXbX2osSPJ}Z`
zTrgD2sqPT0{Y$Ot^^!&EUB|brZr{6ZJ=I8EoQ7hmSm7P6p{#z*;36WuNLVm+9P&4A
zt_im7|AXp1VlQ&-TL+=3#hX+DeW0b=8-~}`*Ml#h<yC_2#=m1gH*n@BNF@S8EKS%a
za8034C{Dt{kY;q(y!N+nSN)r$4f1x+=do%#*64}r5f6rRx<l~F`Ub4N!&>;_Yv0zi
z<>_ZQK$(O&PzSv9oBB01OI7k}W@{zR)~0Z_HqE4x9fh;+y364zzL30~)akIpRSU+z
zq{^&8SGmpYA$Vs?i^|kUBm(~K_C0kUKJp7W<nvgBbAAeR#LU!TWmBy{CAE9|D&C1Q
ztfb&TP3ORM6wbQi$IhIxE7%*pXHL$8i)Iz6uOAqUvge2ww$^m1uk0Z<)Yp09^RGWx
z^=k|$i^X|BeLbn)5dmrx+(-G<6E@B}W}q@rfi0MR)0G*;lW&wTs)V(LxlXwBykaOR
za1I!lU0xZseC2@?Z9)3S5@c|<)V+K7{Z-E^a@cC-%FC%=%bf3s0#yU{5p(Fn1Dio5
zoq5OERSPEPjazuP<Z$M)znC$pDidZ;%7&~A+dphjf?)(T^&vP|A5fR4%IaUb2nS9a
z*!aK4K7Z-cI5D}GQ@e4qNFxqZ`nncyfAQaDU{m7&>u_e5<rYo<{*ttul6jJ76D9gK
z((3Ybm|T?sMLG6<8w|G(!O<2O>YBq43M(p@grVM!6JOMBef6dGqdOYnOlWvbb~LWn
zJ7Pgqf!+476|hVNXYe+b*y60RndL>3F8@JlX5kF=6|?j$YdJ1Ej4e%t;#@lvX4{~*
zFB~OLV34(9O&tn!dbo#~Wd;21j>C03-+uA<m+u^i6Q+4gfQA!=F(VpOa-FWN5AndJ
zm{c)yo}3g|a*k9m{^IIU6EFLrBR#81e;Kr>flMBV%5m8s4~r|E{P6|tjcXZB0kq|~
z+LN^1er>-yKvvLkbFOq<anRr0(6Ddg>-#spuoYsb99ekAVr@U?7$uxL9r2)&zmn0p
z<(Gmf1LZV%#i<;yc6zQ@SUtZguVUs5SAN;7l+?^IjJfR1r6PL;t;qegDg6y>g6WAp
z1fhVhwX^ximXo!+zC65TT@4slQHCgRJ}UeS6z}OKj7z@}ppsYKb!`4G2CURW&X}bZ
zZH%?do6aenl3y}q;q1)9imA@@>~gz3B{LDI2t|A$pZmDG<=F1JFV}BvsQILcOPcUm
zF$Sog1C_0)G}}=0EvWiyV+CmY^ygL+0;!xh%{gN#A}8v_(sM?q=a-*VL}H=b((&c$
zb9&@?n%4Rg;h-nb)m(e3y<z_;(`=JsG3&%<iu_<&9@|?$zj2@nm{F~p9uVS82sllk
zrkK<*6ZU-ptRE9VT#ZbC@(b2OTn?8{{{=aAo>p#mSb+ME=o6P(WEm(s2d0w))xoh=
z;#IN*ux3Dcc1BFOYBQ+(94T)<dyUYr`KyfmT-dLcEm*|XMwvmiTiIHOeK5(2owCV(
zhB@_Wp70)&HAf=>RDSRUh+Sb}qXTU>0cz*ewq&-maqK7md{7vS%TU55H7gHwFo!y*
z5Xbh(oSL+mK;&yPQ-vO!BHotDTrHcxgy8__Z~!$PxB?w~iF2$(({{Y)Lal&ROzPfj
zGZ74<VuRsTc(u%c5KPQ811iM1IrzsR%=NGXayWx(6`BYfd%*(CL?I1~1R(kH{{jpE
X!3xSI6w*O!00000NkvXXu0mjf9yVM%

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-ldpi/icon.png b/packages/apps/CSLauncher/res/drawable-ldpi/icon.png
new file mode 100755
index 0000000000000000000000000000000000000000..1095584ec21f71cd0afc9e0993aa2209671b590c
GIT binary patch
literal 1723
zcmV;s21NOZP)<h;3K|Lk000e1NJLTq001Na001Ni1^@s6;Q*MJ000JpNkl<ZSPAV|
zTWnNS6kYeubY6Whoj!oJloqJGA0nb5fDz@Ri3x^3On~Tz5)-4wS4_m1D8}&Nhfxy{
z69ayjV2tmmi3my*6%bHLDd3b!TbgO<OkeZ557)lsPCB=DDm0)!?#Z5e&z^J7UT5un
z&e?N;|7BtZ6qldHRz&qty;Kj?tsl+TEe4;^sTwtN^<Hc_aXON=04dx0QuR(xarQnl
z*Y$?on0m_h`QGh4&vC>ARe<Hh2}sx|ed^8SkIr5c-eKY<z@Y<$pYtcLyzu(tC*Edr
zfGVt6A|V+oDjOw3!~L}g5sYa<;YBw!cvP<gp2D9sD2mKstmNBG(}1d|`Ohi}28QFc
zd@4j8rse<%fUzQs`BO<V2!pqV3cn|URWqK1t{KpE6MB{**A-+kBUsn?3bR3hq3JMb
zGc*%gR>P91Tc8>~sHP8V>Ys(CF=aT`Sk=;|pS}XrJPb~T1dys{sdO&0YpQBSz*~us
zcN*3-J_EnE1cxrXiq*F~jZje~rkAe3vf3>;eR)3?Ox=jK*jEU7Do|T`2NqP{56w(*
zBAf)rvPB_7rsfeKd0^!CaR%BHUC$tsP9m8a!i@4&TxxzagzsYHJvblx4rRUu#0Jlz
zclZJwdC}7S3BvwaIMTiwb!98zRf|zoya>NudJkDGgEYs=q*HmC)>GExofw=92}s;l
z_YgKLUT5`<1RBwq{f)K<EkI>~I%M=gRE6d<FHDq&W)h|sStE^=^^YK)Y-gCukktCI
zyk;}6aco?&J1^Hr5X_bX_y7#KLtFtxLbEV4yat9bO7raUdvlKkyy4uvOtCUJFV~jL
z4F_gf?I6P`67*JZthLs?{Usrbgxc+9-qjV5^bjy6SJ}TU{|O*fbxYmRsk;KwbuMGF
zV~6Z!up~a*#1)Wq6hM;=nYFAZ2=_!2bp<33Og4weD-y{LCU=7y0hUbw7ZO)M(s|N=
zOdXwxqui@za+L9lLcsL(^&t=lRI|f4WUhcDzSj?k+on>)b5BP`8{u9x0-wsG%H)w^
zRU7n9FwtlfsZ<KFSWNbmYXiiN*Ok-)q-Xedoa)(!*hmY~dIHC~-a*J$h1uondA4mP
zSU)GJA(2QR7z~OFS!x0(50ooIHamrqTGLZ7%q)D~GHbL$9Xrt0`x#VKN-6Q6pnl3)
zbR>SjiSB(k8~Y5+O>dyoSI477Ly?|FR?m))C!ci%BtY!2Sst8Uri#|SFX&)8{_Ou2
z9r5p3Vz9_GY#%D>%huqp_>U}K45YGy__TE!HZA@bMxX~@{;><au~O%#R=eO1RfrvV
zN@}1b)ej(%>cGYRgH~Ih*vd7EgV7h6Pg$#$lH+5=^lj{W80p{{l+;{7_t5cv3xVUy
zl_BY4ht1JH*EEeRS{VwTC(QFIVu8zF&P8O$gJsMgsS<v<^cG8zH12ME8E3p7ArSJ)
z&M1j((`t=fkRbsyk@k;7F_7#+Brq3Ek@Z%>O35SVvBrX`Vah$Yz2-5T>-`4DJNH;N
zlSSY8-mfty+|1~*;BtTwL<Ip!$O-{6nJWXCZfj~?gGcf6rCkhL5i}!%NU#a3>z_w5
z+lRv)J28~G%ouyvca(@|{2->WsPii&79&nju7ITE6hMX4AQc{|KqZN#)aAvemg3IZ
zCr}Y+!r}JU&^>U1C2WyZC<=47itSYQ`?$5{VH?mtFMFFExfYTsfqK%*WzH@Onc#i`
zI@a|rm-WbKk{5my{mF}H>Duc$bit&yLAgFfqo2vVbm~?FeG#0F?dSP*kxSo0Ff!o@
z(C}B;r&6pa-NY4;y~5lX8g&*MYQ>yLGd^tDWC4(sGy$Ow-*!eh%xt;>ve|J1q$*w<
zh;B#cz!6l2=5bkX#nJ9PJQ`ew8t>7z$bxqf*QB=l2_UB$hK|1EIfloN-jQ=qcwChF
zYAkkyp=;FwcnUB3v0=*tMYMA(Hdy<PN`g-^IhR&%fzFN6N*#&lHK?Lk=ZxLc=3rdN
zq(e3yk0;yO+EN7N%Am(wh<K-;2jmbL8HO+Z6SBz}=uJg)0~flX15@%oImi=w^eu?^
z%t_uJK&!llk^e99-)25FLY2R~H%i2Lni{9JP+O^e)Z7~oXC_K$<<GxNRbG`8Q=NTi
znzRTYIm5)q73$E{HZP;%WJucbIzw0y6~<h{M*Cz$0Li2UlrSYKFR#RI$=`tPT2(|y
Rn%e*X002ovPDHLkV1g`*Fem^3

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-mdpi/all_applications_label_background.9.png b/packages/apps/CSLauncher/res/drawable-mdpi/all_applications_label_background.9.png
new file mode 100755
index 0000000000000000000000000000000000000000..b1bf466cafe05b83cd45c02016097f9e77ff274c
GIT binary patch
literal 2833
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

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-mdpi/application_background.9.png b/packages/apps/CSLauncher/res/drawable-mdpi/application_background.9.png
new file mode 100755
index 0000000000000000000000000000000000000000..29ae09af4cb7a8dfed5768688859905a8a1388ee
GIT binary patch
literal 3083
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
Q1ur5nF|gFHgSo`~FQ102-v9sr

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-mdpi/application_background_static.png b/packages/apps/CSLauncher/res/drawable-mdpi/application_background_static.png
new file mode 100755
index 0000000000000000000000000000000000000000..9af69833ec4bc26a85f7fa2f0ff65c2ec080a282
GIT binary patch
literal 3029
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
DBfy~g

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-mdpi/focused_application_background_static.png b/packages/apps/CSLauncher/res/drawable-mdpi/focused_application_background_static.png
new file mode 100755
index 0000000000000000000000000000000000000000..3a6d47cb002d1a657340bc8df1076e76a034392b
GIT binary patch
literal 3792
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
GLSTZz=m9hU

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-mdpi/hide_all_applications.png b/packages/apps/CSLauncher/res/drawable-mdpi/hide_all_applications.png
new file mode 100755
index 0000000000000000000000000000000000000000..a67cf78de082732e7dcf3c42bdb707b7dfd01b46
GIT binary patch
literal 6577
zcmV;i8BXSjP)<h;3K|Lk000e1NJLTq002$^001xu1^@s6zk*Dx00009a7bBm000XU
z000XU0RWnu7ytkYPiaF#P*7-ZbZ>KLZ*U+<Lqi~Na&Km7Y-Iodc-oy)XH-+^7Crag
z^g>IBfRsybQWXdwQbLP>6p<z>Aqfylh#{fb6;Z(vMMVS~$e@S=j*ftg6;Uh<iVD~V
z<RPMtgQJLw%KPDaqifc@_vX$1wbwr9tn;0-&j-K=43<bUQ8j=JsX`tR;Dg7+#^K~H
zK!FM*Z~zbpvt%K2{UZSY_<lS*D<Z%Lz5oGu(+dayz)hRLFdT>f59&ghTmgWD0l;*T
zI7<kC6aYYajzXpYKt=(8otP$50H6c_V9R4-;{Z@C0AMG7=F<Rxo%or10RUT+Ar%3j
zkpLhQWr#!oXgdI`&sK^>09Y^p6lP1rIRMx#05C~cW=H_Aw*bJ-5DT&Z2n+x)QHX^p
z00esgV8|mQcmRZ%02D^@S3L16t`O%c004NIvOKvYIYoh62rY33S640`D9%Y2D-<?i
z0%4j!F2Z@488U%158(66005wo6%pWr^Zj_v4zAA5HjcIqUoGmt2LB>rV&neh&#Q1i
z007~1e$oCcFS8neI|hJl{-P!B1ZZ9hpmq0)X0i`JwE&>$+E?>%_<lS*MWK+n+1cgf
z<k(8YLR(?VSAG6x!e78w{cQPuJpA|d;J)G{fihizM+Erb!p!tcr5w+a34~(Y=8s4G
zw+sLL9n&JjNn*KJDiq^U5^;`1nvC-@r6P$!k}1U{(*I=Q-z@tBKHoI}uxdU5dyy@u
zU1J0GOD7Ombim^G008p4Z^6_k2m^p<gW=D2|L;HjN1!DDfM!XOaR2~bL?kX$%CkSm
z2mk;?pn)o|K^yeJ7%adB9Ki+L!3+FgHiSYX#KJ-lLJDMn9CBbOtb#%)hRv`YDqt_v
zKpix|QD}yfa1JiQRk#j4a1Z)n2%f<xynzV>LC6RbVIkUx0b+_+BaR3cnT7Zv!AJxW
zizFb)h!jyGOOZ85F;a?DAXP{m@;!0_Ifq<Ex{*7`05XF7hP+2Hl!3BQJ=6@fL%FCo
z8iYoo3(#bAF`ADSpqtQgv>H8(HlgRxt7s3}k3K`kFu>>-2Q$QMFfPW!La{h336o>X
zu_CMttHv6zR;&ZNiS=X8v3CR#fknUxHUxJ<AYmRsNLWl*PS{AOARHt#5!wki2?K;t
z!Y3k=s7tgax)J%r7-BLphge7~Bi0g+6E6^Zh(p9TBoc{3GAFr^0!gu?RMHaCM$&Fl
zBk3%un>0uoBa_M6WNWeqIg~6QE69c9o#eyhGvpiOA@W-aonk<7r1(?fC{oI5N*U!4
z<uv66WtcKSRim0x-Ke2d5jBrmLam{;Qm;{ms1r1GnmNsb7D-E`t)i9F8fX`2_i3-_
zbh;7Ul^#x)&{xvS=|||7=mYe33=M`AgU5(xC>fg=2N-7=cNnjjOr{yriy6mMFgG#l
znCF=fnQv8CDz++o6_Lscl}eQ+l^ZHARH>?_s@|##Rr6KLRFA1%Q+=*RRWnoLsR`7U
zt5vF<Q0r40Q)j6=sE4X&sBct1q<&fbi3VB2Ov6t@q*0);U*o*SAPZv|vv@2aYYnT0
zb%8a+Cb7-ge0D0knEf5Qi#@8Tp*ce{N;6lpQuCB%KL_KOarm5cP6_8Ir<e17iry6O
zDdH&`rZh~sF=bq9s+O0QSgS~@QL9Jmy*94xr=6y~MY~!1fet~(N+(<=M`w@D1)b+p
z*;C!83a1uLJv#NSE~;y#8=<>IcfW3@?wFpwUVxrVZ>QdQz32KIeJ}k~{cZZE^+ya?
z2D1z#2HOnI7(B%_ac?{wFUQ;QQA1tBKtrWrm0_3Rgps+?Jfqb{jYbcQX~taRB;#$y
zZN{S}1|}gUOHJxc?wV3fxuz+mJ4`!F$IZ;mqRrNsHJd##*D~ju=bP7?-?v~|cv>vB
zsJ6IeNwVZxrdjT`yl#bBIa#GxRa#xMMy;K#CDyyGyQdMSxlWT#tDe?p!?5wT$+oGt
z8L;Kp2HUQ-ZMJ=3XJQv;x5ci*?vuTfeY$;({XGW_huIFR9a<fJbF^|4I#xQ~n$Dc=
zKYhjYmgz5NSkDm8*fZm{6U!;YX`NG>(?@3)XSs8O^N5RyOM=TTmp(3=8^+zpz2r)C
z^>JO{deZfso3oq3?Wo(Y?l$ge?uXo;%ru`Vo>?<<(8I_>;8Eq#KMS9gFl*neeosSB
zfoHYnBQIkwkyowPu(zdms`p{<7e4kra-ZWq<2*OsGTvEV%s0Td$hXT+!*8Bnh2KMe
zBmZRodjHV?r+_5^X9J0WL4jKW`}lf%A-|44I@@LTvf1rHjG(ze6+w@Jt%Bvjts!X0
z?2xS?_ve_-k<Mujg;0Lz*3buG=3$G&ehepthlN*$KaOySSQ^nWmo<0M+(UEUMEXRQ
zMBbZcF;6+KElM>iKB_KiJlZ$9G`c^=E@oNG)mWWaNo-3TIW8)$Hg0Ub-~8?KhvJ>$
z3*&nim@mj(aCxE5!t{lw7O5^0EIO7zOo&c6l<+|iDySBWCGrz@C5{St!X3hAA}`T4
z(TLbXTq+(;@<=L8dXnssyft|w#WSTW<++3>sgS%(4NTpeI-VAqb|7ssJvzNHgOZVu
zaYCvgO_R1~>SyL=cFU|~g|hy|Zi}}s9+d~lYqOB71z9Z$wnC=pR9Yz4DhIM>Wmjgu
z&56o6maCpC&F##y%G;1PobR9i?GnNg;gYtchD%p19a!eQtZF&3JaKv33gZ<8D~47E
ztUS1iwkmDaPpj=$m#%)jCVEY4fnLGNg2A-`YwHVD3gv};>)hAvT~AmqS>Lr``i7kw
zJ{5_It`yrBmlc25DBO7E8;5VoznR>Ww5hAaxn$2~(q`%A-YuS64wkBy=9dm`4cXeX
z4c}I@?e+FW+b@^RDBHV(wnMq2zdX3SWv9u`%{xC-q*U}&`cyXV(%rRT*Z6MH?i+i&
z_B8C(+grT%{XWUQ+f@NoP1R=AW&26{v-dx)iK^-Nmiuj8txj!m?Z*Ss1N{dh4z}01
z)YTo*JycSU)+_5r4#yw9{+;i4Ee$peRgIj+;v;ZGdF1K$3E%e~4LaI(jC-u%2h$&R
z9cLXcYC@Xwnns&bn)_Q~Te?roKGD|d-g^8;+aC{{G(1^(O7m37Y1-+6)01cN&y1aw
zoqc{T`P^XJqPBbIW6s}d4{z_f5Om?vMgNQEJG?v2T=KYd^0M3I6IZxbny)%vZR&LD
zJpPl@Psh8QyPB@KTx+@RdcC!KX7}kEo;S|j^u2lU7XQ}Oo;f|;z4Ll+_r>@1-xl3|
zawq-H%e&ckC+@AhPrP6BK<z=<L*0kfKU@CX*zeqbYQT4(^U>T#_XdT7&;F71j}Joy
zkC~6lh7E@6o;W@^IpRNZ{ptLtL(gQ-CY~4mqW;US7Zxvm_|@yz&e53Bp_lTPlfP|z
zrTyx_>lv@x#=^!PzR7qqF<$gm`|ZJZ+;<)Cqu&ot<a{81DF0~rvGr5Xr~8u`lav1h
z1DNytV>2z=0000WV@Og>004R=004l4008;_004mL004C`008P>0026e000+nl3&F}
z000i$Nkl<Zc-rindvILUeaFA&>_aPQS5I3O5|(6HAipq<u`zy8sELUSw9|k|0vRSL
zGwn=<N%~HkPBLz%%}ge3GVn*6P>5+srwop<3Bf6`amF?eQ~Vg)$WLThw*1g@_1M+k
z$2q@W|2XIF-W7%#uxvwe?KAi8)!n^!Kll6l{l33*CBe-2?egIl`C9}ZZHa!|4-i6p
ztoMKIUtXDB9xq=8l1qHSH#2iHDX#MrB{ewX`?`;ax;$6yQBZFTXU6{b)yE&|z0#m2
zMyB|<q54t4J^aL$isnSk??Le+h=^509A^eJF*FgBW@t_D6~WgGr3i`$zEAKx<#~)>
z_&NUZ$??5APd&5F`P75^%DVN5X*F#RMy2>O8ILbu0hA{qsI82nIu%1jGKOSn6p0dv
zXhg#EH8MGcp%E8-X$R-}b2xP&i@~&m@vIM@^&YMCcXp4-Utz<8`cnz++dq2iW-xs}
zQWE*BW}vaQ6pd38XqZ}x(vk?+UYr?r8w}#YeqzSRn2)2UM{)Rc1_zG}K@-8#{(p(+
z$Y1S!@=wlxn!t%~KK|O5;_=82rIdAbwIyh6OroVRnZF<d>Am1+!u}$N#Mpl<jkgZ<
z<KT%g=&0@$<KusLXv3p#e&WHcUHg2b_4c~Ih{j957mrKaFg=C#rX<P|(fox3fB+a!
z6BNb_FeWI`ZW9>kF%P@;58&5(dy&cbAf@g(zVVSQlMQY%?TBn%UjOGJn)qH>B8r>a
zD)E^ct4vsiz)(m*W>C?7W(Jc56@p1%fPt#=817wh9sXcN1E$s{02zIG#sfcHJ=w)#
zvJ@x2@%?QNmz0$~TU8Oqycrc}o1Q9!<|Tw>A<v=k8pZj~{?8xx=79lhdGkDa2gl)!
zXYc9$#jCFX8}uheagY6A`<G-i@vl-!%x+3y=JZsN!V2m#_Cx3QleHwF{UHSwsc-@`
zFyprQwOGA)8cGsTh*<1rO`luwBdq?*@=t`~9$vS3PIYC~QxO?mdP{pX7S5{9-?6j3
z8SFlA7AJc~pp=HM$gHhr12Y=xQ&_XI6^+x9=sZ1)|JijC$GS}QBnp9Nh7<y=)2r~n
z-R)><sIbxiHt#r#mv)?nKb{_vLjUq~I`cKWwQlrUR-B9=@rYJpX=8N)H?>t3@)t9<
zztxQs-D$X<564q*T$NwDo<i2~aint)&uuvjBF2VSj^faXet1g3w}6!$L<C=H9O)dy
zf4q3egsoNK>LvA<JF^OrM0pLfxWBP7wX<f`cjsKIy{dTV?=~%xGWJD+z=FBekTR6e
ziE-xq2s~fG^)y`1Li03S-wel7@H~YR-DwarI!~wJD-F*#>eQN`HJf3>nV50%^ayM=
z1i&awNZhsLI>bxMpeO>(`ldMI+w1T6r>_7I*BUsP^~LXNaP!=jB<iY4iqxi=;kXJp
zI~-40cs_DgagM9t`UVs+!}B#f&%9RJ!1I+h`A;*HG5{%WZ3<)F%u38}tpdq-LMtH{
zJdF_fx7s_uySe<1b@kT@II(o?qm?lk{ha4A+FMdZxrl6j3RGnvX?RM*^9jCh_W6q7
zdJ0NuFtN#j+VrlzDkw}7n{Z`7+prC%Ah!RO-#irr39W4|B~JLBxG&<z4^%Ashpz+c
z<kbczlc{AZ6w6y$8p}{q5ieB303I7CzE3vv3^b!Mvrk)9dCI)ksLKE|>O~%=*=N?8
zI1j5}Wq?^TlBlaL1u+Y&QU(}Oa2*i&=c*O*Ma=uww5tkEMH7oW&&SN^NpsKh&?s*`
zJViDXO`daH-vA8M<`a}Qp&0b3S`)}tUC&p>vS{;}z6yX+Axu%QEK&dq+H1f<hT@oD
z;89F#aZhC`zNcdGx-VZ1Z~{QgQTis5QB19lPYBb32Xj4TE2@U;n@Xv)&R0tF+Ds!c
z14KF>ssXGb52(pZIcYBHVVTGbCd_TC1d#|}2_aZ8o1aNR0s_}_3{O=q{m%2a^>1sh
zBsd8mN{F^f0Obj3zSKl`#Be>E)0Bo%WW$avG|IPJ!e%P1gN}lWOt6`=E0|>wsLa9&
zjv-B`uZcrQfdCdRG9>E~BECN*BD*RV|IJ-jQgKl&qYbeViFj0oltzU$GZxRUM_FkU
zzE2^Q832G)3o}}$R{;#%v7`xA6(x2*tjf$W#&<J>V6-(==Ya)^Bht{MQC1RxloF(g
z$@n6GHHy~+DM(7evmqiIlZ(IkLtt&`6;Yg@^(qMjAu$13L3t0ZnT@-awLl2u^AqP)
zCLo2toS9Sb=mYb?0KWS9`MB@S8xW01FcTsY2pSa$fv6Oi(^`v1@4v~ML+d;+vbix9
zAutPoH6*kM!{Un#K^2gZ$0`=je7*A4zg{$H&m1hchzkiXr$KBl)Y?(xdr2T7fmOFP
zW7TcVMNK-2whK!vDzRqe46Io>19_un?MA`36%<yONnxWvVrZ=)HGx3(9Dz|Td|vUH
z1td61Qq)PGR-oaJ598dE<C6hS0FX}39nJZPTGu1Qqp|=bbbUuo4r0^RV|eGpKwgCi
z&3;595;xAM!I$rwgVyO)IMO+Y7wqx*UNQ7#qf(-+r3w$-GaJnf6-B_zn&7w^N-HBU
zNy5B;;%5~WBF$hrqI!=#=A3<b4*=hON1hY|>^g4u(5ONtr=Xegp{heB_?b-yvF~ti
z-u)8=A!2fsCXFMV19*Dl0RX_WFTR6A$NNn#v(2awoPVuI<LJpjtbgGEh-{eJa5Z5|
z7#VXQ;sDqeU;=5y1zS=m5JbMO{ag=?o%u=T;E%uVoPGHMfKmXFi?wOd%LEQyuD@d>
zlUz77>L68CUOby%w@;o)BRrWB%&Z7uM)01_)58EWx_Z(Og_t+Tb4cez=5tS{O-^HD
zLnt4<gn{84pj`_{KuU<f%jFkMS#o<{bGx@cr?VFZtjeT4i<qn&#{h^j1BY{E*P~}(
z9MkI(#Vt?}lJ<)Ru*|h_{@R#qwG7Sl24AoMmdx?iw+VB4Xwo*n5wzBMU)Oyu3#olm
zO_+*un%2au-5yFG{;6|j#~uI<fGmJf02u%-0FC#i-^&NiJHLBhs_rxBI5CV{+A0x|
zC`#mEfR+uUBug-`7{+f25kTgAabadi87R&uOW2zsgzbkdFtP?%X+lTm5VUr*V2%KV
zn?WE=?(kmk%+`O`W9Kda$XQsUA#e@=HCc)y04jTK|Ap#>*|$4RL>H%5I;cs;-#Y=w
zWWr4V(yq1E5JFmKUwB|c)*c8UAiy>m8)F-&Oajobxm2k_g=GR0<9vS>U1x{EN{dj;
z1FXk%re}+D{Dq%cKp6ldAz(QG-utQTvVsFV$LsHSX{2uX;{HAdRb`R)K2i%Vo*BfZ
zz!`OE2mxp+_%zbCgRtRA5MXW8WkT8%9tabzfyx4C%#0)587L>qLa;PX(X`L**kS+7
z&Zqs+&TatX7S^y`XKi?@{N&yw`Z%^Haz{HhzFvR*;`6&YGS{`WBtcpihb!w)?h_Ln
zO|e5D(l#WyaDTWkS($%elkYlo-b^zXuFrU5-vub;XeJ$jR(<}^JI{JOJ9k?}Wv$8r
zXo1S;gMdv6I49Ga=Dt1ak0(}s>r9`6h8okiVnT5+iQWPefd~umB2s`ffk|7eh1?V*
z{X9fwNQnY8TL5++8p6=f5VKMm?#LTX*URg*GdL8=WdXEsE~6{i<Okp!0OM!hetJ8c
z{yi`3=!5T(oy0U_`N9TNrp#Pjkn@;~lB6)+N`TPPn1a>{D;74QG8wn3<Gkl99B)Fl
zxglk$s`ZY&Lmsxj-2<g^4vqKzGJE7dpU}==uLac)pcg=&eLZgN2Yr|?eYp%US(#^*
z<Baqj+Vo_9+Rbg-I}E|50BEi8g*CJA*=5a$MF3_EDGNXZ7!e8F*iwau@11RrZ^!E8
z&4@-AOd1gZ2y0jcObgf6RE4#7-)Mas!zaeiUmrkbsDD_EoY|B+{``8YuE7wn0RUt6
zX6s7{&B=T`7z2<3FcrYG8Nc&KcTJtW=G%9+mt(=KGAOP8-^YvL?eMQifD1W|?W3$9
zmm&1DpCGYq-!KlpJDBO(|LSw&oiF~}=C6sl%>S^!CUUxLorAp)$KJ`(t{p#lEgnfe
z{%gMd8<7%;xh*A7%Kw0dS6n0qgyDsMK_>*vm^^3}*tTyJr_Q_1g^rj0alCVDhXt0l
zW9*~kvdJtC6T>wFpaek4vF%U%>V~M`9kk+4N75da%qs;IRm%5&uwA6M0Af%Wg6eCx
zb3X9O{&A#-{aoLHjekFQWa}ZTt|1F;^n<#9YvD=02!(7dfGGf~X5aDEW%UczJT@&=
zTDf#y0@bAqU#Uxpj|mV9`xy)Yi8DhQZ+7J1xY<*kJD>T%xud(@wMrWbDb2l9n{lb3
zIvKxoBLT!i@M-~6*0n8bX<hQ*=PRZ({cd|xT+D5Wp+p8VB>aBNE<XJu1kzbxUzd-*
z0arWyM>p@;`qXAG-7{cwSpY5bVZ7PZ1{c69vG8i_r~o3#S+{>--gR^C{$fQ%MSD|y
z42{(hRHq~&?1yLY@-re30s;cWfUAN25#VGWVKA-WjP>q2xqHKZcfYg!U27|X>Y26%
z*Sj3~>`H=zoyUp;NCKz=P;KC$G+vr4pRwrPISsQ`uBw>YbZd+etx5qEWdbE}lXyjt
zGzrM&7^4|R#$&i1yV=36ojnJ)Y&&&eN0-)KxC=<zb@ropvug!hIBd(T`YJ8Fa;wN#
zWkY*a<BUa3Q(70yOIA#274fpEiA21HWh|kU$}o9j-uURbp>s#~4)=ARJ9~7;sqA21
z#)1h?1C502hPs^4t_HaL!yF5$+yYG5?NVDzqE?|7n>-8}RI*i3*<_!aFn2aSp+Uzd
z9bEpogjHXORbaVYm)iYdfFd-{9|q>zyftn|)&g`xp*bmkV|BIvKtxzDF$*gZc)k$4
zSV(znq4{>W7Mv5>R+rPCU8~?GDlmGH@j;3U4?UR*yOJ%}hn-Q;c6b(|3;~^(<0v%v
jO2L}c&fzz8`M&`G0d1;^!F55<00000NkvXXu0mjfP8Cu-

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-mdpi/icon.png b/packages/apps/CSLauncher/res/drawable-mdpi/icon.png
new file mode 100755
index 0000000000000000000000000000000000000000..a07c69fa5a0f4da5d5efe96eea12a543154dbab6
GIT binary patch
literal 2574
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

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-mdpi/pressed_application_background_static.png b/packages/apps/CSLauncher/res/drawable-mdpi/pressed_application_background_static.png
new file mode 100755
index 0000000000000000000000000000000000000000..b086a3f4b794a77fa8ee7e22e193d1989fd1d782
GIT binary patch
literal 4560
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

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable-mdpi/show_all_applications.png b/packages/apps/CSLauncher/res/drawable-mdpi/show_all_applications.png
new file mode 100755
index 0000000000000000000000000000000000000000..ed581e1b7009174d297605601cf12c178cdcfefe
GIT binary patch
literal 6700
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
C;h7Tv

literal 0
HcmV?d00001

diff --git a/packages/apps/CSLauncher/res/drawable/all_applications_background.xml b/packages/apps/CSLauncher/res/drawable/all_applications_background.xml
new file mode 100755
index 0000000..f6e13e6
--- /dev/null
+++ b/packages/apps/CSLauncher/res/drawable/all_applications_background.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* //device/apps/common/res/drawable/checkbox_background.xml
+**
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@drawable/all_applications_label_background" />
+</selector>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/drawable/all_applications_button_background.xml b/packages/apps/CSLauncher/res/drawable/all_applications_button_background.xml
new file mode 100755
index 0000000..01bb9d7
--- /dev/null
+++ b/packages/apps/CSLauncher/res/drawable/all_applications_button_background.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* //device/apps/common/res/drawable/checkbox.xml
+**
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_focused="true" android:state_pressed="true" android:drawable="@drawable/pressed_application_background_static" />
+    <item android:state_focused="false" android:state_pressed="true" android:drawable="@drawable/pressed_application_background_static" />
+    <item android:state_focused="true" android:drawable="@drawable/focused_application_background_static" />
+    <item android:state_focused="false" android:drawable="@drawable/application_background_static" />
+</selector>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/drawable/favorite_background.xml b/packages/apps/CSLauncher/res/drawable/favorite_background.xml
new file mode 100755
index 0000000..4413d57
--- /dev/null
+++ b/packages/apps/CSLauncher/res/drawable/favorite_background.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* //device/apps/common/res/drawable/checkbox.xml
+**
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_focused="true" android:state_pressed="true" android:drawable="@drawable/pressed_application_background_static" />
+    <item android:state_focused="false" android:state_pressed="true" android:drawable="@drawable/pressed_application_background_static" />
+    <item android:state_focused="true" android:drawable="@drawable/focused_application_background_static" />
+    <item android:state_focused="false" android:drawable="@android:color/transparent" />
+</selector>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/drawable/grid_selector.xml b/packages/apps/CSLauncher/res/drawable/grid_selector.xml
new file mode 100755
index 0000000..188316d
--- /dev/null
+++ b/packages/apps/CSLauncher/res/drawable/grid_selector.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+**
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_pressed="true" android:drawable="@drawable/pressed_application_background_static" />
+    <item android:state_window_focused="false" android:drawable="@drawable/focused_application_background_static" />
+    <item android:state_window_focused="true" android:drawable="@drawable/focused_application_background_static" />
+</selector>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/layout/all_applications_button.xml b/packages/apps/CSLauncher/res/layout/all_applications_button.xml
new file mode 100755
index 0000000..7df5ff9
--- /dev/null
+++ b/packages/apps/CSLauncher/res/layout/all_applications_button.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/show_all_apps"
+    android:layout_width="90dip"
+    android:layout_height="77dip"
+    android:orientation="vertical"
+    android:gravity="center_vertical"
+    android:clickable="true"
+    android:focusable="true"
+    android:background="@drawable/all_applications_button_background">
+
+</LinearLayout>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/layout/application.xml b/packages/apps/CSLauncher/res/layout/application.xml
new file mode 100755
index 0000000..8f9b9be
--- /dev/null
+++ b/packages/apps/CSLauncher/res/layout/application.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/label"
+    android:layout_width="90dip"
+    android:layout_height="77dip"
+    android:paddingTop="6dip"
+    android:textSize="12dip"
+    android:singleLine="true"
+    android:ellipsize="marquee"
+    android:textColor="@color/bright_text_dark_focused"
+    android:gravity="center_horizontal|center_vertical" />
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/layout/favorite.xml b/packages/apps/CSLauncher/res/layout/favorite.xml
new file mode 100755
index 0000000..fb09ad5
--- /dev/null
+++ b/packages/apps/CSLauncher/res/layout/favorite.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="78dip"
+    android:layout_height="65dip"
+    android:paddingTop="3dip"
+    android:paddingBottom="3dip"
+    android:clickable="true"
+    android:focusable="true"
+    android:background="@drawable/favorite_background"
+    android:textSize="12dip"
+    android:maxLines="1"
+    android:ellipsize="end"
+    android:textColor="@color/bright_text_dark_focused"
+    android:gravity="center_horizontal|bottom" />
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/layout/home.xml b/packages/apps/CSLauncher/res/layout/home.xml
new file mode 100755
index 0000000..7ce7ff5
--- /dev/null
+++ b/packages/apps/CSLauncher/res/layout/home.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:home="http://schemas.android.com/apk/res/com.onskreen.cornerstone.launcher"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:padding="2dip">
+
+<!-- android:background="@drawable/application_background"  -->
+    <!-- All applications on the top side of the screen -->
+    <GridView android:id="@+id/all_apps"
+        android:persistentDrawingCache="animation|scrolling"
+        android:alwaysDrawnWithCache="true"
+        android:scrollbars="none"
+        android:drawSelectorOnTop="false"
+        android:listSelector="@drawable/grid_selector"
+        android:numColumns="auto_fit"
+        android:columnWidth="90dp"
+        android:stretchMode="spacingWidth"
+        android:layout_weight="1.0"
+        android:layout_height="0dip"
+        android:layout_width="match_parent"
+        android:visibility="invisible" />
+		<!-- android:stackFromBottom="true" -->
+
+    <!-- Favorites and Recents -->
+    <!--<com.onskreen.cornerstone.launcher.ApplicationsStackLayout android:id="@+id/faves_and_recents"
+        home:stackOrientation="horizontal"
+        home:marginLeft="1dip"
+        home:marginRight="1dip"
+        android:layout_marginTop="0dip"
+        android:layout_width="match_parent"
+        android:layout_height="77dip"
+        android:background="@drawable/application_background" /> -->
+
+</LinearLayout>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/values/attrs.xml b/packages/apps/CSLauncher/res/values/attrs.xml
new file mode 100755
index 0000000..cb5025d
--- /dev/null
+++ b/packages/apps/CSLauncher/res/values/attrs.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<resources>
+    <declare-styleable name="ApplicationsStackLayout">
+        <attr name="stackOrientation">
+            <enum name="horizontal" value="0" />
+            <enum name="vertical" value="1" />
+        </attr>
+        <attr name="marginLeft" format="dimension"  />
+        <attr name="marginTop" format="dimension"  />
+        <attr name="marginRight" format="dimension"  />
+        <attr name="marginBottom" format="dimension"  />
+    </declare-styleable>
+</resources>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/values/strings.xml b/packages/apps/CSLauncher/res/values/strings.xml
new file mode 100755
index 0000000..397f90e
--- /dev/null
+++ b/packages/apps/CSLauncher/res/values/strings.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources>
+    <!-- Home -->
+    <string name="home_title">Home Sample</string>
+    <string name="show_all_apps">All</string>
+
+    <!-- Home Menus -->
+    <string name="menu_wallpaper">Wallpaper</string>
+    <string name="menu_search">Search</string>
+    <string name="menu_settings">Settings</string>
+	<string name="app_name">Select Application</string>
+    <!-- Wallpaper -->
+    <string name="wallpaper_instructions">Tap picture to set portrait wallpaper</string>
+</resources>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/res/values/styles.xml b/packages/apps/CSLauncher/res/values/styles.xml
new file mode 100755
index 0000000..07df306
--- /dev/null
+++ b/packages/apps/CSLauncher/res/values/styles.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<resources>
+    <style name="Theme" parent="android:Theme">
+        <item name="android:windowNoTitle">true</item>
+    </style>
+</resources>
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/src/com/onskreen/cornerstone/launcher/ApplicationInfo.java b/packages/apps/CSLauncher/src/com/onskreen/cornerstone/launcher/ApplicationInfo.java
new file mode 100755
index 0000000..46fed21
--- /dev/null
+++ b/packages/apps/CSLauncher/src/com/onskreen/cornerstone/launcher/ApplicationInfo.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.onskreen.cornerstone.launcher;
+
+import android.content.ComponentName;
+import android.content.Intent;
+import android.graphics.drawable.Drawable;
+
+/**
+ * Represents a launchable application. An application is made of a name (or title), an intent
+ * and an icon.
+ */
+class ApplicationInfo {
+    /**
+     * The application name.
+     */
+    CharSequence title;
+
+    /**
+     * The intent used to start the application.
+     */
+    Intent intent;
+
+    /**
+     * The application icon.
+     */
+    Drawable icon;
+
+    /**
+     * When set to true, indicates that the icon has been resized.
+     */
+    boolean filtered;
+
+    /**
+     * Creates the application intent based on a component name and various launch flags.
+     *
+     * @param className the class name of the component representing the intent
+     * @param launchFlags the launch flags
+     */
+    final void setActivity(ComponentName className, int launchFlags) {
+        intent = new Intent(Intent.ACTION_MAIN);
+        intent.addCategory(Intent.CATEGORY_LAUNCHER);
+        intent.setComponent(className);
+        intent.setFlags(launchFlags);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof ApplicationInfo)) {
+            return false;
+        }
+
+        ApplicationInfo that = (ApplicationInfo) o;
+        return title.equals(that.title) &&
+                intent.getComponent().getClassName().equals(
+                        that.intent.getComponent().getClassName());
+    }
+
+    @Override
+    public int hashCode() {
+        int result;
+        result = (title != null ? title.hashCode() : 0);
+        final String name = intent.getComponent().getClassName();
+        result = 31 * result + (name != null ? name.hashCode() : 0);
+        return result;
+    }
+}
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/src/com/onskreen/cornerstone/launcher/ApplicationsStackLayout.java b/packages/apps/CSLauncher/src/com/onskreen/cornerstone/launcher/ApplicationsStackLayout.java
new file mode 100755
index 0000000..5087d93
--- /dev/null
+++ b/packages/apps/CSLauncher/src/com/onskreen/cornerstone/launcher/ApplicationsStackLayout.java
@@ -0,0 +1,339 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.onskreen.cornerstone.launcher;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.LayoutInflater;
+import android.widget.TextView;
+
+import java.util.List;
+
+/**
+ * The ApplicationsStackLayout is a specialized layout used for the purpose of the home screen
+ * only. This layout stacks various icons in three distinct areas: the recents, the favorites
+ * (or faves) and the button.
+ *
+ * This layout supports two different orientations: vertical and horizontal. When horizontal,
+ * the areas are laid out this way:
+ *
+ * [RECENTS][FAVES][BUTTON]
+ *
+ * When vertical, the layout is the following:
+ *
+ * [RECENTS]
+ * [FAVES]
+ * [BUTTON]
+ *
+ * The layout operates from the "bottom up" (or from right to left.) This means that the button
+ * area will first be laid out, then the faves area, then the recents. When there are too many
+ * favorites, the recents area is not displayed.
+ *
+ * The following attributes can be set in XML:
+ *
+ * orientation: horizontal or vertical
+ * marginLeft: the left margin of each element in the stack
+ * marginTop: the top margin of each element in the stack
+ * marginRight: the right margin of each element in the stack
+ * marginBottom: the bottom margin of each element in the stack
+ */
+public class ApplicationsStackLayout extends ViewGroup implements View.OnClickListener {
+    public static final int HORIZONTAL = 0;
+    public static final int VERTICAL = 1;
+
+    private View mButton;
+    private LayoutInflater mInflater;
+
+    private int mFavoritesEnd;
+    private int mFavoritesStart;
+
+    private List<ApplicationInfo> mFavorites;
+    private List<ApplicationInfo> mRecents;
+
+    private int mOrientation = VERTICAL;
+
+    private int mMarginLeft;
+    private int mMarginTop;
+    private int mMarginRight;
+    private int mMarginBottom;
+
+    private Rect mDrawRect = new Rect();
+
+    private Drawable mBackground;
+    private int mIconSize;
+
+    public ApplicationsStackLayout(Context context) {
+        super(context);
+        initLayout();
+    }
+
+    public ApplicationsStackLayout(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        TypedArray a =
+                context.obtainStyledAttributes(attrs, R.styleable.ApplicationsStackLayout);
+
+        mOrientation = a.getInt(R.styleable.ApplicationsStackLayout_stackOrientation, VERTICAL);
+
+        mMarginLeft = a.getDimensionPixelSize(R.styleable.ApplicationsStackLayout_marginLeft, 0);
+        mMarginTop = a.getDimensionPixelSize(R.styleable.ApplicationsStackLayout_marginTop, 0);
+        mMarginRight = a.getDimensionPixelSize(R.styleable.ApplicationsStackLayout_marginRight, 0);
+        mMarginBottom = a.getDimensionPixelSize(R.styleable.ApplicationsStackLayout_marginBottom, 0);
+
+        a.recycle();
+
+        mIconSize = 42; //(int) getResources().getDimension(android.R.dimen.app_icon_size);
+
+        initLayout();
+    }
+
+    private void initLayout() {
+        mInflater = LayoutInflater.from(getContext());
+        mButton = mInflater.inflate(R.layout.all_applications_button, this, false);
+        addView(mButton);
+
+        mBackground = getBackground();
+        setBackgroundDrawable(null);
+        setWillNotDraw(false);
+    }
+
+    /**
+     * Return the current orientation, either VERTICAL (default) or HORIZONTAL.
+     *
+     * @return the stack orientation
+     */
+    public int getOrientation() {
+        return mOrientation;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        final Drawable background = mBackground;
+
+        final int right = getWidth();
+        final int bottom = getHeight();
+
+        // Draw behind recents
+        if (mOrientation == VERTICAL) {
+            mDrawRect.set(0, 0, right, mFavoritesStart);
+        } else {
+            mDrawRect.set(0, 0, mFavoritesStart, bottom);
+        }
+        background.setBounds(mDrawRect);
+        background.draw(canvas);
+
+        // Draw behind favorites
+        if (mFavoritesStart > -1) {
+            if (mOrientation == VERTICAL) {
+                mDrawRect.set(0, mFavoritesStart, right, mFavoritesEnd);
+            } else {
+                mDrawRect.set(mFavoritesStart, 0, mFavoritesEnd, bottom);
+            }
+            background.setBounds(mDrawRect);
+            background.draw(canvas);
+        }
+
+        super.onDraw(canvas);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+        final int widthSize = MeasureSpec.getSize(widthMeasureSpec);
+
+        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+        final int heightSize = MeasureSpec.getSize(heightMeasureSpec);
+
+        if (widthMode != MeasureSpec.EXACTLY || heightMode != MeasureSpec.EXACTLY) {
+            throw new IllegalStateException("ApplicationsStackLayout can only be used with "
+                    + "measure spec mode=EXACTLY");
+        }
+
+        setMeasuredDimension(widthSize, heightSize);
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        removeAllApplications();
+
+        LayoutParams layoutParams = mButton.getLayoutParams();
+        final int widthSpec = MeasureSpec.makeMeasureSpec(layoutParams.width, MeasureSpec.EXACTLY);
+        final int heightSpec = MeasureSpec.makeMeasureSpec(layoutParams.height, MeasureSpec.EXACTLY);
+        mButton.measure(widthSpec, heightSpec);
+
+        if (mOrientation == VERTICAL) {
+            layoutVertical();
+        } else {
+            layoutHorizontal();
+        }
+    }
+
+    private void layoutVertical() {
+        int childLeft = 0;
+        int childTop = getHeight();
+
+        int childWidth = mButton.getMeasuredWidth();
+        int childHeight = mButton.getMeasuredHeight();
+
+        childTop -= childHeight + mMarginBottom;
+        mButton.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight);
+        childTop -= mMarginTop;
+        mFavoritesEnd = childTop - mMarginBottom;
+
+        int oldChildTop = childTop;
+        //childTop = stackApplications(mFavorites, childLeft, childTop);
+        if (childTop != oldChildTop) {
+            mFavoritesStart = childTop + mMarginTop;
+        } else {
+            mFavoritesStart = -1;
+        }
+
+        stackApplications(mRecents, childLeft, childTop);
+    }
+
+    private void layoutHorizontal() {
+        int childLeft = getWidth();
+        int childTop = 0;
+
+        int childWidth = mButton.getMeasuredWidth();
+        int childHeight = mButton.getMeasuredHeight();
+
+        //childLeft -= childWidth;
+        //mButton.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight);
+        childLeft -= mMarginLeft;
+        mFavoritesEnd = childLeft - mMarginRight;
+
+        int oldChildLeft = childLeft;
+        //childLeft = stackApplications(mFavorites, childLeft, childTop);
+        if (childLeft != oldChildLeft) {
+            mFavoritesStart = childLeft + mMarginLeft;
+        } else {
+            mFavoritesStart = -1;
+        }
+        stackApplications(mRecents, childLeft, childTop);
+    }
+
+    private int stackApplications(List<ApplicationInfo> applications, int childLeft, int childTop) {
+        LayoutParams layoutParams;
+        int widthSpec;
+        int heightSpec;
+        int childWidth;
+        int childHeight;
+
+        final boolean isVertical = mOrientation == VERTICAL;
+
+        final int count = applications.size();
+        for (int i = count - 1; i >= 0; i--) {
+            final ApplicationInfo info = applications.get(i);
+            final View view = createApplicationIcon(mInflater, this, info);
+
+            layoutParams = view.getLayoutParams();
+            widthSpec = MeasureSpec.makeMeasureSpec(layoutParams.width, MeasureSpec.EXACTLY);
+            heightSpec = MeasureSpec.makeMeasureSpec(layoutParams.height, MeasureSpec.EXACTLY);
+            view.measure(widthSpec, heightSpec);
+
+            childWidth = view.getMeasuredWidth();
+            childHeight = view.getMeasuredHeight();
+
+            if (isVertical) {
+                childTop -= childHeight + mMarginBottom;
+
+                if (childTop < 0) {
+                    childTop += childHeight + mMarginBottom;
+                    break;
+                }
+            } else {
+                childLeft -= childWidth + mMarginRight;
+
+                if (childLeft < 0) {
+                    childLeft += childWidth + mMarginRight;
+                    break;
+                }
+            }
+
+            addViewInLayout(view, -1, layoutParams);
+
+            view.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight);
+
+            if (isVertical) {
+                childTop -= mMarginTop;
+            } else {
+                childLeft -= mMarginLeft;
+            }
+        }
+
+        return isVertical ? childTop : childLeft;
+    }
+
+    private void removeAllApplications() {
+        final int count = getChildCount();
+        for (int i = count - 1; i >= 0; i--) {
+            final View view = getChildAt(i);
+            if (view != mButton) {
+                removeViewAt(i);
+            }
+        }
+    }
+
+    private View createApplicationIcon(LayoutInflater inflater,
+            ViewGroup group, ApplicationInfo info) {
+
+        TextView textView = (TextView) inflater.inflate(R.layout.favorite, group, false);
+
+        info.icon.setBounds(0, 0, mIconSize, mIconSize);
+        textView.setCompoundDrawables(null, info.icon, null, null);
+        textView.setText(info.title);
+
+        textView.setTag(info.intent);
+        textView.setOnClickListener(this);
+
+        return textView;
+    }
+
+    /**
+     * Sets the list of favorites.
+     *
+     * @param applications the applications to put in the favorites area
+     */
+    public void setFavorites(List<ApplicationInfo> applications) {
+        mFavorites = applications;
+        requestLayout();
+    }
+
+    /**
+     * Sets the list of recents.
+     *
+     * @param applications the applications to put in the recents area
+     */
+    public void setRecents(List<ApplicationInfo> applications) {
+        mRecents = applications;
+        requestLayout();
+    }
+
+    public void onClick(View v) {
+        getContext().startActivity((Intent) v.getTag());
+    }
+}
\ No newline at end of file
diff --git a/packages/apps/CSLauncher/src/com/onskreen/cornerstone/launcher/CSLauncher.java b/packages/apps/CSLauncher/src/com/onskreen/cornerstone/launcher/CSLauncher.java
new file mode 100755
index 0000000..25d2353
--- /dev/null
+++ b/packages/apps/CSLauncher/src/com/onskreen/cornerstone/launcher/CSLauncher.java
@@ -0,0 +1,801 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.onskreen.cornerstone.launcher;
+
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.ActivityManagerNative;
+import android.app.SearchManager;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.PaintFlagsDrawFilter;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.ColorFilter;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.PaintDrawable;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.RemoteException;
+import android.util.Log;
+import android.util.Xml;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.view.animation.LayoutAnimationController;
+import android.widget.AdapterView;
+import android.widget.ArrayAdapter;
+import android.widget.CheckBox;
+import android.widget.GridView;
+import android.widget.TextView;
+
+import java.io.IOException;
+import java.io.FileReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+public class CSLauncher extends Activity {
+    /**
+     * Tag used for logging errors.
+     */
+    private static final String LOG_TAG = "Home";
+
+    /**
+     * Keys during freeze/thaw.
+     */
+    private static final String KEY_SAVE_GRID_OPENED = "grid.opened";
+
+    private static final String DEFAULT_FAVORITES_PATH = "etc/favorites.xml";
+
+    private static final String TAG_FAVORITES = "favorites";
+    private static final String TAG_FAVORITE = "favorite";
+    private static final String TAG_PACKAGE = "package";
+    private static final String TAG_CLASS = "class";
+
+    // Identifiers for option menu items
+    private static final int MENU_WALLPAPER_SETTINGS = Menu.FIRST + 1;
+    private static final int MENU_SEARCH = MENU_WALLPAPER_SETTINGS + 1;
+    private static final int MENU_SETTINGS = MENU_SEARCH + 1;
+
+    /**
+     * Maximum number of recent tasks to query.
+     */
+    private static final int MAX_RECENT_TASKS = 20;
+
+    private static boolean mWallpaperChecked;
+    private static ArrayList<ApplicationInfo> mApplications;
+    private static LinkedList<ApplicationInfo> mFavorites;
+
+    private final BroadcastReceiver mWallpaperReceiver = new WallpaperIntentReceiver();
+    private final BroadcastReceiver mApplicationsReceiver = new ApplicationsIntentReceiver();
+
+    private GridView mGrid;
+
+    private LayoutAnimationController mShowLayoutAnimation;
+    private LayoutAnimationController mHideLayoutAnimation;
+
+    private boolean mBlockAnimation;
+
+    private boolean mHomeDown;
+    private boolean mBackDown;
+
+    private View mShowApplications;
+    private CheckBox mShowApplicationsCheck;
+
+    //private ApplicationsStackLayout mApplicationsStack;
+
+    private Animation mGridEntry;
+    private Animation mGridExit;
+
+    @Override
+    public void onCreate(Bundle icicle) {
+        super.onCreate(icicle);
+
+        setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);
+
+        setContentView(R.layout.home);
+
+        registerIntentReceivers();
+
+        //setDefaultWallpaper();
+
+        loadApplications(true);
+
+        bindApplications();
+        //bindFavorites(true);
+        //bindRecents();
+        bindButtons();
+
+        mGridEntry = AnimationUtils.loadAnimation(this, R.anim.grid_entry);
+        mGridExit = AnimationUtils.loadAnimation(this, R.anim.grid_exit);
+
+        showApplications(true);
+    }
+
+    @Override
+    protected void onNewIntent(Intent intent) {
+        super.onNewIntent(intent);
+
+        // Close the menu
+        if (Intent.ACTION_MAIN.equals(intent.getAction())) {
+            getWindow().closeAllPanels();
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+
+        // Remove the callback for the cached drawables or we leak
+        // the previous Home screen on orientation change
+        final int count = mApplications.size();
+        for (int i = 0; i < count; i++) {
+            mApplications.get(i).icon.setCallback(null);
+        }
+
+        unregisterReceiver(mWallpaperReceiver);
+        unregisterReceiver(mApplicationsReceiver);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        //bindRecents();
+    }
+
+    @Override
+    protected void onRestoreInstanceState(Bundle state) {
+        super.onRestoreInstanceState(state);
+        final boolean opened = state.getBoolean(KEY_SAVE_GRID_OPENED, false);
+        if (opened) {
+            showApplications(false);
+        }
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putBoolean(KEY_SAVE_GRID_OPENED, mGrid.getVisibility() == View.VISIBLE);
+    }
+
+    /**
+     * Registers various intent receivers. The current implementation registers
+     * only a wallpaper intent receiver to let other applications change the
+     * wallpaper.
+     */
+    private void registerIntentReceivers() {
+        IntentFilter filter = new IntentFilter(Intent.ACTION_WALLPAPER_CHANGED);
+        registerReceiver(mWallpaperReceiver, filter);
+
+        filter = new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
+        filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
+        filter.addAction(Intent.ACTION_PACKAGE_CHANGED);
+        filter.addDataScheme("package");
+        registerReceiver(mApplicationsReceiver, filter);
+    }
+
+    /**
+     * Creates a new appplications adapter for the grid view and registers it.
+     */
+    private void bindApplications() {
+        if (mGrid == null) {
+            mGrid = (GridView) findViewById(R.id.all_apps);
+        }
+        mGrid.setAdapter(new ApplicationsAdapter(this, mApplications));
+        mGrid.setSelection(0);
+
+        /*if (mApplicationsStack == null) {
+            mApplicationsStack = (ApplicationsStackLayout) findViewById(R.id.faves_and_recents);
+        }*/
+    }
+
+    /**
+     * Binds actions to the various buttons.
+     */
+    private void bindButtons() {
+        mShowApplications = findViewById(R.id.show_all_apps);
+        //mShowApplications.setOnClickListener(new ShowApplications());
+        //mShowApplicationsCheck = (CheckBox) findViewById(R.id.show_all_apps_check);
+
+        mGrid.setOnItemClickListener(new ApplicationLauncher());
+    }
+
+    /**
+     * When no wallpaper was manually set, a default wallpaper is used instead.
+     */
+    private void setDefaultWallpaper() {
+        if (!mWallpaperChecked) {
+            Drawable wallpaper = peekWallpaper();
+            if (wallpaper == null) {
+                try {
+                    clearWallpaper();
+                } catch (IOException e) {
+                    Log.e(LOG_TAG, "Failed to clear wallpaper " + e);
+                }
+            } else {
+                getWindow().setBackgroundDrawable(new ClippedDrawable(wallpaper));
+            }
+            mWallpaperChecked = true;
+        }
+    }
+
+    /**
+     * Refreshes the favorite applications stacked over the all apps button.
+     * The number of favorites depends on the user.
+     */
+    /*private void bindFavorites(boolean isLaunching) {
+        if (!isLaunching || mFavorites == null) {
+
+            if (mFavorites == null) {
+                mFavorites = new LinkedList<ApplicationInfo>();
+            } else {
+                mFavorites.clear();
+            }
+            mApplicationsStack.setFavorites(mFavorites);
+
+            FileReader favReader;
+
+            // Environment.getRootDirectory() is a fancy way of saying ANDROID_ROOT or "/system".
+            final File favFile = new File(Environment.getRootDirectory(), DEFAULT_FAVORITES_PATH);
+            try {
+                favReader = new FileReader(favFile);
+            } catch (FileNotFoundException e) {
+                Log.e(LOG_TAG, "Couldn't find or open favorites file " + favFile);
+                return;
+            }
+
+            final Intent intent = new Intent(Intent.ACTION_MAIN, null);
+            intent.addCategory(Intent.CATEGORY_LAUNCHER);
+
+            final PackageManager packageManager = getPackageManager();
+
+            try {
+                final XmlPullParser parser = Xml.newPullParser();
+                parser.setInput(favReader);
+
+                beginDocument(parser, TAG_FAVORITES);
+
+                ApplicationInfo info;
+
+                while (true) {
+                    nextElement(parser);
+
+                    String name = parser.getName();
+                    if (!TAG_FAVORITE.equals(name)) {
+                        break;
+                    }
+
+                    final String favoritePackage = parser.getAttributeValue(null, TAG_PACKAGE);
+                    final String favoriteClass = parser.getAttributeValue(null, TAG_CLASS);
+
+                    final ComponentName cn = new ComponentName(favoritePackage, favoriteClass);
+                    intent.setComponent(cn);
+                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+                    info = getApplicationInfo(packageManager, intent);
+                    if (info != null) {
+                        info.intent = intent;
+                        mFavorites.addFirst(info);
+                    }
+                }
+            } catch (XmlPullParserException e) {
+                Log.w(LOG_TAG, "Got exception parsing favorites.", e);
+            } catch (IOException e) {
+                Log.w(LOG_TAG, "Got exception parsing favorites.", e);
+            }
+        }
+
+        mApplicationsStack.setFavorites(mFavorites);
+    }*/
+
+    private static void beginDocument(XmlPullParser parser, String firstElementName)
+            throws XmlPullParserException, IOException {
+
+        int type;
+        while ((type = parser.next()) != XmlPullParser.START_TAG &&
+                type != XmlPullParser.END_DOCUMENT) {
+            // Empty
+        }
+
+        if (type != XmlPullParser.START_TAG) {
+            throw new XmlPullParserException("No start tag found");
+        }
+
+        if (!parser.getName().equals(firstElementName)) {
+            throw new XmlPullParserException("Unexpected start tag: found " + parser.getName() +
+                    ", expected " + firstElementName);
+        }
+    }
+
+    private static void nextElement(XmlPullParser parser) throws XmlPullParserException, IOException {
+        int type;
+        while ((type = parser.next()) != XmlPullParser.START_TAG &&
+                type != XmlPullParser.END_DOCUMENT) {
+            // Empty
+        }
+    }
+
+    /**
+     * Refreshes the recently launched applications stacked over the favorites. The number
+     * of recents depends on how many favorites are present.
+     */
+   /* private void bindRecents() {
+        final PackageManager manager = getPackageManager();
+        final ActivityManager tasksManager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
+        final List<ActivityManager.RecentTaskInfo> recentTasks = tasksManager.getRecentTasks(
+                MAX_RECENT_TASKS, 0);
+
+        final int count = recentTasks.size();
+        final ArrayList<ApplicationInfo> recents = new ArrayList<ApplicationInfo>();
+
+        for (int i = count - 1; i >= 0; i--) {
+            final Intent intent = recentTasks.get(i).baseIntent;
+
+            if (Intent.ACTION_MAIN.equals(intent.getAction()) &&
+                    !intent.hasCategory(Intent.CATEGORY_HOME)) {
+
+                ApplicationInfo info = getApplicationInfo(manager, intent);
+                if (info != null) {
+                    info.intent = intent;
+                    //if (!mFavorites.contains(info)) {
+                        recents.add(info);
+                    //}
+                }
+            }
+        }
+
+        mApplicationsStack.setRecents(recents);
+    }*/
+
+    private static ApplicationInfo getApplicationInfo(PackageManager manager, Intent intent) {
+        final ResolveInfo resolveInfo = manager.resolveActivity(intent, 0);
+
+        if (resolveInfo == null) {
+            return null;
+        }
+
+        final ApplicationInfo info = new ApplicationInfo();
+        final ActivityInfo activityInfo = resolveInfo.activityInfo;
+        info.icon = activityInfo.loadIcon(manager);
+        if (info.title == null || info.title.length() == 0) {
+            info.title = activityInfo.loadLabel(manager);
+        }
+        if (info.title == null) {
+            info.title = "";
+        }
+        return info;
+    }
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+        if (!hasFocus) {
+            mBackDown = mHomeDown = false;
+        }
+    }
+
+    /*@Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            switch (event.getKeyCode()) {
+                case KeyEvent.KEYCODE_BACK:
+                    mBackDown = true;
+                    //return true;
+                case KeyEvent.KEYCODE_HOME:
+                    mHomeDown = true;
+                    return true;
+            }
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+            switch (event.getKeyCode()) {
+                case KeyEvent.KEYCODE_BACK:
+                    if (!event.isCanceled()) {
+                        // Do BACK behavior.
+                    }
+                    mBackDown = true;
+                    //return true;
+                case KeyEvent.KEYCODE_HOME:
+                    if (!event.isCanceled()) {
+                        // Do HOME behavior.
+                    }
+                    mHomeDown = true;
+                    return true;
+            }
+        }
+
+        return super.dispatchKeyEvent(event);
+    }*/
+
+    /*@Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        super.onCreateOptionsMenu(menu);
+
+        menu.add(0, MENU_WALLPAPER_SETTINGS, 0, R.string.menu_wallpaper)
+                 .setIcon(android.R.drawable.ic_menu_gallery)
+                 .setAlphabeticShortcut('W');
+        menu.add(0, MENU_SEARCH, 0, R.string.menu_search)
+                .setIcon(android.R.drawable.ic_search_category_default)
+                .setAlphabeticShortcut(SearchManager.MENU_KEY);
+        menu.add(0, MENU_SETTINGS, 0, R.string.menu_settings)
+                .setIcon(android.R.drawable.ic_menu_preferences)
+                .setIntent(new Intent(android.provider.Settings.ACTION_SETTINGS));
+
+        return true;
+    }*/
+
+    /*@Override
+    /*public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case MENU_WALLPAPER_SETTINGS:
+                startWallpaper();
+                return true;
+            case MENU_SEARCH:
+                onSearchRequested();
+                return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+
+    private void startWallpaper() {
+        final Intent pickWallpaper = new Intent(Intent.ACTION_SET_WALLPAPER);
+        startActivity(Intent.createChooser(pickWallpaper, getString(R.string.menu_wallpaper)));
+    }*/
+
+    /**
+     * Loads the list of installed applications in mApplications.
+     */
+    private void loadApplications(boolean isLaunching) {
+        if (isLaunching && mApplications != null) {
+            return;
+        }
+
+        PackageManager manager = getPackageManager();
+
+        Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
+        mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+
+        final List<ResolveInfo> apps = manager.queryIntentActivities(mainIntent, 0);
+        Collections.sort(apps, new ResolveInfo.DisplayNameComparator(manager));
+
+        if (apps != null) {
+            final int count = apps.size();
+
+            if (mApplications == null) {
+                mApplications = new ArrayList<ApplicationInfo>(count);
+            }
+            mApplications.clear();
+
+            for (int i = 0; i < count; i++) {
+                ApplicationInfo application = new ApplicationInfo();
+                ResolveInfo info = apps.get(i);
+
+                application.title = info.loadLabel(manager);
+                application.setActivity(new ComponentName(
+                        info.activityInfo.applicationInfo.packageName,
+                        info.activityInfo.name),
+                        Intent.FLAG_ACTIVITY_NEW_TASK
+                        | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
+                application.icon = info.activityInfo.loadIcon(manager);
+
+                mApplications.add(application);
+            }
+        }
+    }
+
+    /**
+     * Shows all of the applications by playing an animation on the grid.
+     */
+    private void showApplications(boolean animate) {
+        if (mBlockAnimation) {
+            return;
+        }
+        mBlockAnimation = true;
+
+        //mShowApplicationsCheck.toggle();
+
+        if (mShowLayoutAnimation == null) {
+            mShowLayoutAnimation = AnimationUtils.loadLayoutAnimation(
+                    this, R.anim.show_applications);
+        }
+
+        // This enables a layout animation; if you uncomment this code, you need to
+        // comment the line mGrid.startAnimation() below
+//        mGrid.setLayoutAnimationListener(new ShowGrid());
+//        mGrid.setLayoutAnimation(mShowLayoutAnimation);
+//        mGrid.startLayoutAnimation();
+
+        if (animate) {
+            mGridEntry.setAnimationListener(new ShowGrid());
+            mGrid.startAnimation(mGridEntry);
+        }
+
+        mGrid.setVisibility(View.VISIBLE);
+
+        if (!animate) {
+            mBlockAnimation = false;
+        }
+
+        // ViewDebug.startHierarchyTracing("Home", mGrid);
+    }
+
+    /**
+     * Hides all of the applications by playing an animation on the grid.
+     */
+    private void hideApplications() {
+        if (mBlockAnimation) {
+            return;
+        }
+        mBlockAnimation = true;
+
+        //mShowApplicationsCheck.toggle();
+
+        if (mHideLayoutAnimation == null) {
+            mHideLayoutAnimation = AnimationUtils.loadLayoutAnimation(
+                    this, R.anim.hide_applications);
+        }
+
+        mGridExit.setAnimationListener(new HideGrid());
+        mGrid.startAnimation(mGridExit);
+        mGrid.setVisibility(View.INVISIBLE);
+        mShowApplications.requestFocus();
+
+        // This enables a layout animation; if you uncomment this code, you need to
+        // comment the line mGrid.startAnimation() above
+//        mGrid.setLayoutAnimationListener(new HideGrid());
+//        mGrid.setLayoutAnimation(mHideLayoutAnimation);
+//        mGrid.startLayoutAnimation();
+    }
+
+    /**
+     * Receives intents from other applications to change the wallpaper.
+     */
+    private class WallpaperIntentReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            getWindow().setBackgroundDrawable(new ClippedDrawable(getWallpaper()));
+        }
+    }
+
+    /**
+     * Receives notifications when applications are added/removed.
+     */
+    private class ApplicationsIntentReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            loadApplications(false);
+            bindApplications();
+            //bindRecents();
+            //bindFavorites(false);
+        }
+    }
+
+    /**
+     * GridView adapter to show the list of all installed applications.
+     */
+    private class ApplicationsAdapter extends ArrayAdapter<ApplicationInfo> {
+        private Rect mOldBounds = new Rect();
+
+        public ApplicationsAdapter(Context context, ArrayList<ApplicationInfo> apps) {
+            super(context, 0, apps);
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            final ApplicationInfo info = mApplications.get(position);
+
+            if (convertView == null) {
+                final LayoutInflater inflater = getLayoutInflater();
+                convertView = inflater.inflate(R.layout.application, parent, false);
+            }
+
+            Drawable icon = info.icon;
+
+            if (!info.filtered) {
+                //final Resources resources = getContext().getResources();
+                int width = 48;//(int) resources.getDimension(android.R.dimen.app_icon_size);
+                int height = 48;//(int) resources.getDimension(android.R.dimen.app_icon_size);
+
+                final int iconWidth = icon.getIntrinsicWidth();
+                final int iconHeight = icon.getIntrinsicHeight();
+
+                if (icon instanceof PaintDrawable) {
+                    PaintDrawable painter = (PaintDrawable) icon;
+                    painter.setIntrinsicWidth(width);
+                    painter.setIntrinsicHeight(height);
+                }
+
+                if (width > 0 && height > 0 && (width < iconWidth || height < iconHeight)) {
+                    final float ratio = (float) iconWidth / iconHeight;
+
+                    if (iconWidth > iconHeight) {
+                        height = (int) (width / ratio);
+                    } else if (iconHeight > iconWidth) {
+                        width = (int) (height * ratio);
+                    }
+
+                    final Bitmap.Config c =
+                            icon.getOpacity() != PixelFormat.OPAQUE ?
+                                Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+                    final Bitmap thumb = Bitmap.createBitmap(width, height, c);
+                    final Canvas canvas = new Canvas(thumb);
+                    canvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG, 0));
+                    // Copy the old bounds to restore them later
+                    // If we were to do oldBounds = icon.getBounds(),
+                    // the call to setBounds() that follows would
+                    // change the same instance and we would lose the
+                    // old bounds
+                    mOldBounds.set(icon.getBounds());
+                    icon.setBounds(0, 0, width, height);
+                    icon.draw(canvas);
+                    icon.setBounds(mOldBounds);
+                    icon = info.icon = new BitmapDrawable(thumb);
+                    info.filtered = true;
+                }
+            }
+
+            final TextView textView = (TextView) convertView.findViewById(R.id.label);
+            textView.setCompoundDrawablesWithIntrinsicBounds(null, icon, null, null);
+            textView.setText(info.title);
+
+            return convertView;
+        }
+    }
+
+    /**
+     * Shows and hides the applications grid view.
+     */
+    private class ShowApplications implements View.OnClickListener {
+        public void onClick(View v) {
+            if (mGrid.getVisibility() != View.VISIBLE) {
+                showApplications(true);
+            } else {
+                hideApplications();
+            }
+        }
+    }
+
+    /**
+     * Hides the applications grid when the layout animation is over.
+     */
+    private class HideGrid implements Animation.AnimationListener {
+        public void onAnimationStart(Animation animation) {
+        }
+
+        public void onAnimationEnd(Animation animation) {
+            mBlockAnimation = false;
+        }
+
+        public void onAnimationRepeat(Animation animation) {
+        }
+    }
+
+    /**
+     * Shows the applications grid when the layout animation is over.
+     */
+    private class ShowGrid implements Animation.AnimationListener {
+        public void onAnimationStart(Animation animation) {
+        }
+
+        public void onAnimationEnd(Animation animation) {
+            mBlockAnimation = false;
+            // ViewDebug.stopHierarchyTracing();
+        }
+
+        public void onAnimationRepeat(Animation animation) {
+        }
+    }
+
+    /**
+     * Starts the selected activity/application in the grid view.
+     */
+    private class ApplicationLauncher implements AdapterView.OnItemClickListener {
+        public void onItemClick(AdapterView parent, View v, int position, long id) {
+            ApplicationInfo app = (ApplicationInfo) parent.getItemAtPosition(position);
+            //startActivity(app.intent);
+            ActivityLauncher aLauncher = new ActivityLauncher(app.intent);
+            aLauncher.launch();
+        }
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 02/05/2011
+     *
+     * Launch intents in separate thread to avoid ANR crashing the CS.
+     *
+     */
+    private class ActivityLauncher {
+        private Intent intent;
+
+        public ActivityLauncher(Intent intent) {
+            this.intent = intent;
+        }
+
+        public void launch() {
+            new Thread(new Runnable() {
+                public void run() {
+                   startActivity(intent);
+                }
+            }).start();
+
+        }
+    }
+    /**
+     * When a drawable is attached to a View, the View gives the Drawable its dimensions
+     * by calling Drawable.setBounds(). In this application, the View that draws the
+     * wallpaper has the same size as the screen. However, the wallpaper might be larger
+     * that the screen which means it will be automatically stretched. Because stretching
+     * a bitmap while drawing it is very expensive, we use a ClippedDrawable instead.
+     * This drawable simply draws another wallpaper but makes sure it is not stretched
+     * by always giving it its intrinsic dimensions. If the wallpaper is larger than the
+     * screen, it will simply get clipped but it won't impact performance.
+     */
+    private class ClippedDrawable extends Drawable {
+        private final Drawable mWallpaper;
+
+        public ClippedDrawable(Drawable wallpaper) {
+            mWallpaper = wallpaper;
+        }
+
+        @Override
+        public void setBounds(int left, int top, int right, int bottom) {
+            super.setBounds(left, top, right, bottom);
+            // Ensure the wallpaper is as large as it really is, to avoid stretching it
+            // at drawing time
+            mWallpaper.setBounds(left, top, left + mWallpaper.getIntrinsicWidth(),
+                    top + mWallpaper.getIntrinsicHeight());
+        }
+
+        public void draw(Canvas canvas) {
+            mWallpaper.draw(canvas);
+        }
+
+        public void setAlpha(int alpha) {
+            mWallpaper.setAlpha(alpha);
+        }
+
+        public void setColorFilter(ColorFilter cf) {
+            mWallpaper.setColorFilter(cf);
+        }
+
+        public int getOpacity() {
+            return mWallpaper.getOpacity();
+        }
+    }
+}
\ No newline at end of file
diff --git a/packages/apps/WindowApps/Android.mk b/packages/apps/WindowApps/Android.mk
new file mode 100755
index 0000000..ecca83a
--- /dev/null
+++ b/packages/apps/WindowApps/Android.mk
@@ -0,0 +1,30 @@
+#
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_SRC_FILES := $(call all-subdir-java-files)
+
+LOCAL_PACKAGE_NAME := WindowApps
+
+LOCAL_PROGUARD_FLAG_FILES := proguard.flags
+
+LOCAL_CERTIFICATE := platform
+
+include $(BUILD_PACKAGE)
diff --git a/packages/apps/WindowApps/AndroidManifest.xml b/packages/apps/WindowApps/AndroidManifest.xml
new file mode 100644
index 0000000..70069f5
--- /dev/null
+++ b/packages/apps/WindowApps/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.example.windowapps"
+    >
+
+    <application
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name="com.example.windowapps.MainActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/packages/apps/WindowApps/CleanSpec.mk b/packages/apps/WindowApps/CleanSpec.mk
new file mode 100755
index 0000000..fae7663
--- /dev/null
+++ b/packages/apps/WindowApps/CleanSpec.mk
@@ -0,0 +1,49 @@
+# Copyright (C) 2007 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# If you don't need to do a full clean build but would like to touch
+# a file or delete some intermediate files, add a clean step to the end
+# of the list.  These steps will only be run once, if they haven't been
+# run before.
+#
+# E.g.:
+#     $(call add-clean-step, touch -c external/sqlite/sqlite3.h)
+#     $(call add-clean-step, rm -rf $(PRODUCT_OUT)/obj/STATIC_LIBRARIES/libz_intermediates)
+#
+# Always use "touch -c" and "rm -f" or "rm -rf" to gracefully deal with
+# files that are missing or have been moved.
+#
+# Use $(PRODUCT_OUT) to get to the "out/target/product/blah/" directory.
+# Use $(OUT_DIR) to refer to the "out" directory.
+#
+# If you need to re-do something that's already mentioned, just copy
+# the command and add it to the bottom of the list.  E.g., if a change
+# that you made last week required touching a file and a change you
+# made today requires touching the same file, just copy the old
+# touch step and add it to the end of the list.
+#
+# ************************************************
+# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST
+# ************************************************
+
+# For example:
+#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/APPS/AndroidTests_intermediates)
+#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/core_intermediates)
+#$(call add-clean-step, find $(OUT_DIR) -type f -name "IGTalkSession*" -print0 | xargs -0 rm -f)
+#$(call add-clean-step, rm -rf $(PRODUCT_OUT)/data/*)
+
+# ************************************************
+# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST
+# ************************************************
\ No newline at end of file
diff --git a/packages/apps/WindowApps/proguard.flags b/packages/apps/WindowApps/proguard.flags
new file mode 100755
index 0000000..0429cec
--- /dev/null
+++ b/packages/apps/WindowApps/proguard.flags
@@ -0,0 +1,36 @@
+-optimizationpasses 5
+-dontusemixedcaseclassnames
+-dontskipnonpubliclibraryclasses
+-dontpreverify
+-verbose
+-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*
+
+-keep public class * extends android.app.Activity
+-keep public class * extends android.app.Application
+-keep public class * extends android.app.Service
+-keep public class * extends android.content.BroadcastReceiver
+-keep public class * extends android.content.ContentProvider
+-keep public class * extends android.app.backup.BackupAgentHelper
+-keep public class * extends android.preference.Preference
+-keep public class com.android.vending.licensing.ILicensingService
+
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
+
+-keepclasseswithmembernames class * {
+    public <init>(android.content.Context, android.util.AttributeSet);
+}
+
+-keepclasseswithmembernames class * {
+    public <init>(android.content.Context, android.util.AttributeSet, int);
+}
+
+-keepclassmembers enum * {
+    public static **[] values();
+    public static ** valueOf(java.lang.String);
+}
+
+-keep class * implements android.os.Parcelable {
+  public static final android.os.Parcelable$Creator *;
+}
\ No newline at end of file
diff --git a/packages/apps/WindowApps/res/drawable-hdpi/ic_launcher.png b/packages/apps/WindowApps/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 0000000000000000000000000000000000000000..288b66551d1efd1f13dd06f20a67534d2df57946
GIT binary patch
literal 7658
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
Y0e~A6&YDG)xBvhE07*qoM6N<$f<`;WUjP6A

literal 0
HcmV?d00001

diff --git a/packages/apps/WindowApps/res/drawable-mdpi/ic_launcher.png b/packages/apps/WindowApps/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 0000000000000000000000000000000000000000..6ae570b4db4da165fada0650079061cb56aa8793
GIT binary patch
literal 3777
zcmV;y4nFaTP)<h;3K|Lk000e1NJLTq001xm001xu1^@s6R|5Hm000h%Nkl<Zc-rk*
zc~lhlmWIT{$$2mHGV^pM35lX{rMsb_*=1=q5kyD8R@@Pk9h6<68=7vQn|)tf*-<vd
z6*m-(8}3_-xW*-}QJ><5O4m2Hnvj<n=gc`|GV=b&_1sf!QPp+7d%yeL->*wc>ks?G
z2G34C@E_ZLZKgG#r9IGlue=QUde;x0&cEf}-^JJmm+rK2tvlk-Rei)^T;Dlp|J|h@
z^m+gPwY2+#Jp|DwyKZ{cr#D)vv<3?RYtkmp$A#M_scJjzTH4xNh5}{7UZcq4B{H*L
zAbrC#D0V!CY|}%?3-2R&-YsP7u%Pze_gYZ0)AsviO2LRhr%`gXg-+>Ct8*6~gsguK
z#ocE}dD{&cL$1D$Nahk|Gw0#KoMAkBPxj3Dsk7U=vbNLla&#_VG^p9{qm1aoZlq4X
z^Cs&0V~Cl@NMI=QP@|Gq(}0&K#8vp=Jm%rVTTdK%=7x@k&di334&4O8uk5(sqd^Q_
zOZx$2J`a)j^giNo8<F@M6nKFGJV7RXR^lEK2tWt{@WqKYb8+zL47A^K!RBiYXgp*4
zQnk-AUJ9)b1|fK8UqZO!UC5qaVS;f5p%mzHTthf{7=EDR4~Wp5>q0Qj^e(~C7xVD#
zBM<EO(G?pn*|Pw!`df>htX326_pU@IUwD0ag^9a#=8X??`t?%Wdb<V}Un_9>?IN60
zFU5H#fIN^s2jJ9e3jX;b?0@8i_S^2*cGVr<-K)a(^8r}3&jQ&SjUUMBc)a)44{XT~
zKlMpG`6^Vs@6j}zdy)c%>BZfb9XR-87LGiduL=0*b8mD$U4(;==VR}EFYLPIfh||3
zVcW$8=vDXN$A_m-+HT1LV5F7&O24xA)DN34P8+uS&iwD&Z+kG?ZaSg;#ynhn(2U*J
z7o+`-JNDe0iH`fTu;=b9%D4zSZ+fEb+6-*E=!SLQIb-b!2XtJJqGfL^@-~|yYrPpH
zDuess3cWG!rE%Avcd_4iaawO{mmOL!+JO`WtzC|EbjIc@u9RgrY^6+ZxiSr#F1cYt
z*Hq9wXgcGBHOK8yeb|PmV}+va76iZo87&rwFVj~C$j1Kv_X7KXwa2GL)gQN2uQ_Rr
zhSN5hW^6noMAKP&G@o-s%Q+|V$!I=1Src^QDMwA<wMT@gJZMe9Pa^7=qo9ql-)fB1
zH3GyIav1OE(WUeV?S7Hyf8PIDZGes;eM<r@Z7Ch=56{f2*l*2L9<-!vTB7F2B-9?Y
zM%^(R)E~1Y7izrjsGTP0noe6(9kK!41JzzOcncJ6H$(1b6QnmAK~}>@bUv3^5H)(M
zP^vZL9y0!PAE}eBBhux_lLe!GGl+Xg{I`3M7LZhacjB4%!EKjCzGcV#KFV+LG)%3v
zI;N<bgq#g#DA{GM$!gU>D*|Lq0kdwSp$Z!~oArwQR+?+d_E@5L2TL6@q&1o#akT(Z
zndVr!!swDu+<3e83k&~x@|pkk9~tTM6EElYY`)@nyKIl?+yR4VyX-Qw{l?suT{mZ{
z*(PoMemYaUV^Z&mLId~RH+*9o4=!dx<tA{QGX~~PU&6@x-!(3<`2wc)U&74cOIS?S
zp}+OHsl5)2g<rsM(&yls4u_s#7&ykmVPy3=?568tUXUTYf;nXgDwD;l_FAc1&bd+*
z9Z|Hyj9FQtf7W}s?q>r6P}$-AS-}?D(>a?2OwLAAWHcK?T+U+_$Bd0H+2K@Gd&HJ$
zK4(wOI~lDPoJn0=(R6Yu>N}^R`de32>~TT)&M7Evb3nlsA@Vj^BY(3Mxh3+qS|V?Y
zS)T$?52Vx^VMU=nGe2_lzTo7E%M}fVOhKEu=9<*CMoe%rr^|hz&R+)vpssD+Kj*gE
zoK!aQ8D*m(lI!@IMw`3ro0N>T_T||djOZc8DBfj?(%oh#?=Xj|!-6<&si6w1GO7+M
zjn0?06YqERQKxVl%Y9R1t~VwM89`oa2yq!7%hL^**`d070_B|8lzKkH2G1srz%hZc
z-vXeM1z>wp(O|$R*76~zMvKYkFkT_Lsj1cW<t(u54FbxhF$HBpl4$y~n`yjYs~Ohp
zU5w7IN>uKetqCS~lPR({m>_c<1>YplWIm~qkCnxIgemozS;3?C_$TSDl-C+CIqbEq
zCX_fsCQz<-ZtC0-|1ux|s}J~mn%!!9EOm_mLm5F*l>q_Z!7FrBUUG$9S?XE?CUcz;
zh+<S~V*+AAnKeei=1FKd5Q3|B4nVDb3)bHD_Tc>W9jM#wgUl9lC@J$q4J1?cr4@Xv
zC^A5pf=2*!cl(LQ$CD~ia@YZ9!d8g!mvYVuy$9F>H9HpkDSMspa7w*ClU!#&57I|;
z9v8DiM&-*^2@8_z^qKT#L$FoI-DHfStwL-&CZ*-U8CoX1!GAY~{=Iqo3RiC*M)Te%
zDA$;id>WDp5j6|+5t7P<C{VX8Adw?Ws?w+4=&O{hnh$^Jgwu|q(SI2rfG8HgAvpyq
ztI?+i=_4wa$MUpTw#qI`R>Nb`n)s9@BLZQJyhcxS9^XxCB1Yr?ld<P}dwa37qZQ(O
zN2;nJ5>~MQ3=p1X3Q^FgE&dXYoUL}|I+_tJ#&iuIehCwfO`ksO(*Xf!Iu!m%R*UUE
zc`c7&Ga^~VLu3w@nG>d4k)*QEOswKDiUvL{1B{Tj(Hi$2Uqb!HG^7>#;p~OOc=P79
zChz@$_w>BNkrTU-kg)*u>vM4V`UyzNjY!!H2ml`u>60+if7F(xV!hNvs&+;T+b6~v
ziUmjwjtWJ?|2$v-+3W20CROujrO0C?6cJe*mZud`l`u20g3C~UKtrST7I@TsLlfxT
zpRS;)H68_3;ka<=6nb9w;Kb<zP!<KCvLzAsA6}>H)cE1ndBo=P5nsyo76C}JWC3gl
zkZ|)7R`ck4S(P$IA`2jqf51ZY)h7cRWNo2CvsxUsCspx?K0I1%ar*#-=vF6`StTc|
z=4yI_)CgJY`T+DB+q^gKoI_D<B%);QD5_eCTX(zYeD5z+VF5&C>yrXeZ{?DVDlFg`
zpxfl1z|Bn{y0R*zXb@;9=AXddKX3q-^M_`)IJ8MCx%4Gm#FcQdJVTF}6FhpYq}WnU
z=NLKl1}m|d&F23FK!4Ld>HZ1%bv}6cs{5C~`|aAz?+}rx&kisGV2EW3a}9tc@#FJY
zx+*F7)U^UyW)lFh;cgcft)T+~P<FiRqwHqKb&0Dvj9A5`OmPsFHlCRksJk|?)J85=
zahRlPeWVbLGMe56z}nO9N64-AB^o_{N0Yj)9LKUWjz*fJbBqv{Vg^tDQH@LE^h#L(
zZ1&kzs<@nwCGke>9Ff+?0|L;|Asv#_;@FTt0OHFyh%M6701yR@Xh<lrm5Iv<0MU!3
zQF^1<zyVzC0}!3Z0x(8MvI#u>M%MVnb5s%)PZNAfoq&3TkEL;fEkdEzkO3~En?B5L
zajKC}rsGQW5L2Ls5XCsgGjK$Mq}V!vK&jd0me&$r8_e+V>GgNy^9cdSsd^Ux+r$@t
z1`w6QLrks(A{4f8U!q&(C*hQd2|!A{fWF%Z@g;^#fY_p$Li%998y97*V@6yFM;%+J
zhsf-S2uK>I_E@4@oT74;usf*43Le-QL9+r%l?Z3fANpB7e+8iO*8mv2eob<Eat}hq
z&Q#HftTZD!+Z>TfXUy;&SF<F>z++{h$;;GQAtS4_Vq$VFUj<3*L;5#51F~?1#Tb8y
zL3@D2^r?3g|EcHFi5)Jpzy7AMc}bkC!m1Ad^#NOjxKa*H%yGz41rWbaX%y#4_d^YU
zS3S>YfW0Mvhat=L#{BRx@Jk$z@C-IFEC35cE8XDk!zmX^g+n5;Y^E!#yej1?&-!I4
z*7HL{U55VF4Vm_IpYfm03*qrZemoxgSt^x&P}~w2oLp(ECMgBm2W%DCBg<X3TFaDt
zngbE&x_k<`HNHfb(@+!y!cWYjtm`2nTO-L7Jco{4L}ghbO5w(MEas%K&(v&Q`d#by
z*&}QJdas(X%9krCwtu*?grkvIwil%Ayr7D(Lx>%Eu?1ZCOGtXt46rC#51~p{aY#0c
z`aGt9nm3n+@Jucu(`^teae7G<a`?Rh{@;HWqAEly9jOeQzeQ&2Gb@XXNiB>t>w0my
z;V&Ln!n%O8UVy%9OsOf&5Lax5m^@RWkO0AQV<tG!=EdS@L%B%A`B>|HnW#zhVNjC5
z&QD@+Hdsah<~Spv&<&Cz7l@0TATD-5La7szST==8DxV7Zs{bJOfUMjT(h?8E<+;)F
z!Txoy+^oY-%AX;UzQ^EytyJMjQ?gy>e-5`rU&AY8B9^Q)L6}^K6<My&6N^3X$jiJQ
zrl{t2Cl!kz&YOYAv?=h5x4^7GE+g_a?G%M`{&i4)VoxY^O<fp05+43v!Fi4j?A&!=
z<MtISopdU+q*@<H$^F8oE;4ocOl>uFI2=56;OsRLQ@nJU84FF?X+ZtcpuQhaRJtXG
zD#wv5j=}th(WK?Nm^^zVY^Qx)p{04H1a1Eam)SPchpC-reSv9<bZKCH19#tVFw@6$
z@Bw7h&yYstPN0R}1Oz2dz{2Qpn&2EgM*adIC}xVsWUtSA-ItEQyyas_l_t<E7>~ID
z7K0BUr^!7&reGoynL827)AeXt>rs#sFm=wD@_tQ^l)HO)28`%k7(JSHS2WS3T=>T6
zVPTl%AOoP_((0%B#uRYWQ3QY;PNAthc*p87(-(~w_s@@*G!OGdG2?n@Z;MccKEjmj
zCWXg%N1Cl3@FMN^ww3wT!<VHQZjH{gc^j2!qmD{<>Rl3Nx>pqNmCoPihHyw&svtvB
z==>~sl?Ri&TGShnW^;H!%-D(l5HGuff;fK;5F6Qtr8xR6OL27eUe15#ClL1K1%cH|
ruJZJht7Zygm5zVW`osRPe+>Ii)X|D+8y7?e00000NkvXXu0mjf#L-I;

literal 0
HcmV?d00001

diff --git a/packages/apps/WindowApps/res/drawable-xhdpi/ic_launcher.png b/packages/apps/WindowApps/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000000000000000000000000000000000..d4fb7cd9d868f1d7d9964f1686dcbc018ef9495a
GIT binary patch
literal 12516
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

literal 0
HcmV?d00001

diff --git a/packages/apps/WindowApps/res/drawable-xxhdpi/ic_launcher.png b/packages/apps/WindowApps/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000000000000000000000000000000000..85a6081587e2c2b9793d796ee7b07e12fdf860db
GIT binary patch
literal 24777
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

literal 0
HcmV?d00001

diff --git a/packages/apps/WindowApps/res/layout/activity_main.xml b/packages/apps/WindowApps/res/layout/activity_main.xml
new file mode 100644
index 0000000..325968d
--- /dev/null
+++ b/packages/apps/WindowApps/res/layout/activity_main.xml
@@ -0,0 +1,28 @@
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    tools:context=".MainActivity" >
+
+    <Button
+        android:id="@+id/btn_save"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:onClick="onBtnSaveClick"
+        android:text="@string/save" />
+
+    <Button
+        android:id="@+id/btn_get"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:onClick="onBtnGetClick"
+        android:text="@string/get" />
+
+    <ListView
+        android:id="@+id/lv"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content" >
+    </ListView>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/packages/apps/WindowApps/res/layout/list.xml b/packages/apps/WindowApps/res/layout/list.xml
new file mode 100644
index 0000000..11f01c1
--- /dev/null
+++ b/packages/apps/WindowApps/res/layout/list.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="horizontal" >
+
+    <ImageView
+        android:id="@+id/img"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_vertical" />
+
+    <TextView
+        android:id="@+id/title"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:textSize="18dip" />
+
+    <CheckBox
+        android:id="@+id/cb"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:checkMark="?android:attr/listChoiceIndicatorMultiple"
+        android:clickable="false"
+        android:focusable="false"
+        android:focusableInTouchMode="false" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/packages/apps/WindowApps/res/menu/main.xml b/packages/apps/WindowApps/res/menu/main.xml
new file mode 100644
index 0000000..c002028
--- /dev/null
+++ b/packages/apps/WindowApps/res/menu/main.xml
@@ -0,0 +1,9 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android" >
+
+    <item
+        android:id="@+id/action_settings"
+        android:orderInCategory="100"
+        android:showAsAction="never"
+        android:title="@string/action_settings"/>
+
+</menu>
diff --git a/packages/apps/WindowApps/res/values-sw600dp/dimens.xml b/packages/apps/WindowApps/res/values-sw600dp/dimens.xml
new file mode 100644
index 0000000..44f01db
--- /dev/null
+++ b/packages/apps/WindowApps/res/values-sw600dp/dimens.xml
@@ -0,0 +1,8 @@
+<resources>
+
+    <!--
+         Customize dimensions originally defined in res/values/dimens.xml (such as
+         screen margins) for sw600dp devices (e.g. 7" tablets) here.
+    -->
+
+</resources>
diff --git a/packages/apps/WindowApps/res/values-sw720dp-land/dimens.xml b/packages/apps/WindowApps/res/values-sw720dp-land/dimens.xml
new file mode 100644
index 0000000..61e3fa8
--- /dev/null
+++ b/packages/apps/WindowApps/res/values-sw720dp-land/dimens.xml
@@ -0,0 +1,9 @@
+<resources>
+
+    <!--
+         Customize dimensions originally defined in res/values/dimens.xml (such as
+         screen margins) for sw720dp devices (e.g. 10" tablets) in landscape here.
+    -->
+    <dimen name="activity_horizontal_margin">128dp</dimen>
+
+</resources>
diff --git a/packages/apps/WindowApps/res/values-v11/styles.xml b/packages/apps/WindowApps/res/values-v11/styles.xml
new file mode 100644
index 0000000..3c02242
--- /dev/null
+++ b/packages/apps/WindowApps/res/values-v11/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+    <!--
+        Base application theme for API 11+. This theme completely replaces
+        AppBaseTheme from res/values/styles.xml on API 11+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light">
+        <!-- API 11 theme customizations can go here. -->
+    </style>
+
+</resources>
diff --git a/packages/apps/WindowApps/res/values-v14/styles.xml b/packages/apps/WindowApps/res/values-v14/styles.xml
new file mode 100644
index 0000000..a91fd03
--- /dev/null
+++ b/packages/apps/WindowApps/res/values-v14/styles.xml
@@ -0,0 +1,12 @@
+<resources>
+
+    <!--
+        Base application theme for API 14+. This theme completely replaces
+        AppBaseTheme from BOTH res/values/styles.xml and
+        res/values-v11/styles.xml on API 14+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- API 14 theme customizations can go here. -->
+    </style>
+
+</resources>
diff --git a/packages/apps/WindowApps/res/values/dimens.xml b/packages/apps/WindowApps/res/values/dimens.xml
new file mode 100644
index 0000000..55c1e59
--- /dev/null
+++ b/packages/apps/WindowApps/res/values/dimens.xml
@@ -0,0 +1,7 @@
+<resources>
+
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+
+</resources>
diff --git a/packages/apps/WindowApps/res/values/strings.xml b/packages/apps/WindowApps/res/values/strings.xml
new file mode 100644
index 0000000..6db70a8
--- /dev/null
+++ b/packages/apps/WindowApps/res/values/strings.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">WindowApps</string>
+    <string name="action_settings">Settings</string>
+    <string name="hello_world">Hello world!</string>
+    <string name="get">Get</string>
+    <string name="set">Set</string>
+    <string name="save">Save</string>
+
+</resources>
diff --git a/packages/apps/WindowApps/res/values/styles.xml b/packages/apps/WindowApps/res/values/styles.xml
new file mode 100644
index 0000000..6ce89c7
--- /dev/null
+++ b/packages/apps/WindowApps/res/values/styles.xml
@@ -0,0 +1,20 @@
+<resources>
+
+    <!--
+        Base application theme, dependent on API level. This theme is replaced
+        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Light">
+        <!--
+            Theme customizations available in newer API levels can go in
+            res/values-vXX/styles.xml, while customizations related to
+            backward-compatibility can go here.
+        -->
+    </style>
+
+    <!-- Application theme. -->
+    <style name="AppTheme" parent="AppBaseTheme">
+        <!-- All customizations that are NOT specific to a particular API-level can go here. -->
+    </style>
+
+</resources>
diff --git a/packages/apps/WindowApps/src/com/example/windowapps/MainActivity.java b/packages/apps/WindowApps/src/com/example/windowapps/MainActivity.java
new file mode 100644
index 0000000..d52ddf3
--- /dev/null
+++ b/packages/apps/WindowApps/src/com/example/windowapps/MainActivity.java
@@ -0,0 +1,213 @@
+package com.example.windowapps;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import com.example.windowapps.MainActivity.MyAdapter.ViewHolder;
+
+import android.os.Bundle;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.graphics.drawable.Drawable;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.BaseAdapter;
+import android.widget.CheckBox;
+import android.widget.ImageView;
+import android.widget.ListView;
+import android.widget.TextView;
+
+import android.app.WindowAppsManager;
+
+public class MainActivity extends Activity {
+    WindowAppsManager mWindowAppsManager;
+    ListView mListView;
+    MyAdapter mAdapter;
+    SharedPreferences mSharedPreferences;
+    ArrayList<String> mPKGList;
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+
+        mSharedPreferences = getSharedPreferences("window_apps_strings", 0);
+        String pkgs = mSharedPreferences.getString("pkgs", "");
+        mPKGList = parseString2List(pkgs);
+        Log.d("TAG","Ritter::APP mPKGList.size:"+mPKGList.size());
+        mWindowAppsManager = (WindowAppsManager) this
+                .getSystemService("window_apps");
+
+        mListView = (ListView) findViewById(R.id.lv);
+        mAdapter = new MyAdapter(this);
+        mListView.setAdapter(mAdapter);
+        mListView.setItemsCanFocus(false);
+        mListView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
+
+        mListView.setOnItemClickListener(new OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view,
+                    int position, long id) {
+                ViewHolder vHollder = (ViewHolder) view.getTag();
+                vHollder.cBox.toggle();
+                mAdapter.mSelectedMap.put(position, vHollder.cBox.isChecked());
+            }
+        });
+
+
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        getMenuInflater().inflate(R.menu.main, menu);
+        return true;
+    }
+
+    @Override
+    protected void onResume(){
+        super.onResume();
+        //When device reboot, make the service hold values.
+        saveToService();
+    }
+
+    public void onBtnSaveClick(View v) {
+        saveToService();
+    }
+
+    private void saveToService() {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < mAdapter.mSelectedMap.size(); i++) {
+            if (mAdapter.mSelectedMap.get(i)) {
+                Log.d("TAG", "--onClick --"
+                        + mAdapter.mData.get(i).get("title"));
+                Log.d("TAG", "--onClick --" + mAdapter.mData.get(i).get("pkg"));
+                sb.append(mAdapter.mData.get(i).get("pkg"));
+                sb.append("#");
+            }
+        }
+        if(sb.length()>0){
+            sb.deleteCharAt(sb.length()-1);
+        }
+        Log.d("TAG","Ritter::APP onBtnSaveClick:"+sb.toString());
+        mSharedPreferences.edit().putString("pkgs", sb.toString()).commit();
+
+        try {
+            mWindowAppsManager.setWindowApps(sb.toString());
+        } catch (Exception e){
+            e.printStackTrace();
+        }
+    }
+
+    public void onBtnGetClick(View v){
+        String APPs = "";
+        try {
+            APPs = mWindowAppsManager.getWindowApps();
+        } catch (Exception e){
+            e.printStackTrace();
+        }
+        Log.d("TAG","Ritter::APP onBtnGetClick APPS:"+APPs);
+    }
+
+    private ArrayList<String> parseString2List(String s){
+        ArrayList<String> res;
+        res = new ArrayList<String>(Arrays.asList(s.split("#")));
+        return res;
+    }
+
+    class MyAdapter extends android.widget.BaseAdapter {
+        private LayoutInflater mInflater;
+        private List<Map<String, Object>> mData;
+        public Map<Integer, Boolean> mSelectedMap;
+
+        public MyAdapter(Context context) {
+            mInflater = LayoutInflater.from(context);
+            init();
+        }
+
+        private void init() {
+            mData = new ArrayList<Map<String, Object>>();
+            mSelectedMap = new HashMap<Integer, Boolean>();
+
+            PackageManager packageManager = getPackageManager();
+            Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
+            mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+            List<ResolveInfo> resolveInfos = packageManager
+                    .queryIntentActivities(mainIntent, 0);
+            Collections.sort(resolveInfos,
+                    new ResolveInfo.DisplayNameComparator(packageManager));
+            Log.d("TAG","Ritter::APP init APPS resolveInfos.size():"+resolveInfos.size());
+            for (int i=0;i< resolveInfos.size();i++) {
+                String activityName = resolveInfos.get(i).activityInfo.name;
+                String pkgName = resolveInfos.get(i).activityInfo.packageName;
+                String appLabel = (String) resolveInfos.get(i).loadLabel(packageManager);
+                Drawable icon = resolveInfos.get(i).loadIcon(packageManager);
+                Map<String, Object> map = new HashMap<String, Object>();
+                map.put("img", icon);
+                map.put("title", appLabel);
+                map.put("pkg", pkgName);
+                mData.add(map);
+                if(mPKGList.contains(pkgName)){
+                    mSelectedMap.put(i, true);
+                } else {
+                    mSelectedMap.put(i, false);
+                }
+            }
+        }
+
+        @Override
+        public int getCount() {
+            return mData.size();
+        }
+
+        @Override
+        public Object getItem(int position) {
+            return null;
+        }
+
+        @Override
+        public long getItemId(int position) {
+            return 0;
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            ViewHolder holder = null;
+            if (convertView == null) {
+                holder = new ViewHolder();
+                convertView = mInflater.inflate(R.layout.list, null);
+                holder.img = (ImageView) convertView.findViewById(R.id.img);
+                holder.title = (TextView) convertView.findViewById(R.id.title);
+                holder.cBox = (CheckBox) convertView.findViewById(R.id.cb);
+                convertView.setTag(holder);
+            } else {
+                holder = (ViewHolder) convertView.getTag();
+            }
+            holder.img.setImageDrawable((Drawable) mData.get(position).get(
+                    "img"));
+            holder.title.setText(mData.get(position).get("title").toString());
+            holder.pkgName = (mData.get(position).get("pkg").toString());
+            holder.cBox.setChecked(mSelectedMap.get(position));
+            return convertView;
+        }
+
+        public final class ViewHolder {
+            public ImageView img;
+            public TextView title;
+            public CheckBox cBox;
+            public String pkgName;
+        }
+    }
+
+}
